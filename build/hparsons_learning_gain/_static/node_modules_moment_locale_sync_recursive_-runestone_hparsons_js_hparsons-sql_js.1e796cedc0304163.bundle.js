(self["webpackChunkWebComponents"] = self["webpackChunkWebComponents"] || []).push([["node_modules_moment_locale_sync_recursive_-runestone_hparsons_js_hparsons-sql_js"],{

/***/ 28528:
/*!***********************************************!*\
  !*** ./runestone/hparsons/css/hljs-xcode.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 32571:
/*!*********************************************!*\
  !*** ./runestone/hparsons/css/hparsons.css ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 40415,
	"./ka.js": 40415,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 13709,
	"./sr-cyrl.js": 13709,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./th": 9041,
	"./th.js": 9041,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 87036:
/*!************************************************!*\
  !*** ./runestone/hparsons/js/BlockFeedback.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BlockFeedback)
/* harmony export */ });
/* harmony import */ var _hparsonsFeedback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hparsonsFeedback */ 33965);
/* harmony import */ var _blockGrader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blockGrader.js */ 92753);
/* harmony import */ var _parsons_js_parsons_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../parsons/js/parsons-i18n.en.js */ 59164);
/* harmony import */ var _parsons_js_parsons_i18n_en_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_parsons_js_parsons_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _parsons_js_parsons_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../parsons/js/parsons-i18n.pt-br.js */ 16432);
/* harmony import */ var _parsons_js_parsons_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parsons_js_parsons_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__);





class BlockFeedback extends _hparsonsFeedback__WEBPACK_IMPORTED_MODULE_0__["default"] {
    createOutput() {
        // Block based grading output
        this.messageDiv = document.createElement("div");
        this.hparsons.outerDiv.appendChild(this.messageDiv);
    }
    customizeUI() {
        $(this.hparsons.runButton).text('Check Me');
    }

    init() {
        this.checkCount = 0;
        this.solved = false;
        // TODO: not sure what is the best way to do this
        this.grader = new _blockGrader_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        let solutionBlocks = [];
        for (let i = 0; i < this.hparsons.blockAnswer.length; ++i) {
            solutionBlocks.push(this.hparsons.originalBlocks[this.hparsons.blockAnswer[i]]);
        }
        this.solution = solutionBlocks;
        this.grader.solution = solutionBlocks;
        this.answerArea = this.hparsons.hparsonsInput.querySelector('.drop-area');
    }

    // Called when check button clicked (block-based Feedback)
    async runButtonHandler() {
        this.checkCurrentAnswer();
        this.renderFeedback();
    }

    // Used for block-based feedback
    checkCurrentAnswer() {
        if (!this.solved) {
            this.checkCount++;
            this.clearFeedback();
            this.grader.answer = this.hparsons.hparsonsInput.getParsonsTextArray();
            this.grade = this.grader.grade();
            if (this.grade == "correct") {
                $(this.hparsons.runButton).prop("disabled", true);
                this.solved = true;
            }
        }
    }

    renderFeedback() {
        this.grade = this.grader.graderState;
        var feedbackArea;
        var answerArea = $(this.answerArea);
        feedbackArea = $(this.messageDiv);

        if (this.grade === "correct") {
            answerArea.addClass("correct");
            feedbackArea.fadeIn(100);
            feedbackArea.attr("class", "alert alert-info");
            if (this.checkCount > 1) {
                feedbackArea.html(
                    $.i18n("msg_parson_correct", this.checkCount)
                );
            } else {
                feedbackArea.html($.i18n("msg_parson_correct_first_try"));
            }
            this.checkCount = 0;
        }

        if (this.grade === "incorrectTooShort") {
            // too little code
            answerArea.addClass("incorrect");
            feedbackArea.fadeIn(500);
            feedbackArea.attr("class", "alert alert-danger");
            feedbackArea.html($.i18n("msg_parson_too_short"));
        }

        if (this.grade === "incorrectMoveBlocks") {
            var answerBlocks = this.answerArea.children;
            var inSolution = [];
            var inSolutionIndexes = [];
            var notInSolution = [];
            for (let i = 0; i < answerBlocks.length; i++) {
                var block = answerBlocks[i];
                var index = this.solution.indexOf(block.textContent);
                if (index == -1) {
                    notInSolution.push(block);
                } else {
                    inSolution.push(block);
                    inSolutionIndexes.push(index);
                }
            }
            var lisIndexes = this.grader.inverseLISIndices(inSolutionIndexes);
            for (let i = 0; i < lisIndexes.length; i++) {
                notInSolution.push(inSolution[lisIndexes[i]]);
            }
            answerArea.addClass("incorrect");
            feedbackArea.fadeIn(500);
            feedbackArea.attr("class", "alert alert-danger");
            for (let i = 0; i < notInSolution.length; i++) {
                $(notInSolution[i]).addClass("incorrectPosition");
            }
            feedbackArea.html($.i18n("msg_parson_wrong_order"));
        }
    }

    // Feedback UI for Block-based Feedback
    clearFeedback() {
        $(this.answerArea).removeClass("incorrect correct");
        var children = this.answerArea.childNodes;
        for (var i = 0; i < children.length; i++) {
            $(children[i]).removeClass(
                "correctPosition incorrectPosition"
            );
        }
        $(this.messageDiv).hide();
    }

    reset() {
        if (this.solved) {
            this.checkCount = 0;
            $(this.hparsons.runButton).prop("disabled", false);
            this.solved = false;
        }
        this.clearFeedback();
    }

}

/***/ }),

/***/ 3291:
/*!**********************************************!*\
  !*** ./runestone/hparsons/js/SQLFeedback.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SQLFeedback)
/* harmony export */ });
/* harmony import */ var _hparsonsFeedback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hparsonsFeedback */ 33965);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sql.js/dist/sql-wasm.js */ 26657);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var handsontable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! handsontable */ 36080);
/* harmony import */ var handsontable_dist_handsontable_full_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! handsontable/dist/handsontable.full.css */ 59823);





var allDburls = {};

class SQLFeedback extends _hparsonsFeedback__WEBPACK_IMPORTED_MODULE_0__["default"] {

    createOutput() {
        var outDiv = document.createElement("div");
        $(outDiv).addClass("hp_output col-md-12");
        this.outDiv = outDiv;
        this.output = document.createElement("pre");
        this.output.id = this.hparsons.divid + "_stdout";
        $(this.output).css("visibility", "hidden");
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.hparsons.outerDiv.appendChild(clearDiv);
        outDiv.appendChild(this.output);
        this.hparsons.outerDiv.appendChild(outDiv);
        clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.hparsons.outerDiv.appendChild(clearDiv);
    }

    renderFeedback() {
        if (this.testResult) {
            $(this.output).text(this.testResult);
            $(this.output).css("visibility", "visible");
        }
        $(this.outDiv).show();
    }

    clearFeedback() {
        $(this.outDiv).hide();
    }

    reset() {
        this.clearFeedback();
    }

    init() {
        // adapted from activecode-sql
        // fnprefix sets the path to load the sql-wasm.wasm file
        var bookprefix;
        var fnprefix;
        if (eBookConfig.useRunestoneServices) {
            bookprefix = `${eBookConfig.app}/books/published/${eBookConfig.basecourse}`;
            fnprefix = bookprefix + "/_static";
        } else {
            bookprefix = "";
            fnprefix = "/_static";
        }
        let SQLconfig = {
            locateFile: (filename) => `${fnprefix}/${filename}`,
        };
        var self = this.hparsons;
        sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_1___default()(SQLconfig).then(function (SQL) {
            // set up call to load database asynchronously if given
            if (self.dburl) {
                if (self.dburl.startsWith("/_static")) {
                    self.dburl = `${bookprefix}${self.dburl}`;
                }
                $(self.runButton).attr("disabled", "disabled");
                let buttonText = $(self.runButton).text();
                $(self.runButton).text($.i18n("msg_activecode_load_db"));
                if (!(self.dburl in allDburls)) {
                    allDburls[self.dburl] = {
                        status: "loading",
                        xWaitFor: jQuery.Deferred(),
                    };
                } else {
                    if (allDburls[self.dburl].status == "loading") {
                        allDburls[self.dburl].xWaitFor.done(function () {
                            self.db = allDburls[self.dburl].dbObject;
                            $(self.runButton).removeAttr("disabled");
                            $(self.runButton).text(buttonText);
                        });
                        return;
                    }
                    self.db = allDburls[self.dburl].dbObject;
                    $(self.runButton).removeAttr("disabled");
                    $(self.runButton).text(buttonText);
                    return;
                }
                var xhr = new XMLHttpRequest();
                // For example: https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite
                xhr.open("GET", self.dburl, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = (e) => {
                    var uInt8Array = new Uint8Array(xhr.response);
                    self.db = new SQL.Database(uInt8Array);
                    allDburls[self.dburl].dbObject = self.db;
                    $(self.runButton).text(buttonText);
                    $(self.runButton).removeAttr("disabled");
                    allDburls[self.dburl].db = uInt8Array;
                    allDburls[self.dburl].status = "ready";
                    allDburls[self.dburl].xWaitFor.resolve();
                    // contents is now [{columns:['col1','col2',...], values:[[first row], [second row], ...]}]
                };
                xhr.send();
            } else {
                self.db = new SQL.Database();
            }
        });
    }

    // adapted from activecode - SQL
    async runButtonHandler() {
        // Disable the run button until the run is finished.
        this.hparsons.runButton.disabled = true;
        try {
            await this.runProg();
        } catch (e) {
            console.log(`there was an error ${e} running the code`);
        }
        this.logCurrentAnswer();
        this.renderFeedback();
        // The run is finished; re-enable the button.
        this.hparsons.runButton.disabled = false;
    }

    // adapted from activecode-sql
    async runProg() {
        // Clear any old results
        let divid = this.hparsons.divid + "_sql_out";
        let respDiv = document.getElementById(divid);
        if (respDiv) {
            respDiv.parentElement.removeChild(respDiv);
        }
        $(this.output).text("");
        // Run this query
        let query = await this.buildProg();
        if (!this.hparsons.db) {
            $(this.output).text(
                `Error: Database not initialized! DBURL: ${this.dburl}`
            );
            return;
        }

        let it = this.hparsons.db.iterateStatements(query);
        this.results = [];
        try {
            for (let statement of it) {
                let columns = statement.getColumnNames();
                if (columns.length > 0) {
                    // data! probably a SELECT
                    let data = [];
                    while (statement.step()) {
                        data.push(statement.get());
                    }
                    this.results.push({
                        status: "success",
                        columns: columns,
                        values: data,
                        rowcount: data.length,
                    });
                } else {
                    let nsql = statement.getNormalizedSQL();
                    let prefix = nsql.substr(0, 6).toLowerCase();
                    statement.step(); // execute the query
                    // Try to detect INSERT/UPDATE/DELETE to give friendly feedback
                    // on rows modified - unfortunately, this won't catch such queries
                    // if they use CTEs.  There seems to be no reliable way of knowing
                    // when a SQLite query actually modified data.
                    if (
                        prefix === "insert" ||
                        prefix === "update" ||
                        prefix === "delete"
                    ) {
                        this.results.push({
                            status: "success",
                            operation: prefix,
                            rowcount: this.db.getRowsModified(),
                        });
                    } else {
                        this.results.push({ status: "success" });
                    }
                }
            }
        } catch (e) {
            this.results.push({
                status: "failure",
                message: e.toString(),
                sql: it.getRemainingSQL(),
            });
        }

        if (this.results.length === 0) {
            this.results.push({
                status: "failure",
                message: "No queries submitted.",
            });
        }

        respDiv = document.createElement("div");
        respDiv.id = divid;
        this.outDiv.appendChild(respDiv);
        $(this.outDiv).show();
        // Sometimes we don't want to show a bunch of intermediate results
        // like when we are including a bunch of previous statements from
        // other activecodes In that case the showlastsql flag can be set
        // so we only show the last result
        let resultArray = this.results;
        for (let r of resultArray) {
            let section = document.createElement("div");
            section.setAttribute("class", "hp_sql_result");
            respDiv.appendChild(section);
            if (r.status === "success") {
                if (r.columns) {
                    let tableDiv = document.createElement("div");
                    section.appendChild(tableDiv);
                    let maxHeight = 350;
                    if (resultArray.length > 1) maxHeight = 200; // max height smaller if lots of results
                    createTable(r, tableDiv, maxHeight);
                    let messageBox = document.createElement("pre");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    let msg = "" + r.rowcount + rmsg + "returned";
                    if (r.rowcount > 100) {
                        msg = msg + " (only first 100 rows displayed)";
                    }
                    msg = msg + ".";
                    messageBox.textContent = msg;
                    messageBox.setAttribute("class", "hp_sql_result_success");
                    section.appendChild(messageBox);
                } else if (r.rowcount) {
                    let messageBox = document.createElement("pre");
                    let op = r.operation;
                    op = op + (op.charAt(op.length - 1) === "e" ? "d." : "ed.");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    messageBox.textContent = "" + r.rowcount + rmsg + op;
                    messageBox.setAttribute("class", "hp_sql_result_success");
                    section.appendChild(messageBox);
                } else {
                    let messageBox = document.createElement("pre");
                    messageBox.textContent = "Operation succeeded.";
                    messageBox.setAttribute("class", "hp_sql_result_success");
                    section.appendChild(messageBox);
                }
            } else {
                let messageBox = document.createElement("pre");
                messageBox.textContent = r.message;
                messageBox.setAttribute("class", "hp_sql_result_failure");
                section.appendChild(messageBox);
            }
        }

        // Now handle autograding
        if (this.hparsons.unittest) {
            this.testResult = this.autograde(
                this.results[this.results.length - 1]
            );
        } else {
            $(this.output).css("visibility", "hidden");
        }

        return Promise.resolve("done");
    }

    // adapted from activecode
    async buildProg() {
        // TODO: fix text entry
        var prog;
        if (this.hparsons.textentry) {
            prog = this.hparsons.hparsonsInput.getCurrentInput();
        } else {
            prog = this.hparsons.hparsonsInput.getParsonsTextArray().join(' ') + "\n";
        }
        return Promise.resolve(prog);
    }

    // copied from activecode-sql
    async logCurrentAnswer(sid) {
        // commenting these out for now
        // Not sure if we need to log run event in horizontal parsons
        // let data = {
        //     div_id: this.hparsons.divid,
        //     code: this.hparsons.hparsonsInput.getParsonsTextArray(),
        //     language: "sql",
        //     // errinfo: this.results[this.results.length - 1].status,
        //     to_save: this.hparsons.saveCode,
        //     prefix: this.hparsons.pretext,
        //     suffix: this.hparsons.suffix,
        // }; // Log the run event
        // if (typeof sid !== "undefined") {
        //     data.sid = sid;
        // }
        // await this.hparsons.logRunEvent(data);

        if (this.unit_results) {
            let unitData = {
                event: "unittest",
                div_id: this.hparsons.divid,
                course: eBookConfig.course,
                act: this.unit_results,
            };
            if (typeof sid !== "undefined") {
                unitData.sid = sid;
            }
            await this.hparsons.logBookEvent(unitData);
        }
    }

    // might move to base class if used by multiple execution based feedback
    autograde(result_table) {
        var tests = this.hparsons.unittest;
        this.passed = 0;
        this.failed = 0;
        // Tests should be of the form
        // assert row,col oper value for example
        // assert 4,4 == 3
        var result = "";
        tests = tests.filter(function (s) {
            return s.indexOf("assert") > -1;
        });
        for (let test of tests) {
            let wlist = test.split(/\s+/);
            wlist.shift();
            let loc = wlist.shift();
            let oper = wlist.shift();
            let expected = wlist.join(" ");
            let [row, col] = loc.split(",");
            result += this.testOneAssert(
                row,
                col,
                oper,
                expected,
                result_table
            );
            result += "\n";
        }
        let pct = (100 * this.passed) / (this.passed + this.failed);
        pct = pct.toLocaleString(undefined, { maximumFractionDigits: 2 });
        result += `You passed ${this.passed} out of ${this.passed + this.failed
            } tests for ${pct}%`;
        this.unit_results = `percent:${pct}:passed:${this.passed}:failed:${this.failed}`;
        return result;
    }

    // might move to base class if used by multiple execution based feedback
    testOneAssert(row, col, oper, expected, result_table) {
        // make sure row and col are in bounds
        let actual;
        let output = "";
        try {
            actual = result_table.values[row][col];
        } catch (e) {
            if (expected == 'NO_DATA') {
                this.passed++;
                output = `Passed: No data in row ${row}, column ${col}`;
                return output;
            } else {
                output = `Failed: Not enough data to check row ${row} or column ${col}`;
                return output;
            }
        }
        const operators = {
            "==": function (operand1, operand2) {
                return operand1 == operand2;
            },
            "!=": function (operand1, operand2) {
                return operand1 != operand2;
            },
            ">": function (operand1, operand2) {
                return operand1 > operand2;
            },
            "<": function (operand1, operand2) {
                return operand1 > operand2;
            },
        };
        let res = operators[oper](actual, expected);
        if (res) {
            output = `Pass: ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.passed++;
        } else {
            output = `Failed ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.failed++;
        }
        return output;
    }
}

function createTable(tableData, container, maxHeight) {
    let data = tableData.values;
    let trimRows = undefined;
    if (data.length === 0) {
        // kludge: no column headers will show up unless we do this
        data = [tableData.columns.map((e) => null)];
        trimRows = [0];
    }

    var hot = new handsontable__WEBPACK_IMPORTED_MODULE_2__["default"](container, {
        data: data,
        trimRows: trimRows,
        width: "100%",
        height: maxHeight,
        autoRowSize: true,
        autoColumnSize: { useHeaders: true },
        rowHeaders: false,
        colHeaders: tableData.columns,
        editor: false,
        maxRows: 100,
        filters: false,
        dropdownMenu: false,
        licenseKey: "non-commercial-and-evaluation",
    });

    // calculate actual height and resize
    let actualHeight = 40; // header height + small margin
    if (tableData.values.length > 0) {
        for (let i = 0; i < data.length; i++) {
            actualHeight = actualHeight + hot.getRowHeight(i);
            if (actualHeight > maxHeight) break;
        }
    }

    hot.updateSettings({ height: actualHeight });

    return hot;
}


/***/ }),

/***/ 92753:
/*!**********************************************!*\
  !*** ./runestone/hparsons/js/blockGrader.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BlockBasedGrader)
/* harmony export */ });
// This file is adapted from lineGrader in parsons directive.
// We could have fit our data structure to use the original LineBasedGrader directly,
// but that would result in changes in parsons directive affecting this, so we created a copy
// instead.

class BlockBasedGrader {
    constructor(problem) {
        this.problem = problem;
    }
    // Use a LIS (Longest Increasing Subsequence) algorithm to return the indexes
    // that are not part of that subsequence.
    inverseLISIndices(arr) {
        // Get all subsequences
        var allSubsequences = [];
        for (var i = 0; i < arr.length; i++) {
            var subsequenceForCurrent = [arr[i]],
                current = arr[i],
                lastElementAdded = -1;
            for (var j = i; j < arr.length; j++) {
                var subsequent = arr[j];
                if (subsequent > current && lastElementAdded < subsequent) {
                    subsequenceForCurrent.push(subsequent);
                    lastElementAdded = subsequent;
                }
            }
            allSubsequences.push(subsequenceForCurrent);
        }
        // Figure out the longest one
        var longestSubsequenceLength = -1;
        var longestSubsequence;
        for (let i in allSubsequences) {
            var subs = allSubsequences[i];
            if (subs.length > longestSubsequenceLength) {
                longestSubsequenceLength = subs.length;
                longestSubsequence = subs;
            }
        }
        // Create the inverse indexes
        var indexes = [];
        var lIndex = 0;
        for (let i = 0; i < arr.length; i++) {
            if (lIndex > longestSubsequence.length) {
                indexes.push(i);
            } else {
                if (arr[i] == longestSubsequence[lIndex]) {
                    lIndex += 1;
                } else {
                    indexes.push(i);
                }
            }
        }
        return indexes;
    }
    // grade that element, returning the state
    grade() {
        this.correctLines = 0;
        this.percentLines = 0;
        var solutionLines = this.solution;
        var answerLines = this.answer;
        var i;
        var state;
        this.percentLines =
            Math.min(answerLines.length, solutionLines.length) /
            Math.max(answerLines.length, solutionLines.length);
        if (answerLines.length < solutionLines.length) {
            state = "incorrectTooShort";
            this.correctLength = false;
        } else if (answerLines.length == solutionLines.length) {
            this.correctLength = true;
        } else {
            this.correctLength = false;
        }

        // Determine whether the code **that is there** is in the correct order
        // If there is too much or too little code this only matters for
        // calculating a percentage score.
        let isCorrectOrder = true;
        this.correctLines = 0;
        this.solutionLength = solutionLines.length;
        let loopLimit = Math.min(solutionLines.length, answerLines.length);
        for (i = 0; i < loopLimit; i++) {
            if (answerLines[i] !== solutionLines[i]) {
                isCorrectOrder = false;
            } else {
                this.correctLines += 1;
            }
        }

        if (
            isCorrectOrder &&
            this.correctLength
        ) {
            // Perfect
            state = "correct";
        } else if (!isCorrectOrder && state != "incorrectTooShort") {
            state = "incorrectMoveBlocks";
        }
        this.calculatePercent();
        this.graderState = state;
        return state;
    }

    calculatePercent() {
        let numLines = this.percentLines * 0.2;
        let lines = this.answer.length;
        let numCorrectBlocks = (this.correctLines / lines) * 0.8;

        this.percent = numLines + numCorrectBlocks;
    }
}


/***/ }),

/***/ 10331:
/*!*****************************************************!*\
  !*** ./runestone/hparsons/js/horizontal-parsons.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HParsonsElement": () => (/* binding */ HParsonsElement)
/* harmony export */ });
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version$1 = "1.14.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version$1;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

var RegexEvent;
(function (RegexEvent) {
    (function (ParsonsInputAction) {
        ParsonsInputAction["ADD"] = "add";
        ParsonsInputAction["MOVE"] = "move";
        ParsonsInputAction["REMOVE"] = "remove";
    })(RegexEvent.ParsonsInputAction || (RegexEvent.ParsonsInputAction = {}));
    (function (RegexCompilationStatus) {
        RegexCompilationStatus["ERROR"] = "error";
        RegexCompilationStatus["SUCCESS"] = "success";
    })(RegexEvent.RegexCompilationStatus || (RegexEvent.RegexCompilationStatus = {}));
    (function (MatchTriggerType) {
        MatchTriggerType["MANUAL"] = "manual";
        MatchTriggerType["AUTO"] = "auto";
    })(RegexEvent.MatchTriggerType || (RegexEvent.MatchTriggerType = {}));
    (function (PageStatus) {
        PageStatus["FOCUS"] = "focus";
        PageStatus["VISIBILITY"] = "visibility";
    })(RegexEvent.PageStatus || (RegexEvent.PageStatus = {}));
})(RegexEvent || (RegexEvent = {}));

var deepFreezeEs6 = {exports: {}};

function deepFreeze(obj) {
    if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function () {
            throw new Error('map is read-only');
        };
    } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function () {
            throw new Error('set is read-only');
        };
    }

    // Freeze self
    Object.freeze(obj);

    Object.getOwnPropertyNames(obj).forEach(function (name) {
        var prop = obj[name];

        // Freeze prop if it is an object
        if (typeof prop == 'object' && !Object.isFrozen(prop)) {
            deepFreeze(prop);
        }
    });

    return obj;
}

deepFreezeEs6.exports = deepFreeze;
deepFreezeEs6.exports.default = deepFreeze;

var deepFreeze$1 = deepFreezeEs6.exports;

/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse */
/** @typedef {import('highlight.js').CompiledMode} CompiledMode */
/** @implements CallbackResponse */

class Response {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    // eslint-disable-next-line no-undefined
    if (mode.data === undefined) mode.data = {};

    this.data = mode.data;
    this.isMatchIgnored = false;
  }

  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}

/**
 * @param {string} value
 * @returns {string}
 */
function escapeHTML(value) {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}

/**
 * performs a shallow merge of multiple objects into one
 *
 * @template T
 * @param {T} original
 * @param {Record<string,any>[]} objects
 * @returns {T} a single new object
 */
function inherit$1(original, ...objects) {
  /** @type Record<string,any> */
  const result = Object.create(null);

  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj) {
    for (const key in obj) {
      result[key] = obj[key];
    }
  });
  return /** @type {T} */ (result);
}

/**
 * @typedef {object} Renderer
 * @property {(text: string) => void} addText
 * @property {(node: Node) => void} openNode
 * @property {(node: Node) => void} closeNode
 * @property {() => string} value
 */

/** @typedef {{kind?: string, sublanguage?: boolean}} Node */
/** @typedef {{walk: (r: Renderer) => void}} Tree */
/** */

const SPAN_CLOSE = '</span>';

/**
 * Determines if a node needs to be wrapped in <span>
 *
 * @param {Node} node */
const emitsWrappingTags = (node) => {
  return !!node.kind;
};

/**
 *
 * @param {string} name
 * @param {{prefix:string}} options
 */
const expandScopeName = (name, { prefix }) => {
  if (name.includes(".")) {
    const pieces = name.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...(pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`))
    ].join(" ");
  }
  return `${prefix}${name}`;
};

/** @type {Renderer} */
class HTMLRenderer {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }

  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text) {
    this.buffer += escapeHTML(text);
  }

  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node) {
    if (!emitsWrappingTags(node)) return;

    let scope = node.kind;
    if (node.sublanguage) {
      scope = `language-${scope}`;
    } else {
      scope = expandScopeName(scope, { prefix: this.classPrefix });
    }
    this.span(scope);
  }

  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node) {
    if (!emitsWrappingTags(node)) return;

    this.buffer += SPAN_CLOSE;
  }

  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }

  // helpers

  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}

/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
/** @typedef {import('highlight.js').Emitter} Emitter */
/**  */

class TokenTree {
  constructor() {
    /** @type DataNode */
    this.rootNode = { children: [] };
    this.stack = [this.rootNode];
  }

  get top() {
    return this.stack[this.stack.length - 1];
  }

  get root() { return this.rootNode; }

  /** @param {Node} node */
  add(node) {
    this.top.children.push(node);
  }

  /** @param {string} kind */
  openNode(kind) {
    /** @type Node */
    const node = { kind, children: [] };
    this.add(node);
    this.stack.push(node);
  }

  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    // eslint-disable-next-line no-undefined
    return undefined;
  }

  closeAllNodes() {
    while (this.closeNode());
  }

  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }

  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    // this does not
    return this.constructor._walk(builder, this.rootNode);
    // this works
    // return TokenTree._walk(builder, this.rootNode);
  }

  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }

  /**
   * @param {Node} node
   */
  static _collapse(node) {
    if (typeof node === "string") return;
    if (!node.children) return;

    if (node.children.every(el => typeof el === "string")) {
      // node.text = node.children.join("");
      // delete node.children;
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}

/**
  Currently this is all private API, but this is the minimal API necessary
  that an Emitter must implement to fully support the parser.

  Minimal interface:

  - addKeyword(text, kind)
  - addText(text)
  - addSublanguage(emitter, subLanguageName)
  - finalize()
  - openNode(kind)
  - closeNode()
  - closeAllNodes()
  - toHTML()

*/

/**
 * @implements {Emitter}
 */
class TokenTreeEmitter extends TokenTree {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }

  /**
   * @param {string} text
   * @param {string} kind
   */
  addKeyword(text, kind) {
    if (text === "") { return; }

    this.openNode(kind);
    this.addText(text);
    this.closeNode();
  }

  /**
   * @param {string} text
   */
  addText(text) {
    if (text === "") { return; }

    this.add(text);
  }

  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  addSublanguage(emitter, name) {
    /** @type DataNode */
    const node = emitter.root;
    node.kind = name;
    node.sublanguage = true;
    this.add(node);
  }

  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }

  finalize() {
    return true;
  }
}

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function anyNumberOfTimes(re) {
  return concat('(?:', re, ')*');
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function optional(re) {
  return concat('(?:', re, ')?');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/**
 * @param { Array<string | RegExp | Object> } args
 * @returns {object}
 */
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];

  if (typeof opts === 'object' && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}

/** @typedef { {capture?: boolean} } RegexEitherOptions */

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args
 * @returns {string}
 */
function either(...args) {
  /** @type { object & {capture?: boolean} }  */
  const opts = stripOptionsFromArgs(args);
  const joined = '('
    + (opts.capture ? "" : "?:")
    + args.map((x) => source(x)).join("|") + ")";
  return joined;
}

/**
 * @param {RegExp | string} re
 * @returns {number}
 */
function countMatchGroups(re) {
  return (new RegExp(re.toString() + '|')).exec('').length - 1;
}

/**
 * Does lexeme start with a regular expression match at the beginning
 * @param {RegExp} re
 * @param {string} lexeme
 */
function startsWith(re, lexeme) {
  const match = re && re.exec(lexeme);
  return match && match.index === 0;
}

// BACKREF_RE matches an open parenthesis or backreference. To avoid
// an incorrect parse, it additionally matches the following:
// - [...] elements, where the meaning of parentheses and escapes change
// - other escape sequences, so we do not misparse escape sequences as
//   interesting elements
// - non-matching or lookahead parentheses, which do not capture. These
//   follow the '(' with a '?'.
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;

// **INTERNAL** Not intended for outside usage
// join logically computes regexps.join(separator), but fixes the
// backreferences so they continue to match.
// it also places each individual regular expression into it's own
// match group, keeping track of the sequencing of those match groups
// is currently an exercise for the caller. :-)
/**
 * @param {(string | RegExp)[]} regexps
 * @param {{joinWith: string}} opts
 * @returns {string}
 */
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;

  return regexps.map((regex) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re = source(regex);
    let out = '';

    while (re.length > 0) {
      const match = BACKREF_RE.exec(re);
      if (!match) {
        out += re;
        break;
      }
      out += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === '\\' && match[1]) {
        // Adjust the backreference.
        out += '\\' + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === '(') {
          numCaptures++;
        }
      }
    }
    return out;
  }).map(re => `(${re})`).join(joinWith);
}

/** @typedef {import('highlight.js').Mode} Mode */
/** @typedef {import('highlight.js').ModeCallback} ModeCallback */

// Common regexps
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$1 = '[a-zA-Z]\\w*';
const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

/**
* @param { Partial<Mode> & {binary?: string | RegExp} } opts
*/
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/);
  }
  return inherit$1({
    scope: 'meta',
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m, resp) => {
      if (m.index !== 0) resp.ignoreMatch();
    }
  }, opts);
};

// Common modes
const BACKSLASH_ESCAPE = {
  begin: '\\\\[\\s\\S]', relevance: 0
};
const APOS_STRING_MODE = {
  scope: 'string',
  begin: '\'',
  end: '\'',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: 'string',
  begin: '"',
  end: '"',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
/**
 * Creates a comment mode
 *
 * @param {string | RegExp} begin
 * @param {string | RegExp} end
 * @param {Mode | {}} [modeOptions]
 * @returns {Partial<Mode>}
 */
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1(
    {
      scope: 'comment',
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: 'doctag',
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/, // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/ // allow capitalized words at beginning of sentences
  );
  // looking like plain text, more likely to be a comment
  mode.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---

      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827

      begin: concat(
        /[ ]+/, // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        '(',
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        '){3}') // look for 3 words in a row
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT('//', '$');
const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
const HASH_COMMENT_MODE = COMMENT('#', '$');
const NUMBER_MODE = {
  scope: 'number',
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: 'number',
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: 'number',
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: 'regexp',
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  scope: 'title',
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: 'title',
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
  relevance: 0
};

/**
 * Adds end same as begin mechanics to a mode
 *
 * Your mode must include at least a single () match group as that first match
 * group is what is used for comparison
 * @param {Partial<Mode>} mode
 */
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(mode,
    {
      /** @type {ModeCallback} */
      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
      /** @type {ModeCallback} */
      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
    });
};

var MODES = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE$1,
    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
    NUMBER_RE: NUMBER_RE,
    C_NUMBER_RE: C_NUMBER_RE,
    BINARY_NUMBER_RE: BINARY_NUMBER_RE,
    RE_STARTERS_RE: RE_STARTERS_RE,
    SHEBANG: SHEBANG,
    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
    APOS_STRING_MODE: APOS_STRING_MODE,
    QUOTE_STRING_MODE: QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
    COMMENT: COMMENT,
    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE: HASH_COMMENT_MODE,
    NUMBER_MODE: NUMBER_MODE,
    C_NUMBER_MODE: C_NUMBER_MODE,
    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
    REGEXP_MODE: REGEXP_MODE,
    TITLE_MODE: TITLE_MODE,
    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
    METHOD_GUARD: METHOD_GUARD,
    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
});

/**
@typedef {import('highlight.js').CallbackResponse} CallbackResponse
@typedef {import('highlight.js').CompilerExt} CompilerExt
*/

// Grammar extensions / plugins
// See: https://github.com/highlightjs/highlight.js/issues/2833

// Grammar extensions allow "syntactic sugar" to be added to the grammar modes
// without requiring any underlying changes to the compiler internals.

// `compileMatch` being the perfect small example of now allowing a grammar
// author to write `match` when they desire to match a single expression rather
// than being forced to use `begin`.  The extension then just moves `match` into
// `begin` when it runs.  Ie, no features have been added, but we've just made
// the experience of writing (and reading grammars) a little bit nicer.

// ------

// TODO: We need negative look-behind support to do this properly
/**
 * Skip a match if it has a preceding dot
 *
 * This is used for `beginKeywords` to prevent matching expressions such as
 * `bob.keyword.do()`. The mode compiler automatically wires this up as a
 * special _internal_ 'on:begin' callback for modes with `beginKeywords`
 * @param {RegExpMatchArray} match
 * @param {CallbackResponse} response
 */
function skipIfHasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}

/**
 *
 * @type {CompilerExt}
 */
function scopeClassName(mode, _parent) {
  // eslint-disable-next-line no-undefined
  if (mode.className !== undefined) {
    mode.scope = mode.className;
    delete mode.className;
  }
}

/**
 * `beginKeywords` syntactic sugar
 * @type {CompilerExt}
 */
function beginKeywords(mode, parent) {
  if (!parent) return;
  if (!mode.beginKeywords) return;

  // for languages with keywords that include non-word characters checking for
  // a word boundary is not sufficient, so instead we check for a word boundary
  // or whitespace - this does no harm in any case since our keyword engine
  // doesn't allow spaces in keywords anyways and we still check for the boundary
  // first
  mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;

  // prevents double relevance, the keywords themselves provide
  // relevance, the mode doesn't need to double it
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 0;
}

/**
 * Allow `illegal` to contain an array of illegal values
 * @type {CompilerExt}
 */
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal)) return;

  mode.illegal = either(...mode.illegal);
}

/**
 * `match` to match a single expression for readability
 * @type {CompilerExt}
 */
function compileMatch(mode, _parent) {
  if (!mode.match) return;
  if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

  mode.begin = mode.match;
  delete mode.match;
}

/**
 * provides the default 1 relevance to all modes
 * @type {CompilerExt}
 */
function compileRelevance(mode, _parent) {
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 1;
}

// allow beforeMatch to act as a "qualifier" for the match
// the full match begin must be [beforeMatch][begin]
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch) return;
  // starts conflicts with endsParent which we need to make sure the child
  // rule is not matched multiple times
  if (mode.starts) throw new Error("beforeMatch cannot be used with starts");

  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => { delete mode[key]; });

  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;

  delete originalMode.beforeMatch;
};

// keywords that should have no default relevance value
const COMMON_KEYWORDS = [
  'of',
  'and',
  'for',
  'in',
  'not',
  'or',
  'if',
  'then',
  'parent', // common variable name
  'list', // common variable name
  'value' // common variable name
];

const DEFAULT_KEYWORD_SCOPE = "keyword";

/**
 * Given raw keywords from a language definition, compile them.
 *
 * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
 * @param {boolean} caseInsensitive
 */
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  /** @type KeywordDict */
  const compiledKeywords = Object.create(null);

  // input can be a string of keywords, an array of keywords, or a object with
  // named keys representing scopeName (which can then point to a string or array)
  if (typeof rawKeywords === 'string') {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName) {
      // collapse all our objects back into the parent object
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)
      );
    });
  }
  return compiledKeywords;

  // ---

  /**
   * Compiles an individual list of keywords
   *
   * Ex: "for if when while|5"
   *
   * @param {string} scopeName
   * @param {Array<string>} keywordList
   */
  function compileList(scopeName, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map(x => x.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split('|');
      compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];
    });
  }
}

/**
 * Returns the proper score for a given keyword
 *
 * Also takes into account comment keywords, which will be scored 0 UNLESS
 * another score has been manually assigned.
 * @param {string} keyword
 * @param {string} [providedScore]
 */
function scoreForKeyword(keyword, providedScore) {
  // manual scores always win over common keywords
  // so you can force a score of 1 if you really insist
  if (providedScore) {
    return Number(providedScore);
  }

  return commonKeyword(keyword) ? 0 : 1;
}

/**
 * Determines if a given keyword is common or not
 *
 * @param {string} keyword */
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}

/*

For the reasoning behind this please see:
https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

*/

/**
 * @type {Record<string, boolean>}
 */
const seenDeprecations = {};

/**
 * @param {string} message
 */
const error = (message) => {
  console.error(message);
};

/**
 * @param {string} message
 * @param {any} args
 */
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};

/**
 * @param {string} version
 * @param {string} message
 */
const deprecated = (version, message) => {
  if (seenDeprecations[`${version}/${message}`]) return;

  console.log(`Deprecated as of ${version}. ${message}`);
  seenDeprecations[`${version}/${message}`] = true;
};

/* eslint-disable no-throw-literal */

/**
@typedef {import('highlight.js').CompiledMode} CompiledMode
*/

const MultiClassError = new Error();

/**
 * Renumbers labeled scope names to account for additional inner match
 * groups that otherwise would break everything.
 *
 * Lets say we 3 match scopes:
 *
 *   { 1 => ..., 2 => ..., 3 => ... }
 *
 * So what we need is a clean match like this:
 *
 *   (a)(b)(c) => [ "a", "b", "c" ]
 *
 * But this falls apart with inner match groups:
 *
 * (a)(((b)))(c) => ["a", "b", "b", "b", "c" ]
 *
 * Our scopes are now "out of alignment" and we're repeating `b` 3 times.
 * What needs to happen is the numbers are remapped:
 *
 *   { 1 => ..., 2 => ..., 5 => ... }
 *
 * We also need to know that the ONLY groups that should be output
 * are 1, 2, and 5.  This function handles this behavior.
 *
 * @param {CompiledMode} mode
 * @param {Array<RegExp | string>} regexes
 * @param {{key: "beginScope"|"endScope"}} opts
 */
function remapScopeNames(mode, regexes, { key }) {
  let offset = 0;
  const scopeNames = mode[key];
  /** @type Record<number,boolean> */
  const emit = {};
  /** @type Record<number,string> */
  const positions = {};

  for (let i = 1; i <= regexes.length; i++) {
    positions[i + offset] = scopeNames[i];
    emit[i + offset] = true;
    offset += countMatchGroups(regexes[i - 1]);
  }
  // we use _emit to keep track of which match groups are "top-level" to avoid double
  // output from inside match groups
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}

/**
 * @param {CompiledMode} mode
 */
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin)) return;

  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }

  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }

  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}

/**
 * @param {CompiledMode} mode
 */
function endMultiClass(mode) {
  if (!Array.isArray(mode.end)) return;

  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }

  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }

  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}

/**
 * this exists only to allow `scope: {}` to be used beside `match:`
 * Otherwise `beginScope` would necessary and that would look weird

  {
    match: [ /def/, /\w+/ ]
    scope: { 1: "keyword" , 2: "title" }
  }

 * @param {CompiledMode} mode
 */
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}

/**
 * @param {CompiledMode} mode
 */
function MultiClass(mode) {
  scopeSugar(mode);

  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }

  beginMultiClass(mode);
  endMultiClass(mode);
}

/**
@typedef {import('highlight.js').Mode} Mode
@typedef {import('highlight.js').CompiledMode} CompiledMode
@typedef {import('highlight.js').Language} Language
@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin
@typedef {import('highlight.js').CompiledLanguage} CompiledLanguage
*/

// compilation

/**
 * Compiles a language definition result
 *
 * Given the raw result of a language definition (Language), compiles this so
 * that it is ready for highlighting code.
 * @param {Language} language
 * @returns {CompiledLanguage}
 */
function compileLanguage(language) {
  /**
   * Builds a regex with the case sensitivity of the current language
   *
   * @param {RegExp | string} value
   * @param {boolean} [global]
   */
  function langRe(value, global) {
    return new RegExp(
      source(value),
      'm'
      + (language.case_insensitive ? 'i' : '')
      + (language.unicodeRegex ? 'u' : '')
      + (global ? 'g' : '')
    );
  }

  /**
    Stores multiple regular expressions and allows you to quickly search for
    them all in a string simultaneously - returning the first match.  It does
    this by creating a huge (a|b|c) regex - each individual item wrapped with ()
    and joined by `|` - using match groups to track position.  When a match is
    found checking which position in the array has content allows us to figure
    out which of the original regexes / match groups triggered the match.

    The match object itself (the result of `Regex.exec`) is returned but also
    enhanced by merging in any meta-data that was registered with the regex.
    This is how we keep track of which mode matched, and what type of rule
    (`illegal`, `begin`, end, etc).
  */
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      // @ts-ignore
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      opts.position = this.position++;
      // @ts-ignore
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    }

    compile() {
      if (this.regexes.length === 0) {
        // avoids the need to check length every time exec is called
        // @ts-ignore
        this.exec = () => null;
      }
      const terminators = this.regexes.map(el => el[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);
      this.lastIndex = 0;
    }

    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s);
      if (!match) { return null; }

      // eslint-disable-next-line no-undefined
      const i = match.findIndex((el, i) => i > 0 && el !== undefined);
      // @ts-ignore
      const matchData = this.matchIndexes[i];
      // trim off any earlier non-relevant match groups (ie, the other regex
      // match groups that make up the multi-matcher)
      match.splice(0, i);

      return Object.assign(match, matchData);
    }
  }

  /*
    Created to solve the key deficiently with MultiRegex - there is no way to
    test for multiple matches at a single location.  Why would we need to do
    that?  In the future a more dynamic engine will allow certain matches to be
    ignored.  An example: if we matched say the 3rd regex in a large group but
    decided to ignore it - we'd need to started testing again at the 4th
    regex... but MultiRegex itself gives us no real way to do that.

    So what this class creates MultiRegexs on the fly for whatever search
    position they are needed.

    NOTE: These additional MultiRegex objects are created dynamically.  For most
    grammars most of the time we will never actually need anything more than the
    first MultiRegex - so this shouldn't have too much overhead.

    Say this is our search group, and we match regex3, but wish to ignore it.

      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

    What we need is a new MultiRegex that only includes the remaining
    possibilities:

      regex4 | regex5                               ' ie, startAt = 3

    This class wraps all that complexity up in a simple API... `startAt` decides
    where in the array of expressions to start doing the matching. It
    auto-increments, so if a match is found at position 2, then startAt will be
    set to 3.  If the end is reached startAt will return to 0.

    MOST of the time the parser will be setting startAt manually to 0.
  */
  class ResumableMultiRegex {
    constructor() {
      // @ts-ignore
      this.rules = [];
      // @ts-ignore
      this.multiRegexes = [];
      this.count = 0;

      this.lastIndex = 0;
      this.regexIndex = 0;
    }

    // @ts-ignore
    getMatcher(index) {
      if (this.multiRegexes[index]) return this.multiRegexes[index];

      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }

    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }

    considerAll() {
      this.regexIndex = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin") this.count++;
    }

    /** @param {string} s */
    exec(s) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result = m.exec(s);

      // The following is because we have no easy way to say "resume scanning at the
      // existing position but also skip the current rule ONLY". What happens is
      // all prior rules are also skipped which can result in matching the wrong
      // thing. Example of matching "booger":

      // our matcher is [string, "booger", number]
      //
      // ....booger....

      // if "booger" is ignored then we'd really need a regex to scan from the
      // SAME position for only: [string, number] but ignoring "booger" (if it
      // was the first match), a simple resume would scan ahead who knows how
      // far looking only for "number", ignoring potential string matches (or
      // future "booger" matches that might be valid.)

      // So what we do: We execute two matchers, one resuming at the same
      // position, but the second full matcher starting at the position after:

      //     /--- resume first regex match here (for [number])
      //     |/---- full match here for [string, "booger", number]
      //     vv
      // ....booger....

      // Which ever results in a match first is then used. So this 3-4 step
      // process essentially allows us to say "match at this position, excluding
      // a prior rule that was ignored".
      //
      // 1. Match "booger" first, ignore. Also proves that [string] does non match.
      // 2. Resume matching for [number]
      // 3. Match at index + 1 for [string, "booger", number]
      // 4. If #2 and #3 result in matches, which came first?
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex) ; else { // use the second matcher result
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }

      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          // wrap-around to considering all matches again
          this.considerAll();
        }
      }

      return result;
    }
  }

  /**
   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
   * the content and find matches.
   *
   * @param {CompiledMode} mode
   * @returns {ResumableMultiRegex}
   */
  function buildModeRegex(mode) {
    const mm = new ResumableMultiRegex();

    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }

    return mm;
  }

  /** skip vs abort vs ignore
   *
   * @skip   - The mode is still entered and exited normally (and contains rules apply),
   *           but all content is held and added to the parent buffer rather than being
   *           output when the mode ends.  Mostly used with `sublanguage` to build up
   *           a single large buffer than can be parsed by sublanguage.
   *
   *             - The mode begin ands ends normally.
   *             - Content matched is added to the parent mode buffer.
   *             - The parser cursor is moved forward normally.
   *
   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
   *           never matched) but DOES NOT continue to match subsequent `contains`
   *           modes.  Abort is bad/suboptimal because it can result in modes
   *           farther down not getting applied because an earlier rule eats the
   *           content but then aborts.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is added to the mode buffer.
   *             - The parser cursor is moved forward accordingly.
   *
   * @ignore - Ignores the mode (as if it never matched) and continues to match any
   *           subsequent `contains` modes.  Ignore isn't technically possible with
   *           the current parser implementation.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is ignored.
   *             - The parser cursor is not moved forward.
   */

  /**
   * Compiles an individual mode
   *
   * This can raise an error if the mode contains certain detectable known logic
   * issues.
   * @param {Mode} mode
   * @param {CompiledMode | null} [parent]
   * @returns {CompiledMode | never}
   */
  function compileMode(mode, parent) {
    const cmode = /** @type CompiledMode */ (mode);
    if (mode.isCompiled) return cmode;

    [
      scopeClassName,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach(ext => ext(mode, parent));

    language.compilerExtensions.forEach(ext => ext(mode, parent));

    // __beforeBegin is considered private API, internal use only
    mode.__beforeBegin = null;

    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach(ext => ext(mode, parent));

    mode.isCompiled = true;

    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      // we need a copy because keywords might be compiled multiple times
      // so we can't go deleting $pattern from the original on the first
      // pass
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;

    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }

    cmode.keywordPatternRe = langRe(keywordPattern, true);

    if (parent) {
      if (!mode.begin) mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
      if (mode.end) cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || '';
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
      }
    }
    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
    if (!mode.contains) mode.contains = [];

    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === 'self' ? mode : c);
    }));
    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

    if (mode.starts) {
      compileMode(mode.starts, parent);
    }

    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }

  if (!language.compilerExtensions) language.compilerExtensions = [];

  // self is not valid at the top-level
  if (language.contains && language.contains.includes('self')) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }

  // we need a null object, which inherit will guarantee
  language.classNameAliases = inherit$1(language.classNameAliases || {});

  return compileMode(/** @type Mode */ (language));
}

/**
 * Determines if a mode has a dependency on it's parent or not
 *
 * If a mode does have a parent dependency then often we need to clone it if
 * it's used in multiple places so that each copy points to the correct parent,
 * where-as modes without a parent can often safely be re-used at the bottom of
 * a mode chain.
 *
 * @param {Mode | null} mode
 * @returns {boolean} - is there a dependency on the parent?
 * */
function dependencyOnParent(mode) {
  if (!mode) return false;

  return mode.endsWithParent || dependencyOnParent(mode.starts);
}

/**
 * Expands a mode or clones it if necessary
 *
 * This is necessary for modes with parental dependenceis (see notes on
 * `dependencyOnParent`) and for nodes that have `variants` - which must then be
 * exploded into their own individual modes at compile time.
 *
 * @param {Mode} mode
 * @returns {Mode | Mode[]}
 * */
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }

  // EXPAND
  // if we have variants then essentially "replace" the mode with the variants
  // this happens in compileMode, where this function is called from
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }

  // CLONE
  // if we have dependencies on parents then we need a unique
  // instance of ourselves, so we can be reused with many
  // different parents without issue
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }

  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }

  // no special dependency issues, just return ourselves
  return mode;
}

var version = "11.5.0";

class HTMLInjectionError extends Error {
  constructor(reason, html) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html;
  }
}

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

/**
@typedef {import('highlight.js').Mode} Mode
@typedef {import('highlight.js').CompiledMode} CompiledMode
@typedef {import('highlight.js').CompiledScope} CompiledScope
@typedef {import('highlight.js').Language} Language
@typedef {import('highlight.js').HLJSApi} HLJSApi
@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin
@typedef {import('highlight.js').PluginEvent} PluginEvent
@typedef {import('highlight.js').HLJSOptions} HLJSOptions
@typedef {import('highlight.js').LanguageFn} LanguageFn
@typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement
@typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext
@typedef {import('highlight.js/private').MatchType} MatchType
@typedef {import('highlight.js/private').KeywordData} KeywordData
@typedef {import('highlight.js/private').EnhancedMatch} EnhancedMatch
@typedef {import('highlight.js/private').AnnotatedError} AnnotatedError
@typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult
@typedef {import('highlight.js').HighlightOptions} HighlightOptions
@typedef {import('highlight.js').HighlightResult} HighlightResult
*/


const escape = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;

/**
 * @param {any} hljs - object that is extended (legacy)
 * @returns {HLJSApi}
 */
const HLJS = function(hljs) {
  // Global internal variables used within the highlight.js library.
  /** @type {Record<string, Language>} */
  const languages = Object.create(null);
  /** @type {Record<string, string>} */
  const aliases = Object.create(null);
  /** @type {HLJSPlugin[]} */
  const plugins = [];

  // safe/production mode - swallows more errors, tries to keep running
  // even if a single syntax or parse hits a fatal error
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  /** @type {Language} */
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  /** @type HLJSOptions */
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: 'hljs-',
    cssSelector: 'pre code',
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter
  };

  /* Utility functions */

  /**
   * Tests a language name to see if highlighting should be skipped
   * @param {string} languageName
   */
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }

  /**
   * @param {HighlightedHTMLElement} block - the HTML element to determine language for
   */
  function blockLanguage(block) {
    let classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language = getLanguage(match[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : 'no-highlight';
    }

    return classes
      .split(/\s+/)
      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }

  /**
   * Core highlighting function.
   *
   * OLD API
   * highlight(lang, code, ignoreIllegals, continuation)
   *
   * NEW API
   * highlight(code, {lang, ignoreIllegals})
   *
   * @param {string} codeOrLanguageName - the language to use for highlighting
   * @param {string | HighlightOptions} optionsOrCode - the code to highlight
   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   *
   * @returns {HighlightResult} Result - an object that represents the result
   * @property {string} language - the language name
   * @property {number} relevance - the relevance score
   * @property {string} value - the highlighted HTML code
   * @property {string} code - the original raw code
   * @property {CompiledMode} top - top of the current mode stack
   * @property {boolean} illegal - indicates whether any illegal matches were found
  */
  function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      // old API
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }

    // https://github.com/highlightjs/highlight.js/issues/3149
    // eslint-disable-next-line no-undefined
    if (ignoreIllegals === undefined) { ignoreIllegals = true; }

    /** @type {BeforeHighlightContext} */
    const context = {
      code,
      language: languageName
    };
    // the plugin can change the desired language or the code to be highlighted
    // just be changing the object it was passed
    fire("before:highlight", context);

    // a before plugin can usurp the result completely by providing it's own
    // in which case we don't even need to call highlight
    const result = context.result
      ? context.result
      : _highlight(context.language, context.code, ignoreIllegals);

    result.code = context.code;
    // the plugin can change anything in result to suite it
    fire("after:highlight", result);

    return result;
  }

  /**
   * private highlight that's used internally and does not fire callbacks
   *
   * @param {string} languageName - the language to use for highlighting
   * @param {string} codeToHighlight - the code to highlight
   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   * @param {CompiledMode?} [continuation] - current continuation mode, if any
   * @returns {HighlightResult} - result of the highlight operation
  */
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = Object.create(null);

    /**
     * Return keyword data if a match is a keyword
     * @param {CompiledMode} mode - current mode
     * @param {string} matchText - the textual match
     * @returns {KeywordData | false}
     */
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }

    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }

      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";

      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
        const data = keywordData(top, word);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";

          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            // _ implied for relevance only, do not highlight
            // by applying a class name
            buf += match[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substr(lastIndex);
      emitter.addText(buf);
    }

    function processSubLanguage() {
      if (modeBuffer === "") return;
      /** @type HighlightResult */
      let result = null;

      if (typeof top.subLanguage === 'string') {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result._top);
      } else {
        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Use case in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      emitter.addSublanguage(result._emitter, result.language);
    }

    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = '';
    }

    /**
     * @param {CompiledScope} scope
     * @param {RegExpMatchArray} match
     */
    function emitMultiClass(scope, match) {
      let i = 1;
      const max = match.length - 1;
      while (i <= max) {
        if (!scope._emit[i]) { i++; continue; }
        const klass = language.classNameAliases[scope[i]] || scope[i];
        const text = match[i];
        if (klass) {
          emitter.addKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i++;
      }
    }

    /**
     * @param {CompiledMode} mode - new mode to start
     * @param {RegExpMatchArray} match
     */
    function startNewMode(mode, match) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        // beginScope just wraps the begin match itself in a scope
        if (mode.beginScope._wrap) {
          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          // at this point modeBuffer should just be the match
          emitMultiClass(mode.beginScope, match);
          modeBuffer = "";
        }
      }

      top = Object.create(mode, { parent: { value: top } });
      return top;
    }

    /**
     * @param {CompiledMode } mode - the mode to potentially end
     * @param {RegExpMatchArray} match - the latest match
     * @param {string} matchPlusRemainder - match plus remainder of content
     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
     */
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);

      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored) matched = false;
        }

        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      // even if on:end fires an `ignore` it's still possible
      // that we might trigger the end node because of a parent mode
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }

    /**
     * Handle matching but then ignoring a sequence of text
     *
     * @param {string} lexeme - string containing full match text
     */
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        // no more regexes to potentially match here, so we move the cursor forward one
        // space
        modeBuffer += lexeme[0];
        return 1;
      } else {
        // no need to move the cursor, we still have additional regexes to try and
        // match at this very spot
        resumeScanAtSamePosition = true;
        return 0;
      }
    }

    /**
     * Handle the start of a new potential mode match
     *
     * @param {EnhancedMatch} match - the current match
     * @returns {number} how far to advance the parse cursor
     */
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;

      const resp = new Response(newMode);
      // first internal before callbacks, then the public ones
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb) continue;
        cb(match, resp);
        if (resp.isMatchIgnored) return doIgnore(lexeme);
      }

      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match);
      return newMode.returnBegin ? 0 : lexeme.length;
    }

    /**
     * Handle the potential end of mode
     *
     * @param {RegExpMatchArray} match - the current match
     */
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substr(match.index);

      const endMode = endOfMode(top, match, matchPlusRemainder);
      if (!endMode) { return NO_MATCH; }

      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitter.addKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }

    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach(item => emitter.openNode(item));
    }

    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
    let lastMatch = {};

    /**
     *  Process an individual match
     *
     * @param {string} textBeforeMatch - text preceding the match (since the last match)
     * @param {EnhancedMatch} [match] - the match itself
     */
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];

      // add non-matched text to the current mode buffer
      modeBuffer += textBeforeMatch;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      // we've found a 0 width match and we're stuck, so we need to advance
      // this happens when we have badly behaved rules that have optional matchers to the degree that
      // sometimes they can end up matching nothing at all
      // Ref: https://github.com/highlightjs/highlight.js/issues/2140
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        // spit the "skipped" character that our regex choked on back into the output sequence
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          /** @type {AnnotatedError} */
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;

      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        // illegal match, we do not continue processing
        /** @type {AnnotatedError} */
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || '<unnamed>') + '"');
        err.mode = top;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }

      // edge case for when illegal matches $ (end of line) which is technically
      // a 0 width match but not a begin/end match so it's not caught by the
      // first handler (when ignoreIllegals is true)
      if (match.type === "illegal" && lexeme === "") {
        // advance so we aren't stuck in an infinite loop
        return 1;
      }

      // infinite loops are BAD, this is a last ditch catch all. if we have a
      // decent number of iterations yet our index (cursor position in our
      // parsing) still 3x behind our index then something is very wrong
      // so we bail
      if (iterations > 100000 && iterations > match.index * 3) {
        const err = new Error('potential infinite loop, way more iterations than matches');
        throw err;
      }

      /*
      Why might be find ourselves here?  An potential end match that was
      triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.
      (this could be because a callback requests the match be ignored, etc)

      This causes no real harm other than stopping a few times too many.
      */

      modeBuffer += lexeme;
      return lexeme.length;
    }

    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }

    const md = compileLanguage(language);
    let result = '';
    /** @type {CompiledMode} */
    let top = continuation || md;
    /** @type Record<string,CompiledMode> */
    const continuations = {}; // keep continuations for sub-languages
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = '';
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;

    try {
      top.matcher.considerAll();

      for (;;) {
        iterations++;
        if (resumeScanAtSamePosition) {
          // only regexes not matched previously will now be
          // considered for a potential match
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;

        const match = top.matcher.exec(codeToHighlight);
        // console.log("match", match[0], match.rule && match.rule.begin)

        if (!match) break;

        const beforeMatch = codeToHighlight.substring(index, match.index);
        const processedCount = processLexeme(beforeMatch, match);
        index = match.index + processedCount;
      }
      processLexeme(codeToHighlight.substr(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();

      return {
        language: languageName,
        value: result,
        relevance: relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes('Illegal')) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index: index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }

  /**
   * returns a valid highlight result, without actually doing any actual work,
   * auto highlight starts with this and it's possible for small snippets that
   * auto-detection may not find a better match
   * @param {string} code
   * @returns {HighlightResult}
   */
  function justTextHighlightResult(code) {
    const result = {
      value: escape(code),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code);
    return result;
  }

  /**
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - secondBest (object with the same structure for second-best heuristically
    detected language, may be absent)

    @param {string} code
    @param {Array<string>} [languageSubset]
    @returns {AutoHighlightResult}
  */
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code);

    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
      _highlight(name, code, false)
    );
    results.unshift(plaintext); // plaintext is always an option

    const sorted = results.sort((a, b) => {
      // sort base on relevance
      if (a.relevance !== b.relevance) return b.relevance - a.relevance;

      // always award the tie to the base language
      // ie if C++ and Arduino are tied, it's more likely to be C++
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }

      // otherwise say they are equal, which has the effect of sorting on
      // relevance while preserving the original ordering - which is how ties
      // have historically been settled, ie the language that comes first always
      // wins in the case of a tie
      return 0;
    });

    const [best, secondBest] = sorted;

    /** @type {AutoHighlightResult} */
    const result = best;
    result.secondBest = secondBest;

    return result;
  }

  /**
   * Builds new class name for block given the language name
   *
   * @param {HTMLElement} element
   * @param {string} [currentLang]
   * @param {string} [resultLang]
   */
  function updateClassName(element, currentLang, resultLang) {
    const language = (currentLang && aliases[currentLang]) || resultLang;

    element.classList.add("hljs");
    element.classList.add(`language-${language}`);
  }

  /**
   * Applies highlighting to a DOM node containing code.
   *
   * @param {HighlightedHTMLElement} element - the HTML element to highlight
  */
  function highlightElement(element) {
    /** @type HTMLElement */
    let node = null;
    const language = blockLanguage(element);

    if (shouldNotHighlight(language)) return;

    fire("before:highlightElement",
      { el: element, language: language });

    // we should be all text, no child nodes (unescaped HTML) - this is possibly
    // an HTML injection attack - it's likely too late if this is already in
    // production (the code has likely already done its damage by the time
    // we're seeing it)... but we yell loudly about this so that hopefully it's
    // more likely to be caught in development before making it to production
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError(
          "One of your code blocks includes unescaped HTML.",
          element.innerHTML
        );
        throw err;
      }
    }

    node = element;
    const text = node.textContent;
    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);

    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }

    fire("after:highlightElement", { el: element, result, text });
  }

  /**
   * Updates highlight.js global options with the passed options
   *
   * @param {Partial<HLJSOptions>} userOptions
   */
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }

  // TODO: remove v12, deprecated
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };

  // TODO: remove v12, deprecated
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }

  let wantsHighlight = false;

  /**
   * auto-highlights all pre>code elements on the page
   */
  function highlightAll() {
    // if we are called too early in the loading process
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }

    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }

  function boot() {
    // if a highlight was requested before DOM was loaded, do now
    if (wantsHighlight) highlightAll();
  }

  // make sure we are in the browser environment
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('DOMContentLoaded', boot, false);
  }

  /**
   * Register a language grammar module
   *
   * @param {string} languageName
   * @param {LanguageFn} languageDefinition
   */
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      // hard or soft error
      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
      // languages that have serious errors are replaced with essentially a
      // "plaintext" stand-in so that the code blocks will still get normal
      // css classes applied to them - and one bad language won't break the
      // entire highlighter
      lang = PLAINTEXT_LANGUAGE;
    }
    // give it a temporary name if it doesn't have one in the meta-data
    if (!lang.name) lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);

    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }

  /**
   * Remove a language grammar module
   *
   * @param {string} languageName
   */
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }

  /**
   * @returns {string[]} List of language internal names
   */
  function listLanguages() {
    return Object.keys(languages);
  }

  /**
   * @param {string} name - name of the language to retrieve
   * @returns {Language | undefined}
   */
  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /**
   *
   * @param {string|string[]} aliasList - single alias or list of aliases
   * @param {{languageName: string}} opts
   */
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === 'string') {
      aliasList = [aliasList];
    }
    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
  }

  /**
   * Determines if a given language has auto-detection enabled
   * @param {string} name - name of the language
   */
  function autoDetection(name) {
    const lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }

  /**
   * Upgrades the old highlightBlock plugins to the new
   * highlightElement API
   * @param {HLJSPlugin} plugin
   */
  function upgradePluginAPI(plugin) {
    // TODO: remove with v12
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
  }

  /**
   * @param {HLJSPlugin} plugin
   */
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }

  /**
   *
   * @param {PluginEvent} event
   * @param {any} args
   */
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }

  /**
   * DEPRECATED
   * @param {HighlightedHTMLElement} el
   */
  function deprecateHighlightBlock(el) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");

    return highlightElement(el);
  }

  /* Interface definition */
  Object.assign(hljs, {
    highlight,
    highlightAuto,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin
  });

  hljs.debugMode = function() { SAFE_MODE = false; };
  hljs.safeMode = function() { SAFE_MODE = true; };
  hljs.versionString = version;

  hljs.regex = {
    concat: concat,
    lookahead: lookahead,
    either: either,
    optional: optional,
    anyNumberOfTimes: anyNumberOfTimes
  };

  for (const key in MODES) {
    // @ts-ignore
    if (typeof MODES[key] === "object") {
      // @ts-ignore
      deepFreeze$1(MODES[key]);
    }
  }

  // merge all the modes/regexes into our main object
  Object.assign(hljs, MODES);

  return hljs;
};

// export an "instance" of the highlighter
var highlight = HLJS({});

var core = highlight;
highlight.HighlightJS = highlight;
highlight.default = highlight;

const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
const KEYWORDS = [
  "as", // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
const TYPES = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];

const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];

const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",

  "require",
  "exports",

  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];

const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global" // Node.js
];

const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  TYPES,
  ERROR_TYPES
);

/*
Language: JavaScript
Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
Category: common, scripting, web
Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
*/

/** @type LanguageFn */
function javascript(hljs) {
  const regex = hljs.regex;
  /**
   * Takes a string like "<Booger" and checks to see
   * if we can find a matching "</Booger" later in the
   * content.
   * @param {RegExpMatchArray} match
   * @param {{after:number}} param1
   */
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };

  const IDENT_RE$1 = IDENT_RE;
  const FRAGMENT = {
    begin: '<>',
    end: '</>'
  };
  // to avoid some special cases inside isTrulyOpeningTag
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" ||
        // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ",") {
        response.ignoreMatch();
        return;
      }

      // `<something>`
      // Quite possibly a tag, lets look for a matching closing tag...
      if (nextChar === ">") {
        // if we cannot find a matching closing tag, then we
        // will ignore it
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }

      // `<blah />` (self-closing)
      // handled by simpleSelfClosing rule

      // `<From extends string>`
      // technically this could be HTML, but it smells like a type
      let m;
      const afterMatch = match.input.substr(afterMatchIndex);
      // NOTE: This is ugh, but added specifically for https://github.com/highlightjs/highlight.js/issues/3276
      if ((m = afterMatch.match(/^\s+extends\s+/))) {
        if (m.index === 0) {
          response.ignoreMatch();
          // eslint-disable-next-line no-useless-return
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };

  // https://tc39.es/ecma262/#sec-literals-numeric-literals
  const decimalDigits = '[0-9](_?[0-9])*';
  const frac = `\\.(${decimalDigits})`;
  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: 'number',
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
        `[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" },
    ],
    relevance: 0
  };

  const SUBST = {
    className: 'subst',
    begin: '\\$\\{',
    end: '\\}',
    keywords: KEYWORDS$1,
    contains: [] // defined later
  };
  const HTML_TEMPLATE = {
    begin: 'html`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'xml'
    }
  };
  const CSS_TEMPLATE = {
    begin: 'css`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'css'
    }
  };
  const TEMPLATE_STRING = {
    className: 'string',
    begin: '`',
    end: '`',
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    '\\*/',
    {
      relevance: 0,
      contains: [
        {
          begin: '(?=@[A-Za-z]+)',
          relevance: 0,
          contains: [
            {
              className: 'doctag',
              begin: '@[A-Za-z]+'
            },
            {
              className: 'type',
              begin: '\\{',
              end: '\\}',
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: 'variable',
              begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER,
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS
    .concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };

  // ES6 classes
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$1, "(", regex.concat(/\./, IDENT_RE$1), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      },

    ]
  };

  const CLASS_REFERENCE = {
    relevance: 0,
    match:
    regex.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/,
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };

  const USE_STRICT = {
    label: "use_strict",
    className: 'meta',
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };

  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$1,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [ PARAMS ],
    illegal: /%/
  };

  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };

  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }

  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super"
      ]),
      IDENT_RE$1, regex.lookahead(/\(/)),
    className: "title.function",
    relevance: 0
  };

  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$1,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };

  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$1,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      { // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };

  const FUNC_LEAD_IN_RE = '(\\(' +
    '[^()]*(\\(' +
    '[^()]*(\\(' +
    '[^()]*' +
    '\\)[^()]*)*' +
    '\\)[^()]*)*' +
    '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>';

  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/, /\s+/,
      IDENT_RE$1, /\s*/,
      /=\s*/,
      /(async\s*)?/, // async is optional
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };

  return {
    name: 'Javascript',
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT,
      NUMBER,
      CLASS_REFERENCE,
      {
        className: 'attr',
        begin: IDENT_RE$1 + regex.lookahead(':'),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      { // "value" container
        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        relevance: 0,
        contains: [
          COMMENT,
          hljs.REGEXP_MODE,
          {
            className: 'function',
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          { // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          { // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                'on:begin': XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: 'xml',
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ['self']
              }
            ]
          }
        ],
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: '\\b(?!function)' + hljs.UNDERSCORE_IDENT_RE +
          '\\(' + // first parens
          '[^()]*(\\(' +
            '[^()]*(\\(' +
              '[^()]*' +
            '\\)[^()]*)*' +
          '\\)[^()]*)*' +
          '\\)\\s*\\{', // end parens
        returnBegin:true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: '\\$' + IDENT_RE$1,
        relevance: 0
      },
      {
        match: [ /\bconstructor(?=\s*\()/ ],
        className: { 1: "title.function" },
        contains: [ PARAMS ]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}

var javascript_1 = javascript;

/*
Language: Python
Description: Python is an interpreted, object-oriented, high-level programming language with dynamic semantics.
Website: https://www.python.org
Category: common
*/
function python(hljs) {
  const regex = hljs.regex;
  const IDENT_RE = /[\p{XID_Start}_]\p{XID_Continue}*/u;
  const RESERVED_WORDS = [
    'and',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'class',
    'continue',
    'def',
    'del',
    'elif',
    'else',
    'except',
    'finally',
    'for',
    'from',
    'global',
    'if',
    'import',
    'in',
    'is',
    'lambda',
    'nonlocal|10',
    'not',
    'or',
    'pass',
    'raise',
    'return',
    'try',
    'while',
    'with',
    'yield'
  ];

  const BUILT_INS = [
    '__import__',
    'abs',
    'all',
    'any',
    'ascii',
    'bin',
    'bool',
    'breakpoint',
    'bytearray',
    'bytes',
    'callable',
    'chr',
    'classmethod',
    'compile',
    'complex',
    'delattr',
    'dict',
    'dir',
    'divmod',
    'enumerate',
    'eval',
    'exec',
    'filter',
    'float',
    'format',
    'frozenset',
    'getattr',
    'globals',
    'hasattr',
    'hash',
    'help',
    'hex',
    'id',
    'input',
    'int',
    'isinstance',
    'issubclass',
    'iter',
    'len',
    'list',
    'locals',
    'map',
    'max',
    'memoryview',
    'min',
    'next',
    'object',
    'oct',
    'open',
    'ord',
    'pow',
    'print',
    'property',
    'range',
    'repr',
    'reversed',
    'round',
    'set',
    'setattr',
    'slice',
    'sorted',
    'staticmethod',
    'str',
    'sum',
    'super',
    'tuple',
    'type',
    'vars',
    'zip'
  ];

  const LITERALS = [
    '__debug__',
    'Ellipsis',
    'False',
    'None',
    'NotImplemented',
    'True'
  ];

  // https://docs.python.org/3/library/typing.html
  // TODO: Could these be supplemented by a CamelCase matcher in certain
  // contexts, leaving these remaining only for relevance hinting?
  const TYPES = [
    "Any",
    "Callable",
    "Coroutine",
    "Dict",
    "List",
    "Literal",
    "Generic",
    "Optional",
    "Sequence",
    "Set",
    "Tuple",
    "Type",
    "Union"
  ];

  const KEYWORDS = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: RESERVED_WORDS,
    built_in: BUILT_INS,
    literal: LITERALS,
    type: TYPES
  };

  const PROMPT = {
    className: 'meta',
    begin: /^(>>>|\.\.\.) /
  };

  const SUBST = {
    className: 'subst',
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS,
    illegal: /#/
  };

  const LITERAL_BRACKET = {
    begin: /\{\{/,
    relevance: 0
  };

  const STRING = {
    className: 'string',
    contains: [ hljs.BACKSLASH_ESCAPE ],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };

  // https://docs.python.org/3.9/reference/lexical_analysis.html#numeric-literals
  const digitpart = '[0-9](_?[0-9])*';
  const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
  // Whitespace after a number (or any lexical token) is needed only if its absence
  // would change the tokenization
  // https://docs.python.org/3.9/reference/lexical_analysis.html#whitespace-between-tokens
  // We deviate slightly, requiring a word boundary or a keyword
  // to avoid accidentally recognizing *prefixes* (e.g., `0` in `0x41` or `08` or `0__1`)
  const lookahead = `\\b|${RESERVED_WORDS.join('|')}`;
  const NUMBER = {
    className: 'number',
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead})`
      },
      {
        begin: `(${pointfloat})[jJ]?`
      },

      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead})`
      },

      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${digitpart})[jJ](?=${lookahead})`
      }
    ]
  };
  const COMMENT_TYPE = {
    className: "comment",
    begin: regex.lookahead(/# type:/),
    end: /$/,
    keywords: KEYWORDS,
    contains: [
      { // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  };
  const PARAMS = {
    className: 'params',
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS,
        contains: [
          'self',
          PROMPT,
          NUMBER,
          STRING,
          hljs.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  SUBST.contains = [
    STRING,
    NUMBER,
    PROMPT
  ];

  return {
    name: 'Python',
    aliases: [
      'py',
      'gyp',
      'ipython'
    ],
    unicodeRegex: true,
    keywords: KEYWORDS,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      PROMPT,
      NUMBER,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      STRING,
      COMMENT_TYPE,
      hljs.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/, /\s+/,
          IDENT_RE,
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [ PARAMS ]
      },
      {
        variants: [
          {
            match: [
              /\bclass/, /\s+/,
              IDENT_RE, /\s*/,
              /\(\s*/, IDENT_RE,/\s*\)/
            ],
          },
          {
            match: [
              /\bclass/, /\s+/,
              IDENT_RE
            ],
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited",
        }
      },
      {
        className: 'meta',
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          NUMBER,
          PARAMS,
          STRING
        ]
      }
    ]
  };
}

var python_1 = python;

// https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
var decimalDigits = '[0-9](_*[0-9])*';
var frac = `\\.(${decimalDigits})`;
var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
var NUMERIC = {
  className: 'number',
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
      `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${frac})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits})[fFdD]\\b` },

    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
      `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },

    // DecimalIntegerLiteral
    { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

    // HexIntegerLiteral
    { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },

    // OctalIntegerLiteral
    { begin: '\\b0(_*[0-7])*[lL]?\\b' },

    // BinaryIntegerLiteral
    { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
  ],
  relevance: 0
};

/*
Language: Java
Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>
Category: common, enterprise
Website: https://www.java.com/
*/

/**
 * Allows recursive regex expressions to a given depth
 *
 * ie: recurRegex("(abc~~~)", /~~~/g, 2) becomes:
 * (abc(abc(abc)))
 *
 * @param {string} re
 * @param {RegExp} substitution (should be a g mode regex)
 * @param {number} depth
 * @returns {string}``
 */
function recurRegex(re, substitution, depth) {
  if (depth === -1) return "";

  return re.replace(substitution, _ => {
    return recurRegex(re, substitution, depth - 1);
  });
}

/** @type LanguageFn */
function java(hljs) {
  const regex = hljs.regex;
  const JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
  const GENERIC_IDENT_RE = JAVA_IDENT_RE
    + recurRegex('(?:<' + JAVA_IDENT_RE + '~~~(?:\\s*,\\s*' + JAVA_IDENT_RE + '~~~)*>)?', /~~~/g, 2);
  const MAIN_KEYWORDS = [
    'synchronized',
    'abstract',
    'private',
    'var',
    'static',
    'if',
    'const ',
    'for',
    'while',
    'strictfp',
    'finally',
    'protected',
    'import',
    'native',
    'final',
    'void',
    'enum',
    'else',
    'break',
    'transient',
    'catch',
    'instanceof',
    'volatile',
    'case',
    'assert',
    'package',
    'default',
    'public',
    'try',
    'switch',
    'continue',
    'throws',
    'protected',
    'public',
    'private',
    'module',
    'requires',
    'exports',
    'do',
    'sealed'
  ];

  const BUILT_INS = [
    'super',
    'this'
  ];

  const LITERALS = [
    'false',
    'true',
    'null'
  ];

  const TYPES = [
    'char',
    'boolean',
    'long',
    'float',
    'int',
    'byte',
    'short',
    'double'
  ];

  const KEYWORDS = {
    keyword: MAIN_KEYWORDS,
    literal: LITERALS,
    type: TYPES,
    built_in: BUILT_INS
  };

  const ANNOTATION = {
    className: 'meta',
    begin: '@' + JAVA_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [ "self" ] // allow nested () inside our annotation
      }
    ]
  };
  const PARAMS = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS,
    relevance: 0,
    contains: [ hljs.C_BLOCK_COMMENT_MODE ],
    endsParent: true
  };

  return {
    name: 'Java',
    aliases: [ 'jsp' ],
    keywords: KEYWORDS,
    illegal: /<\/|#/,
    contains: [
      hljs.COMMENT(
        '/\\*\\*',
        '\\*/',
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: 'doctag',
              begin: '@[A-Za-z]+'
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [ hljs.BACKSLASH_ESCAPE ]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          regex.concat(/(?!else)/, JAVA_IDENT_RE),
          /\s+/,
          JAVA_IDENT_RE,
          /\s+/,
          /=/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          PARAMS,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: 'new throw return else',
        relevance: 0
      },
      {
        begin: [
          '(?:' + GENERIC_IDENT_RE + '\\s+)',
          hljs.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: KEYWORDS,
        contains: [
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS,
            relevance: 0,
            contains: [
              ANNOTATION,
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              NUMERIC,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      NUMERIC,
      ANNOTATION
    ]
  };
}

var java_1 = java;

/*
 Language: SQL
 Website: https://en.wikipedia.org/wiki/SQL
 Category: common, database
 */
/*

Goals:

SQL is intended to highlight basic/common SQL keywords and expressions

- If pretty much every single SQL server includes supports, then it's a canidate.
- It is NOT intended to include tons of vendor specific keywords (Oracle, MySQL,
  PostgreSQL) although the list of data types is purposely a bit more expansive.
- For more specific SQL grammars please see:
  - PostgreSQL and PL/pgSQL - core
  - T-SQL - https://github.com/highlightjs/highlightjs-tsql
  - sql_more (core)

 */

function sql(hljs) {
  const regex = hljs.regex;
  const COMMENT_MODE = hljs.COMMENT('--', '$');
  const STRING = {
    className: 'string',
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [ { begin: /''/ } ]
      }
    ]
  };
  const QUOTED_IDENTIFIER = {
    begin: /"/,
    end: /"/,
    contains: [ { begin: /""/ } ]
  };

  const LITERALS = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ];

  const MULTI_WORD_TYPES = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ];

  const TYPES = [
    'bigint',
    'binary',
    'blob',
    'boolean',
    'char',
    'character',
    'clob',
    'date',
    'dec',
    'decfloat',
    'decimal',
    'float',
    'int',
    'integer',
    'interval',
    'nchar',
    'nclob',
    'national',
    'numeric',
    'real',
    'row',
    'smallint',
    'time',
    'timestamp',
    'varchar',
    'varying', // modifier (character varying)
    'varbinary'
  ];

  const NON_RESERVED_WORDS = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ];

  // https://jakewheat.github.io/sql-overview/sql-2016-foundation-grammar.html#reserved-word
  const RESERVED_WORDS = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year",
  ];

  // these are reserved words we have identified to be functions
  // and should only be highlighted in a dispatch-like context
  // ie, array_agg(...), etc.
  const RESERVED_FUNCTIONS = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket",
  ];

  // these functions can
  const POSSIBLE_WITHOUT_PARENS = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ];

  // those exist to boost relevance making these very
  // "SQL like" keyword combos worth +1 extra relevance
  const COMBOS = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ];

  const FUNCTIONS = RESERVED_FUNCTIONS;

  const KEYWORDS = [
    ...RESERVED_WORDS,
    ...NON_RESERVED_WORDS
  ].filter((keyword) => {
    return !RESERVED_FUNCTIONS.includes(keyword);
  });

  const VARIABLE = {
    className: "variable",
    begin: /@[a-z0-9]+/,
  };

  const OPERATOR = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0,
  };

  const FUNCTION_CALL = {
    begin: regex.concat(/\b/, regex.either(...FUNCTIONS), /\s*\(/),
    relevance: 0,
    keywords: { built_in: FUNCTIONS }
  };

  // keywords with less than 3 letters are reduced in relevancy
  function reduceRelevancy(list, {
    exceptions, when
  } = {}) {
    const qualifyFn = when;
    exceptions = exceptions || [];
    return list.map((item) => {
      if (item.match(/\|\d+$/) || exceptions.includes(item)) {
        return item;
      } else if (qualifyFn(item)) {
        return `${item}|0`;
      } else {
        return item;
      }
    });
  }

  return {
    name: 'SQL',
    case_insensitive: true,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword:
        reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
      literal: LITERALS,
      type: TYPES,
      built_in: POSSIBLE_WITHOUT_PARENS
    },
    contains: [
      {
        begin: regex.either(...COMBOS),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: KEYWORDS.concat(COMBOS),
          literal: LITERALS,
          type: TYPES
        },
      },
      {
        className: "type",
        begin: regex.either(...MULTI_WORD_TYPES)
      },
      FUNCTION_CALL,
      VARIABLE,
      STRING,
      QUOTED_IDENTIFIER,
      hljs.C_NUMBER_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      COMMENT_MODE,
      OPERATOR
    ]
  };
}

var sql_1 = sql;

/*
Language: HTML, XML
Website: https://www.w3.org/XML/
Category: common, web
Audit: 2020
*/
/** @type LanguageFn */
function xml(hljs) {
  const regex = hljs.regex;
  // Element names can contain letters, digits, hyphens, underscores, and periods
  const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
  const XML_ENTITIES = {
    className: 'symbol',
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: 'keyword',
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: 'string' });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: 'string' });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: 'attr',
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: 'string',
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [ XML_ENTITIES ]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [ XML_ENTITIES ]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: 'HTML, XML',
    aliases: [
      'html',
      'xhtml',
      'rss',
      'atom',
      'xjb',
      'xsd',
      'xsl',
      'plist',
      'wsf',
      'svg'
    ],
    case_insensitive: true,
    contains: [
      {
        className: 'meta',
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: 'meta',
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      // xml processing instructions
      {
        className: 'meta',
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/,
          }
        ]

      },
      {
        className: 'tag',
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: 'style' },
        contains: [ TAG_INTERNALS ],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            'css',
            'xml'
          ]
        }
      },
      {
        className: 'tag',
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: 'script' },
        contains: [ TAG_INTERNALS ],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            'javascript',
            'handlebars',
            'xml'
          ]
        }
      },
      // we need this for now for jSX
      {
        className: 'tag',
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: 'tag',
        begin: regex.concat(
          /</,
          regex.lookahead(regex.concat(
            TAG_NAME_RE,
            // <tag/>
            // <tag>
            // <tag ...
            regex.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: 'name',
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      // close tag
      {
        className: 'tag',
        begin: regex.concat(
          /<\//,
          regex.lookahead(regex.concat(
            TAG_NAME_RE, />/
          ))
        ),
        contains: [
          {
            className: 'name',
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}

var xml_1 = xml;

core.registerLanguage('javascript', javascript_1);
core.registerLanguage('sql', sql_1);
core.registerLanguage('java', java_1);
core.registerLanguage('xml', xml_1);
core.registerLanguage('python', python_1);
class ParsonsInput {
    // The input element
    el;
    _dropArea;
    _dragArea;
    _dropSortable;
    _dragSortable;
    parentElement;
    _prevPosition;
    reusable;
    randomize;
    storedSourceBlocks;
    storedSourceBlockExplanations;
    hljsLanguage;
    contextBefore;
    contextAfter;
    // if the input has been initialized once
    initialized;
    constructor(parentElement, reusable, randomize) {
        this.el = document.createElement('div');
        this.parentElement = parentElement;
        this.el.id = 'regextool-' + this.parentElement.toolNumber + '-parsons-input';
        const dragTip = document.createElement('div');
        dragTip.innerText = 'Drag or click the blocks below to form your code:';
        dragTip.classList.add('hparsons-tip');
        this.el.append(dragTip);
        this._dragArea = document.createElement('div');
        this.el.appendChild(this._dragArea);
        this._dragArea.classList.add('drag-area');
        const dropTip = document.createElement('div');
        dropTip.innerText = 'Your code (click on a block to remove it):';
        dropTip.classList.add('hparsons-tip');
        this.el.append(dropTip);
        const contextBefore = document.createElement('div');
        contextBefore.id = 'hparsons-' + this.parentElement.toolNumber + '-context-before';
        contextBefore.classList.add('context');
        contextBefore.classList.add('hide');
        this.el.appendChild(contextBefore);
        this.contextBefore = contextBefore;
        this._dropArea = document.createElement('div');
        this.el.appendChild(this._dropArea);
        this._dropArea.classList.add('drop-area');
        this._prevPosition = -1;
        const contextAfter = document.createElement('div');
        contextAfter.id = 'hparsons-' + this.parentElement.toolNumber + '-context-after';
        contextAfter.classList.add('context');
        contextAfter.classList.add('hide');
        this.el.appendChild(contextAfter);
        this.contextAfter = contextAfter;
        this.storedSourceBlocks = [];
        this.storedSourceBlockExplanations = null;
        this.reusable = reusable;
        this.randomize = randomize;
        this._dragSortable = null;
        this._dropSortable = null;
        this._initSortable();
        this.initialized = false;
        this.hljsLanguage = this.parentElement.language;
    }
    getText = () => {
        let ret = '';
        if (this._dropArea.hasChildNodes()) {
            let el = this._dropArea.firstChild;
            ret += el.innerText.replace(/\xA0/g, ' ');
            while (el.nextSibling) {
                el = el.nextSibling;
                ret += el.innerText.replace(/\xA0/g, ' ');
            }
            return ret;
        }
        else {
            return ret;
        }
    };
    // Durstenfeld shuffle
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1));
            let temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    setSourceBlocks = (data, tooltips) => {
        // shuffle source blocks if randomize
        if (this.randomize) {
            let originalData = JSON.stringify(data);
            this.shuffleArray(data);
            while (JSON.stringify(data) == originalData) {
                this.shuffleArray(data);
            }
        }
        this.storedSourceBlocks = data;
        this.storedSourceBlockExplanations = tooltips;
        this._resetInput();
    };
    // TODO: not efficient enough. should not need to create new elements; simply sorting them should be good.
    _resetInput = () => {
        // clearing previous blocks
        while (this._dragArea.firstChild) {
            this._dragArea.removeChild(this._dragArea.firstChild);
        }
        while (this._dropArea.firstChild) {
            this._dropArea.removeChild(this._dropArea.firstChild);
        }
        // add new blocks
        for (let i = 0; i < this.storedSourceBlocks.length; ++i) {
            const newBlock = document.createElement('div');
            this._dragArea.appendChild(newBlock);
            if (this.storedSourceBlocks[i] === ' ') {
                // console.log('here');
                newBlock.innerHTML = '&nbsp;';
            }
            else {
                // console.log(data[i]);
                if (this.hljsLanguage) {
                    newBlock.innerHTML = core.highlight(this.storedSourceBlocks[i], { language: this.hljsLanguage, ignoreIllegals: true }).value;
                }
                else {
                    newBlock.innerText = this.storedSourceBlocks[i];
                }
            }
            newBlock.style.display = 'inline-block';
            newBlock.classList.add('parsons-block');
            newBlock.onclick = () => {
                this._onBlockClicked(newBlock);
            };
        }
    };
    _onBlockClicked = (block) => {
        if (block.parentElement == this._dragArea) {
            let endPosition;
            if (this.reusable) {
                const blockCopy = block.cloneNode(true);
                blockCopy.onclick = () => this._onBlockClicked(blockCopy);
                this._dropArea.appendChild(blockCopy);
                endPosition = this._getBlockPosition(blockCopy);
            }
            else {
                this._dropArea.appendChild(block);
                endPosition = this._getBlockPosition(block);
            }
            const inputEvent = {
                'event-type': 'parsons-input',
                action: 'add',
                position: [-1, endPosition],
                answer: this._getTextArray(),
            };
            this.parentElement.logEvent(inputEvent);
        }
        else {
            const startPosition = this._getBlockPosition(block);
            if (this.reusable) {
                this._dropArea.removeChild(block);
            }
            else {
                this._dragArea.appendChild(block);
            }
            const inputEvent = {
                'event-type': 'parsons-input',
                action: 'remove',
                position: [startPosition, -1],
                answer: this._getTextArray(),
            };
            this.parentElement.logEvent(inputEvent);
        }
    };
    _initSortable = () => {
        if (this.reusable) {
            this._dragSortable = new Sortable(this._dragArea, {
                group: {
                    name: 'shared',
                    pull: 'clone',
                    put: false
                },
                sort: false,
                direction: 'horizontal',
                animation: 150,
                draggable: '.parsons-block',
                onClone: (event) => {
                    const newBlock = event.clone;
                    newBlock.onclick = () => this._onBlockClicked(newBlock);
                }
            });
            this._dropSortable = new Sortable(this._dropArea, {
                group: 'shared',
                direction: 'horizontal',
                animation: 150,
                draggable: '.parsons-block',
                onAdd: (event) => {
                    const inputEvent = {
                        'event-type': 'parsons-input',
                        action: 'add',
                        position: [-1, this._getBlockPosition(event.item)],
                        answer: this._getTextArray(),
                    };
                    this.parentElement.logEvent(inputEvent);
                },
                onStart: (event) => {
                    this._prevPosition = this._getBlockPosition(event.item);
                },
                onEnd: (event) => {
                    let endposition;
                    let action = 'move';
                    const upperbound = this._dropArea.getBoundingClientRect().top;
                    const lowerbound = this._dropArea.getBoundingClientRect().bottom;
                    if (event.originalEvent.clientY > lowerbound || event.originalEvent.clientY < upperbound) {
                        const item = event.item;
                        if (item.parentNode) {
                            item.parentNode.removeChild(item);
                        }
                        endposition = -1;
                        action = 'remove';
                    }
                    else {
                        endposition = this._getBlockPosition(event.item);
                    }
                    const inputEvent = {
                        'event-type': 'parsons-input',
                        action: action,
                        position: [this._prevPosition, endposition],
                        answer: this._getTextArray(),
                    };
                    this.parentElement.logEvent(inputEvent);
                },
            });
        }
        else {
            this._dragSortable = new Sortable(this._dragArea, {
                group: {
                    name: 'shared',
                    // pull: 'clone',
                    // put: false
                },
                // sort: false,
                direction: 'horizontal',
                animation: 150,
                draggable: '.parsons-block',
            });
            this._dropSortable = new Sortable(this._dropArea, {
                group: 'shared',
                direction: 'horizontal',
                animation: 150,
                draggable: '.parsons-block',
                onAdd: (event) => {
                    const inputEvent = {
                        'event-type': 'parsons-input',
                        action: 'add',
                        position: [-1, this._getBlockPosition(event.item)],
                        answer: this._getTextArray(),
                    };
                    this.parentElement.logEvent(inputEvent);
                },
                onStart: (event) => {
                    this._prevPosition = this._getBlockPosition(event.item);
                },
                onEnd: (event) => {
                    let endposition = this._getBlockPosition(event.item);
                    const action = endposition == -1 ? 'remove' : 'move';
                    const inputEvent = {
                        'event-type': 'parsons-input',
                        action: action,
                        position: [this._prevPosition, endposition],
                        answer: this._getTextArray(),
                    };
                    this.parentElement.logEvent(inputEvent);
                },
            });
        }
    };
    updateTestStatus = (result) => {
        if (this._dropArea.classList.contains(result)) {
            return;
        }
        if (this._dropArea.classList.contains('Pass')) {
            this._dropArea.classList.remove('Pass');
        }
        else if (this._dropArea.classList.contains('Fail')) {
            this._dropArea.classList.remove('Fail');
        }
        else if (this._dropArea.classList.contains('Error')) {
            this._dropArea.classList.remove('Error');
        }
        this._dropArea.classList.add(result);
    };
    _getBlockPosition = (block) => {
        let position = -1;
        const parent = this._dropArea;
        if (parent) {
            for (position = 0; position < parent.childNodes.length; ++position) {
                if (parent.childNodes[position] === block) {
                    break;
                }
            }
        }
        return position;
    };
    _getTextArray = () => {
        let answer = [];
        if (this._dropArea.hasChildNodes()) {
            let el = this._dropArea.firstChild;
            answer.push(el.innerText);
            while (el.nextSibling) {
                el = el.nextSibling;
                answer.push(el.innerText);
            }
        }
        return answer;
    };
    highlightError = (position) => {
        // console.log(position);
        let count = 0;
        if (this._dropArea.hasChildNodes()) {
            let el = this._dropArea.firstChild;
            count += el.innerText.length;
            if (count >= position) {
                // the current block contains the symbol with error
                el.style.backgroundColor = '#ff99b3';
            }
            else {
                while (el.nextSibling) {
                    el = el.nextSibling;
                    count += el.innerText.length;
                    if (count >= position) {
                        // the current block contains the symbol with error
                        el.style.backgroundColor = '#ff99b3';
                        break;
                    }
                }
            }
        }
    };
    removeFormat = () => {
        if (this._dropArea.hasChildNodes()) {
            let el = this._dropArea.firstChild;
            el.style.removeProperty('background-color');
            while (el.nextSibling) {
                el = el.nextSibling;
                el.style.removeProperty('background-color');
            }
        }
    };
    resetInput = () => {
        if (this.reusable) {
            while (this._dropArea.firstChild) {
                this._dropArea.removeChild(this._dropArea.firstChild);
            }
        }
        else {
            this._resetInput();
        }
    };
    // TODO: not used for now, not sure if is working correctly
    restoreAnswer(type, answer) {
        if (type != 'parsons' || !Array.isArray(answer)) {
            return;
        }
        this._dropArea.innerHTML = '';
        for (let i = 0; i < answer.length; ++i) {
            if (typeof answer[i] === 'string') {
                const newBlock = document.createElement('div');
                this._dropArea.appendChild(newBlock);
                newBlock.innerText = answer[i];
                newBlock.style.display = 'inline-block';
                newBlock.classList.add('parsons-block');
                newBlock.onclick = () => {
                    // clicking the new block generated by clicking an extendable block to remove that block
                    // console.log('expandable new block onclick')
                    const endPosition = this._getBlockPosition(newBlock);
                    newBlock.parentNode?.removeChild(newBlock);
                    if (this.parentElement) {
                        this.parentElement.temporaryInputEvent = {
                            'event-type': 'parsons-input',
                            action: RegexEvent.ParsonsInputAction.REMOVE,
                            position: [endPosition, -1],
                            answer: this._getTextArray()
                        };
                    }
                };
                this.el.dispatchEvent(new Event('codeChanged'));
            }
        }
    }
    setIndent = (indent) => {
        const fontSize = Number(window.getComputedStyle(this.contextBefore, null).getPropertyValue('font-size').slice(0, -2));
        this._dropArea.style.paddingLeft = fontSize * indent + 'px';
    };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */

var quill = createCommonjsModule(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_233122__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_233122__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_233122__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_233122__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_233122__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_233122__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_233122__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_233122__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_233122__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_233122__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_233122__(__nested_webpack_require_233122__.s = 109);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __nested_webpack_require_235401__) {

Object.defineProperty(exports, "__esModule", { value: true });
var container_1 = __nested_webpack_require_235401__(17);
var format_1 = __nested_webpack_require_235401__(18);
var leaf_1 = __nested_webpack_require_235401__(19);
var scroll_1 = __nested_webpack_require_235401__(45);
var inline_1 = __nested_webpack_require_235401__(46);
var block_1 = __nested_webpack_require_235401__(47);
var embed_1 = __nested_webpack_require_235401__(48);
var text_1 = __nested_webpack_require_235401__(49);
var attributor_1 = __nested_webpack_require_235401__(12);
var class_1 = __nested_webpack_require_235401__(32);
var style_1 = __nested_webpack_require_235401__(33);
var store_1 = __nested_webpack_require_235401__(31);
var Registry = __nested_webpack_require_235401__(1);
var Parchment = {
    Scope: Registry.Scope,
    create: Registry.create,
    find: Registry.find,
    query: Registry.query,
    register: Registry.register,
    Container: container_1.default,
    Format: format_1.default,
    Leaf: leaf_1.default,
    Embed: embed_1.default,
    Scroll: scroll_1.default,
    Block: block_1.default,
    Inline: inline_1.default,
    Text: text_1.default,
    Attributor: {
        Attribute: attributor_1.default,
        Class: class_1.default,
        Style: style_1.default,
        Store: store_1.default,
    },
};
exports.default = Parchment;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ParchmentError = /** @class */ (function (_super) {
    __extends(ParchmentError, _super);
    function ParchmentError(message) {
        var _this = this;
        message = '[Parchment] ' + message;
        _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _this.constructor.name;
        return _this;
    }
    return ParchmentError;
}(Error));
exports.ParchmentError = ParchmentError;
var attributes = {};
var classes = {};
var tags = {};
var types = {};
exports.DATA_KEY = '__blot';
var Scope;
(function (Scope) {
    Scope[Scope["TYPE"] = 3] = "TYPE";
    Scope[Scope["LEVEL"] = 12] = "LEVEL";
    Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
    Scope[Scope["BLOT"] = 14] = "BLOT";
    Scope[Scope["INLINE"] = 7] = "INLINE";
    Scope[Scope["BLOCK"] = 11] = "BLOCK";
    Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
    Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
    Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
    Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
    Scope[Scope["ANY"] = 15] = "ANY";
})(Scope = exports.Scope || (exports.Scope = {}));
function create(input, value) {
    var match = query(input);
    if (match == null) {
        throw new ParchmentError("Unable to create " + input + " blot");
    }
    var BlotClass = match;
    var node = 
    // @ts-ignore
    input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
    return new BlotClass(node, value);
}
exports.create = create;
function find(node, bubble) {
    if (bubble === void 0) { bubble = false; }
    if (node == null)
        return null;
    // @ts-ignore
    if (node[exports.DATA_KEY] != null)
        return node[exports.DATA_KEY].blot;
    if (bubble)
        return find(node.parentNode, bubble);
    return null;
}
exports.find = find;
function query(query, scope) {
    if (scope === void 0) { scope = Scope.ANY; }
    var match;
    if (typeof query === 'string') {
        match = types[query] || attributes[query];
        // @ts-ignore
    }
    else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
        match = types['text'];
    }
    else if (typeof query === 'number') {
        if (query & Scope.LEVEL & Scope.BLOCK) {
            match = types['block'];
        }
        else if (query & Scope.LEVEL & Scope.INLINE) {
            match = types['inline'];
        }
    }
    else if (query instanceof HTMLElement) {
        var names = (query.getAttribute('class') || '').split(/\s+/);
        for (var i in names) {
            match = classes[names[i]];
            if (match)
                break;
        }
        match = match || tags[query.tagName];
    }
    if (match == null)
        return null;
    // @ts-ignore
    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
        return match;
    return null;
}
exports.query = query;
function register() {
    var Definitions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        Definitions[_i] = arguments[_i];
    }
    if (Definitions.length > 1) {
        return Definitions.map(function (d) {
            return register(d);
        });
    }
    var Definition = Definitions[0];
    if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
        throw new ParchmentError('Invalid definition');
    }
    else if (Definition.blotName === 'abstract') {
        throw new ParchmentError('Cannot register abstract class');
    }
    types[Definition.blotName || Definition.attrName] = Definition;
    if (typeof Definition.keyName === 'string') {
        attributes[Definition.keyName] = Definition;
    }
    else {
        if (Definition.className != null) {
            classes[Definition.className] = Definition;
        }
        if (Definition.tagName != null) {
            if (Array.isArray(Definition.tagName)) {
                Definition.tagName = Definition.tagName.map(function (tagName) {
                    return tagName.toUpperCase();
                });
            }
            else {
                Definition.tagName = Definition.tagName.toUpperCase();
            }
            var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
            tagNames.forEach(function (tag) {
                if (tags[tag] == null || Definition.className == null) {
                    tags[tag] = Definition;
                }
            });
        }
    }
    return Definition;
}
exports.register = register;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_241840__) {

var diff = __nested_webpack_require_241840__(51);
var equal = __nested_webpack_require_241840__(11);
var extend = __nested_webpack_require_241840__(3);
var op = __nested_webpack_require_241840__(20);


var NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()


var Delta = function (ops) {
  // Assume we are given a well formed ops
  if (Array.isArray(ops)) {
    this.ops = ops;
  } else if (ops != null && Array.isArray(ops.ops)) {
    this.ops = ops.ops;
  } else {
    this.ops = [];
  }
};


Delta.prototype.insert = function (text, attributes) {
  var newOp = {};
  if (text.length === 0) return this;
  newOp.insert = text;
  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};

Delta.prototype['delete'] = function (length) {
  if (length <= 0) return this;
  return this.push({ 'delete': length });
};

Delta.prototype.retain = function (length, attributes) {
  if (length <= 0) return this;
  var newOp = { retain: length };
  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
    newOp.attributes = attributes;
  }
  return this.push(newOp);
};

Delta.prototype.push = function (newOp) {
  var index = this.ops.length;
  var lastOp = this.ops[index - 1];
  newOp = extend(true, {}, newOp);
  if (typeof lastOp === 'object') {
    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };
      return this;
    }
    // Since it does not matter if we insert before or after deleting at the same index,
    // always prefer to insert first
    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
      index -= 1;
      lastOp = this.ops[index - 1];
      if (typeof lastOp !== 'object') {
        this.ops.unshift(newOp);
        return this;
      }
    }
    if (equal(newOp.attributes, lastOp.attributes)) {
      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
        return this;
      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
        return this;
      }
    }
  }
  if (index === this.ops.length) {
    this.ops.push(newOp);
  } else {
    this.ops.splice(index, 0, newOp);
  }
  return this;
};

Delta.prototype.chop = function () {
  var lastOp = this.ops[this.ops.length - 1];
  if (lastOp && lastOp.retain && !lastOp.attributes) {
    this.ops.pop();
  }
  return this;
};

Delta.prototype.filter = function (predicate) {
  return this.ops.filter(predicate);
};

Delta.prototype.forEach = function (predicate) {
  this.ops.forEach(predicate);
};

Delta.prototype.map = function (predicate) {
  return this.ops.map(predicate);
};

Delta.prototype.partition = function (predicate) {
  var passed = [], failed = [];
  this.forEach(function(op) {
    var target = predicate(op) ? passed : failed;
    target.push(op);
  });
  return [passed, failed];
};

Delta.prototype.reduce = function (predicate, initial) {
  return this.ops.reduce(predicate, initial);
};

Delta.prototype.changeLength = function () {
  return this.reduce(function (length, elem) {
    if (elem.insert) {
      return length + op.length(elem);
    } else if (elem.delete) {
      return length - elem.delete;
    }
    return length;
  }, 0);
};

Delta.prototype.length = function () {
  return this.reduce(function (length, elem) {
    return length + op.length(elem);
  }, 0);
};

Delta.prototype.slice = function (start, end) {
  start = start || 0;
  if (typeof end !== 'number') end = Infinity;
  var ops = [];
  var iter = op.iterator(this.ops);
  var index = 0;
  while (index < end && iter.hasNext()) {
    var nextOp;
    if (index < start) {
      nextOp = iter.next(start - index);
    } else {
      nextOp = iter.next(end - index);
      ops.push(nextOp);
    }
    index += op.length(nextOp);
  }
  return new Delta(ops);
};


Delta.prototype.compose = function (other) {
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var ops = [];
  var firstOther = otherIter.peek();
  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
    var firstLeft = firstOther.retain;
    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
      firstLeft -= thisIter.peekLength();
      ops.push(thisIter.next());
    }
    if (firstOther.retain - firstLeft > 0) {
      otherIter.next(firstOther.retain - firstLeft);
    }
  }
  var delta = new Delta(ops);
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (otherIter.peekType() === 'insert') {
      delta.push(otherIter.next());
    } else if (thisIter.peekType() === 'delete') {
      delta.push(thisIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (typeof otherOp.retain === 'number') {
        var newOp = {};
        if (typeof thisOp.retain === 'number') {
          newOp.retain = length;
        } else {
          newOp.insert = thisOp.insert;
        }
        // Preserve null when composing with a retain, otherwise remove it for inserts
        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
        if (attributes) newOp.attributes = attributes;
        delta.push(newOp);

        // Optimization if rest of other is just retain
        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
          var rest = new Delta(thisIter.rest());
          return delta.concat(rest).chop();
        }

      // Other op should be delete, we could be an insert or retain
      // Insert + delete cancels out
      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
        delta.push(otherOp);
      }
    }
  }
  return delta.chop();
};

Delta.prototype.concat = function (other) {
  var delta = new Delta(this.ops.slice());
  if (other.ops.length > 0) {
    delta.push(other.ops[0]);
    delta.ops = delta.ops.concat(other.ops.slice(1));
  }
  return delta;
};

Delta.prototype.diff = function (other, index) {
  if (this.ops === other.ops) {
    return new Delta();
  }
  var strings = [this, other].map(function (delta) {
    return delta.map(function (op) {
      if (op.insert != null) {
        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
      }
      var prep = (delta === other) ? 'on' : 'with';
      throw new Error('diff() called ' + prep + ' non-document');
    }).join('');
  });
  var delta = new Delta();
  var diffResult = diff(strings[0], strings[1], index);
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  diffResult.forEach(function (component) {
    var length = component[1].length;
    while (length > 0) {
      var opLength = 0;
      switch (component[0]) {
        case diff.INSERT:
          opLength = Math.min(otherIter.peekLength(), length);
          delta.push(otherIter.next(opLength));
          break;
        case diff.DELETE:
          opLength = Math.min(length, thisIter.peekLength());
          thisIter.next(opLength);
          delta['delete'](opLength);
          break;
        case diff.EQUAL:
          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
          var thisOp = thisIter.next(opLength);
          var otherOp = otherIter.next(opLength);
          if (equal(thisOp.insert, otherOp.insert)) {
            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
          } else {
            delta.push(otherOp)['delete'](opLength);
          }
          break;
      }
      length -= opLength;
    }
  });
  return delta.chop();
};

Delta.prototype.eachLine = function (predicate, newline) {
  newline = newline || '\n';
  var iter = op.iterator(this.ops);
  var line = new Delta();
  var i = 0;
  while (iter.hasNext()) {
    if (iter.peekType() !== 'insert') return;
    var thisOp = iter.peek();
    var start = op.length(thisOp) - iter.peekLength();
    var index = typeof thisOp.insert === 'string' ?
      thisOp.insert.indexOf(newline, start) - start : -1;
    if (index < 0) {
      line.push(iter.next());
    } else if (index > 0) {
      line.push(iter.next(index));
    } else {
      if (predicate(line, iter.next(1).attributes || {}, i) === false) {
        return;
      }
      i += 1;
      line = new Delta();
    }
  }
  if (line.length() > 0) {
    predicate(line, {}, i);
  }
};

Delta.prototype.transform = function (other, priority) {
  priority = !!priority;
  if (typeof other === 'number') {
    return this.transformPosition(other, priority);
  }
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var delta = new Delta();
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
      delta.retain(op.length(thisIter.next()));
    } else if (otherIter.peekType() === 'insert') {
      delta.push(otherIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (thisOp['delete']) {
        // Our delete either makes their delete redundant or removes their retain
        continue;
      } else if (otherOp['delete']) {
        delta.push(otherOp);
      } else {
        // We retain either their retain or insert
        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
      }
    }
  }
  return delta.chop();
};

Delta.prototype.transformPosition = function (index, priority) {
  priority = !!priority;
  var thisIter = op.iterator(this.ops);
  var offset = 0;
  while (thisIter.hasNext() && offset <= index) {
    var length = thisIter.peekLength();
    var nextType = thisIter.peekType();
    thisIter.next();
    if (nextType === 'delete') {
      index -= Math.min(length, index - offset);
      continue;
    } else if (nextType === 'insert' && (offset < index || !priority)) {
      index += length;
    }
    offset += length;
  }
  return index;
};


module.exports = Delta;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_255998__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extend = __nested_webpack_require_255998__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __nested_webpack_require_255998__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __nested_webpack_require_255998__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _break = __nested_webpack_require_255998__(16);

var _break2 = _interopRequireDefault(_break);

var _inline = __nested_webpack_require_255998__(6);

var _inline2 = _interopRequireDefault(_inline);

var _text = __nested_webpack_require_255998__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NEWLINE_LENGTH = 1;

var BlockEmbed = function (_Parchment$Embed) {
  _inherits(BlockEmbed, _Parchment$Embed);

  function BlockEmbed() {
    _classCallCheck(this, BlockEmbed);

    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
  }

  _createClass(BlockEmbed, [{
    key: 'attach',
    value: function attach() {
      _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
      this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
    }
  }, {
    key: 'delta',
    value: function delta() {
      return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
      if (attribute != null) {
        this.attributes.attribute(attribute, value);
      }
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      this.format(name, value);
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (typeof value === 'string' && value.endsWith('\n')) {
        var block = _parchment2.default.create(Block.blotName);
        this.parent.insertBefore(block, index === 0 ? this : this.next);
        block.insertAt(0, value.slice(0, -1));
      } else {
        _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
      }
    }
  }]);

  return BlockEmbed;
}(_parchment2.default.Embed);

BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
// It is important for cursor behavior BlockEmbeds use tags that are block level elements


var Block = function (_Parchment$Block) {
  _inherits(Block, _Parchment$Block);

  function Block(domNode) {
    _classCallCheck(this, Block);

    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));

    _this2.cache = {};
    return _this2;
  }

  _createClass(Block, [{
    key: 'delta',
    value: function delta() {
      if (this.cache.delta == null) {
        this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
          if (leaf.length() === 0) {
            return delta;
          } else {
            return delta.insert(leaf.value(), bubbleFormats(leaf));
          }
        }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
      }
      return this.cache.delta;
    }
  }, {
    key: 'deleteAt',
    value: function deleteAt(index, length) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
      this.cache = {};
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (length <= 0) return;
      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
        if (index + length === this.length()) {
          this.format(name, value);
        }
      } else {
        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
      }
      this.cache = {};
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
      if (value.length === 0) return;
      var lines = value.split('\n');
      var text = lines.shift();
      if (text.length > 0) {
        if (index < this.length() - 1 || this.children.tail == null) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
        } else {
          this.children.tail.insertAt(this.children.tail.length(), text);
        }
        this.cache = {};
      }
      var block = this;
      lines.reduce(function (index, line) {
        block = block.split(index, true);
        block.insertAt(0, line);
        return line.length;
      }, index + text.length);
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      var head = this.children.head;
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
      if (head instanceof _break2.default) {
        head.remove();
      }
      this.cache = {};
    }
  }, {
    key: 'length',
    value: function length() {
      if (this.cache.length == null) {
        this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
      }
      return this.cache.length;
    }
  }, {
    key: 'moveChildren',
    value: function moveChildren(target, ref) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
      this.cache = {};
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
      this.cache = {};
    }
  }, {
    key: 'path',
    value: function path(index) {
      return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
    }
  }, {
    key: 'removeChild',
    value: function removeChild(child) {
      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
      this.cache = {};
    }
  }, {
    key: 'split',
    value: function split(index) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
        var clone = this.clone();
        if (index === 0) {
          this.parent.insertBefore(clone, this);
          return this;
        } else {
          this.parent.insertBefore(clone, this.next);
          return clone;
        }
      } else {
        var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
        this.cache = {};
        return next;
      }
    }
  }]);

  return Block;
}(_parchment2.default.Block);

Block.blotName = 'block';
Block.tagName = 'P';
Block.defaultChild = 'break';
Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];

function bubbleFormats(blot) {
  var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (blot == null) return formats;
  if (typeof blot.formats === 'function') {
    formats = (0, _extend2.default)(formats, blot.formats());
  }
  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
    return formats;
  }
  return bubbleFormats(blot.parent, formats);
}

exports.bubbleFormats = bubbleFormats;
exports.BlockEmbed = BlockEmbed;
exports.default = Block;

/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_266127__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.overload = exports.expandConfig = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__nested_webpack_require_266127__(50);

var _quillDelta = __nested_webpack_require_266127__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _editor = __nested_webpack_require_266127__(14);

var _editor2 = _interopRequireDefault(_editor);

var _emitter3 = __nested_webpack_require_266127__(8);

var _emitter4 = _interopRequireDefault(_emitter3);

var _module = __nested_webpack_require_266127__(9);

var _module2 = _interopRequireDefault(_module);

var _parchment = __nested_webpack_require_266127__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _selection = __nested_webpack_require_266127__(15);

var _selection2 = _interopRequireDefault(_selection);

var _extend = __nested_webpack_require_266127__(3);

var _extend2 = _interopRequireDefault(_extend);

var _logger = __nested_webpack_require_266127__(10);

var _logger2 = _interopRequireDefault(_logger);

var _theme = __nested_webpack_require_266127__(34);

var _theme2 = _interopRequireDefault(_theme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _logger2.default)('quill');

var Quill = function () {
  _createClass(Quill, null, [{
    key: 'debug',
    value: function debug(limit) {
      if (limit === true) {
        limit = 'log';
      }
      _logger2.default.level(limit);
    }
  }, {
    key: 'find',
    value: function find(node) {
      return node.__quill || _parchment2.default.find(node);
    }
  }, {
    key: 'import',
    value: function _import(name) {
      if (this.imports[name] == null) {
        debug.error('Cannot import ' + name + '. Are you sure it was registered?');
      }
      return this.imports[name];
    }
  }, {
    key: 'register',
    value: function register(path, target) {
      var _this = this;

      var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (typeof path !== 'string') {
        var name = path.attrName || path.blotName;
        if (typeof name === 'string') {
          // register(Blot | Attributor, overwrite)
          this.register('formats/' + name, path, target);
        } else {
          Object.keys(path).forEach(function (key) {
            _this.register(key, path[key], target);
          });
        }
      } else {
        if (this.imports[path] != null && !overwrite) {
          debug.warn('Overwriting ' + path + ' with', target);
        }
        this.imports[path] = target;
        if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
          _parchment2.default.register(target);
        } else if (path.startsWith('modules') && typeof target.register === 'function') {
          target.register();
        }
      }
    }
  }]);

  function Quill(container) {
    var _this2 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Quill);

    this.options = expandConfig(container, options);
    this.container = this.options.container;
    if (this.container == null) {
      return debug.error('Invalid Quill container', container);
    }
    if (this.options.debug) {
      Quill.debug(this.options.debug);
    }
    var html = this.container.innerHTML.trim();
    this.container.classList.add('ql-container');
    this.container.innerHTML = '';
    this.container.__quill = this;
    this.root = this.addContainer('ql-editor');
    this.root.classList.add('ql-blank');
    this.root.setAttribute('data-gramm', false);
    this.scrollingContainer = this.options.scrollingContainer || this.root;
    this.emitter = new _emitter4.default();
    this.scroll = _parchment2.default.create(this.root, {
      emitter: this.emitter,
      whitelist: this.options.formats
    });
    this.editor = new _editor2.default(this.scroll);
    this.selection = new _selection2.default(this.scroll, this.emitter);
    this.theme = new this.options.theme(this, this.options);
    this.keyboard = this.theme.addModule('keyboard');
    this.clipboard = this.theme.addModule('clipboard');
    this.history = this.theme.addModule('history');
    this.theme.init();
    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
      if (type === _emitter4.default.events.TEXT_CHANGE) {
        _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
      }
    });
    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
      var range = _this2.selection.lastRange;
      var index = range && range.length === 0 ? range.index : undefined;
      modify.call(_this2, function () {
        return _this2.editor.update(null, mutations, index);
      }, source);
    });
    var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
    this.setContents(contents);
    this.history.clear();
    if (this.options.placeholder) {
      this.root.setAttribute('data-placeholder', this.options.placeholder);
    }
    if (this.options.readOnly) {
      this.disable();
    }
  }

  _createClass(Quill, [{
    key: 'addContainer',
    value: function addContainer(container) {
      var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof container === 'string') {
        var className = container;
        container = document.createElement('div');
        container.classList.add(className);
      }
      this.container.insertBefore(container, refNode);
      return container;
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.selection.setRange(null);
    }
  }, {
    key: 'deleteText',
    value: function deleteText(index, length, source) {
      var _this3 = this;

      var _overload = overload(index, length, source);

      var _overload2 = _slicedToArray(_overload, 4);

      index = _overload2[0];
      length = _overload2[1];
      source = _overload2[3];

      return modify.call(this, function () {
        return _this3.editor.deleteText(index, length);
      }, source, index, -1 * length);
    }
  }, {
    key: 'disable',
    value: function disable() {
      this.enable(false);
    }
  }, {
    key: 'enable',
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.scroll.enable(enabled);
      this.container.classList.toggle('ql-disabled', !enabled);
    }
  }, {
    key: 'focus',
    value: function focus() {
      var scrollTop = this.scrollingContainer.scrollTop;
      this.selection.focus();
      this.scrollingContainer.scrollTop = scrollTop;
      this.scrollIntoView();
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      var _this4 = this;

      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        var range = _this4.getSelection(true);
        var change = new _quillDelta2.default();
        if (range == null) {
          return change;
        } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
          change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
        } else if (range.length === 0) {
          _this4.selection.format(name, value);
          return change;
        } else {
          change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
        }
        _this4.setSelection(range, _emitter4.default.sources.SILENT);
        return change;
      }, source);
    }
  }, {
    key: 'formatLine',
    value: function formatLine(index, length, name, value, source) {
      var _this5 = this;

      var formats = void 0;

      var _overload3 = overload(index, length, name, value, source);

      var _overload4 = _slicedToArray(_overload3, 4);

      index = _overload4[0];
      length = _overload4[1];
      formats = _overload4[2];
      source = _overload4[3];

      return modify.call(this, function () {
        return _this5.editor.formatLine(index, length, formats);
      }, source, index, 0);
    }
  }, {
    key: 'formatText',
    value: function formatText(index, length, name, value, source) {
      var _this6 = this;

      var formats = void 0;

      var _overload5 = overload(index, length, name, value, source);

      var _overload6 = _slicedToArray(_overload5, 4);

      index = _overload6[0];
      length = _overload6[1];
      formats = _overload6[2];
      source = _overload6[3];

      return modify.call(this, function () {
        return _this6.editor.formatText(index, length, formats);
      }, source, index, 0);
    }
  }, {
    key: 'getBounds',
    value: function getBounds(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var bounds = void 0;
      if (typeof index === 'number') {
        bounds = this.selection.getBounds(index, length);
      } else {
        bounds = this.selection.getBounds(index.index, index.length);
      }
      var containerBounds = this.container.getBoundingClientRect();
      return {
        bottom: bounds.bottom - containerBounds.top,
        height: bounds.height,
        left: bounds.left - containerBounds.left,
        right: bounds.right - containerBounds.left,
        top: bounds.top - containerBounds.top,
        width: bounds.width
      };
    }
  }, {
    key: 'getContents',
    value: function getContents() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

      var _overload7 = overload(index, length);

      var _overload8 = _slicedToArray(_overload7, 2);

      index = _overload8[0];
      length = _overload8[1];

      return this.editor.getContents(index, length);
    }
  }, {
    key: 'getFormat',
    value: function getFormat() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (typeof index === 'number') {
        return this.editor.getFormat(index, length);
      } else {
        return this.editor.getFormat(index.index, index.length);
      }
    }
  }, {
    key: 'getIndex',
    value: function getIndex(blot) {
      return blot.offset(this.scroll);
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      return this.scroll.length();
    }
  }, {
    key: 'getLeaf',
    value: function getLeaf(index) {
      return this.scroll.leaf(index);
    }
  }, {
    key: 'getLine',
    value: function getLine(index) {
      return this.scroll.line(index);
    }
  }, {
    key: 'getLines',
    value: function getLines() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

      if (typeof index !== 'number') {
        return this.scroll.lines(index.index, index.length);
      } else {
        return this.scroll.lines(index, length);
      }
    }
  }, {
    key: 'getModule',
    value: function getModule(name) {
      return this.theme.modules[name];
    }
  }, {
    key: 'getSelection',
    value: function getSelection() {
      var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (focus) this.focus();
      this.update(); // Make sure we access getRange with editor in consistent state
      return this.selection.getRange()[0];
    }
  }, {
    key: 'getText',
    value: function getText() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

      var _overload9 = overload(index, length);

      var _overload10 = _slicedToArray(_overload9, 2);

      index = _overload10[0];
      length = _overload10[1];

      return this.editor.getText(index, length);
    }
  }, {
    key: 'hasFocus',
    value: function hasFocus() {
      return this.selection.hasFocus();
    }
  }, {
    key: 'insertEmbed',
    value: function insertEmbed(index, embed, value) {
      var _this7 = this;

      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;

      return modify.call(this, function () {
        return _this7.editor.insertEmbed(index, embed, value);
      }, source, index);
    }
  }, {
    key: 'insertText',
    value: function insertText(index, text, name, value, source) {
      var _this8 = this;

      var formats = void 0;

      var _overload11 = overload(index, 0, name, value, source);

      var _overload12 = _slicedToArray(_overload11, 4);

      index = _overload12[0];
      formats = _overload12[2];
      source = _overload12[3];

      return modify.call(this, function () {
        return _this8.editor.insertText(index, text, formats);
      }, source, index, text.length);
    }
  }, {
    key: 'isEnabled',
    value: function isEnabled() {
      return !this.container.classList.contains('ql-disabled');
    }
  }, {
    key: 'off',
    value: function off() {
      return this.emitter.off.apply(this.emitter, arguments);
    }
  }, {
    key: 'on',
    value: function on() {
      return this.emitter.on.apply(this.emitter, arguments);
    }
  }, {
    key: 'once',
    value: function once() {
      return this.emitter.once.apply(this.emitter, arguments);
    }
  }, {
    key: 'pasteHTML',
    value: function pasteHTML(index, html, source) {
      this.clipboard.dangerouslyPasteHTML(index, html, source);
    }
  }, {
    key: 'removeFormat',
    value: function removeFormat(index, length, source) {
      var _this9 = this;

      var _overload13 = overload(index, length, source);

      var _overload14 = _slicedToArray(_overload13, 4);

      index = _overload14[0];
      length = _overload14[1];
      source = _overload14[3];

      return modify.call(this, function () {
        return _this9.editor.removeFormat(index, length);
      }, source, index);
    }
  }, {
    key: 'scrollIntoView',
    value: function scrollIntoView() {
      this.selection.scrollIntoView(this.scrollingContainer);
    }
  }, {
    key: 'setContents',
    value: function setContents(delta) {
      var _this10 = this;

      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        delta = new _quillDelta2.default(delta);
        var length = _this10.getLength();
        var deleted = _this10.editor.deleteText(0, length);
        var applied = _this10.editor.applyDelta(delta);
        var lastOp = applied.ops[applied.ops.length - 1];
        if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
          _this10.editor.deleteText(_this10.getLength() - 1, 1);
          applied.delete(1);
        }
        var ret = deleted.compose(applied);
        return ret;
      }, source);
    }
  }, {
    key: 'setSelection',
    value: function setSelection(index, length, source) {
      if (index == null) {
        this.selection.setRange(null, length || Quill.sources.API);
      } else {
        var _overload15 = overload(index, length, source);

        var _overload16 = _slicedToArray(_overload15, 4);

        index = _overload16[0];
        length = _overload16[1];
        source = _overload16[3];

        this.selection.setRange(new _selection.Range(index, length), source);
        if (source !== _emitter4.default.sources.SILENT) {
          this.selection.scrollIntoView(this.scrollingContainer);
        }
      }
    }
  }, {
    key: 'setText',
    value: function setText(text) {
      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      var delta = new _quillDelta2.default().insert(text);
      return this.setContents(delta, source);
    }
  }, {
    key: 'update',
    value: function update() {
      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

      var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes
      this.selection.update(source);
      return change;
    }
  }, {
    key: 'updateContents',
    value: function updateContents(delta) {
      var _this11 = this;

      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

      return modify.call(this, function () {
        delta = new _quillDelta2.default(delta);
        return _this11.editor.applyDelta(delta, source);
      }, source, true);
    }
  }]);

  return Quill;
}();

Quill.DEFAULTS = {
  bounds: null,
  formats: null,
  modules: {},
  placeholder: '',
  readOnly: false,
  scrollingContainer: null,
  strict: true,
  theme: 'default'
};
Quill.events = _emitter4.default.events;
Quill.sources = _emitter4.default.sources;
// eslint-disable-next-line no-undef
Quill.version =  "1.3.7";

Quill.imports = {
  'delta': _quillDelta2.default,
  'parchment': _parchment2.default,
  'core/module': _module2.default,
  'core/theme': _theme2.default
};

function expandConfig(container, userConfig) {
  userConfig = (0, _extend2.default)(true, {
    container: container,
    modules: {
      clipboard: true,
      keyboard: true,
      history: true
    }
  }, userConfig);
  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
    userConfig.theme = _theme2.default;
  } else {
    userConfig.theme = Quill.import('themes/' + userConfig.theme);
    if (userConfig.theme == null) {
      throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
    }
  }
  var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
  [themeConfig, userConfig].forEach(function (config) {
    config.modules = config.modules || {};
    Object.keys(config.modules).forEach(function (module) {
      if (config.modules[module] === true) {
        config.modules[module] = {};
      }
    });
  });
  var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
  var moduleConfig = moduleNames.reduce(function (config, name) {
    var moduleClass = Quill.import('modules/' + name);
    if (moduleClass == null) {
      debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
    } else {
      config[name] = moduleClass.DEFAULTS || {};
    }
    return config;
  }, {});
  // Special case toolbar shorthand
  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
    userConfig.modules.toolbar = {
      container: userConfig.modules.toolbar
    };
  }
  userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
  ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
    if (typeof userConfig[key] === 'string') {
      userConfig[key] = document.querySelector(userConfig[key]);
    }
  });
  userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
    if (userConfig.modules[name]) {
      config[name] = userConfig.modules[name];
    }
    return config;
  }, {});
  return userConfig;
}

// Handle selection preservation and TEXT_CHANGE emission
// common to modification APIs
function modify(modifier, source, index, shift) {
  if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
    return new _quillDelta2.default();
  }
  var range = index == null ? null : this.getSelection();
  var oldDelta = this.editor.delta;
  var change = modifier();
  if (range != null) {
    if (index === true) index = range.index;
    if (shift == null) {
      range = shiftRange(range, change, source);
    } else if (shift !== 0) {
      range = shiftRange(range, index, shift, source);
    }
    this.setSelection(range, _emitter4.default.sources.SILENT);
  }
  if (change.length() > 0) {
    var _emitter;

    var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
    if (source !== _emitter4.default.sources.SILENT) {
      var _emitter2;

      (_emitter2 = this.emitter).emit.apply(_emitter2, args);
    }
  }
  return change;
}

function overload(index, length, name, value, source) {
  var formats = {};
  if (typeof index.index === 'number' && typeof index.length === 'number') {
    // Allow for throwaway end (used by insertText/insertEmbed)
    if (typeof length !== 'number') {
      source = value, value = name, name = length, length = index.length, index = index.index;
    } else {
      length = index.length, index = index.index;
    }
  } else if (typeof length !== 'number') {
    source = value, value = name, name = length, length = 0;
  }
  // Handle format being object, two format name/value strings or excluded
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    formats = name;
    source = value;
  } else if (typeof name === 'string') {
    if (value != null) {
      formats[name] = value;
    } else {
      source = name;
    }
  }
  // Handle optional source
  source = source || _emitter4.default.sources.API;
  return [index, length, formats, source];
}

function shiftRange(range, index, length, source) {
  if (range == null) return null;
  var start = void 0,
      end = void 0;
  if (index instanceof _quillDelta2.default) {
    var _map = [range.index, range.index + range.length].map(function (pos) {
      return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
    });

    var _map2 = _slicedToArray(_map, 2);

    start = _map2[0];
    end = _map2[1];
  } else {
    var _map3 = [range.index, range.index + range.length].map(function (pos) {
      if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;
      if (length >= 0) {
        return pos + length;
      } else {
        return Math.max(index, pos + length);
      }
    });

    var _map4 = _slicedToArray(_map3, 2);

    start = _map4[0];
    end = _map4[1];
  }
  return new _selection.Range(start, end - start);
}

exports.expandConfig = expandConfig;
exports.overload = overload;
exports.default = Quill;

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_290737__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _text = __nested_webpack_require_290737__(7);

var _text2 = _interopRequireDefault(_text);

var _parchment = __nested_webpack_require_290737__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Inline = function (_Parchment$Inline) {
  _inherits(Inline, _Parchment$Inline);

  function Inline() {
    _classCallCheck(this, Inline);

    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
  }

  _createClass(Inline, [{
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
        var blot = this.isolate(index, length);
        if (value) {
          blot.wrap(name, value);
        }
      } else {
        _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
      if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
        var parent = this.parent.isolate(this.offset(), this.length());
        this.moveChildren(parent);
        parent.wrap(this);
      }
    }
  }], [{
    key: 'compare',
    value: function compare(self, other) {
      var selfIndex = Inline.order.indexOf(self);
      var otherIndex = Inline.order.indexOf(other);
      if (selfIndex >= 0 || otherIndex >= 0) {
        return selfIndex - otherIndex;
      } else if (self === other) {
        return 0;
      } else if (self < other) {
        return -1;
      } else {
        return 1;
      }
    }
  }]);

  return Inline;
}(_parchment2.default.Inline);

Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
// Lower index means deeper in the DOM tree, since not found (-1) is for embeds
Inline.order = ['cursor', 'inline', // Must be lower
'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
];

exports.default = Inline;

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_295144__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __nested_webpack_require_295144__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextBlot = function (_Parchment$Text) {
  _inherits(TextBlot, _Parchment$Text);

  function TextBlot() {
    _classCallCheck(this, TextBlot);

    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
  }

  return TextBlot;
}(_parchment2.default.Text);

exports.default = TextBlot;

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_296728__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventemitter = __nested_webpack_require_296728__(54);

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _logger = __nested_webpack_require_296728__(10);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:events');

var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];

EVENTS.forEach(function (eventName) {
  document.addEventListener(eventName, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
      // TODO use WeakMap
      if (node.__quill && node.__quill.emitter) {
        var _node$__quill$emitter;

        (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
      }
    });
  });
});

var Emitter = function (_EventEmitter) {
  _inherits(Emitter, _EventEmitter);

  function Emitter() {
    _classCallCheck(this, Emitter);

    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));

    _this.listeners = {};
    _this.on('error', debug.error);
    return _this;
  }

  _createClass(Emitter, [{
    key: 'emit',
    value: function emit() {
      debug.log.apply(debug, arguments);
      _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
    }
  }, {
    key: 'handleDOM',
    value: function handleDOM(event) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (this.listeners[event.type] || []).forEach(function (_ref) {
        var node = _ref.node,
            handler = _ref.handler;

        if (event.target === node || node.contains(event.target)) {
          handler.apply(undefined, [event].concat(args));
        }
      });
    }
  }, {
    key: 'listenDOM',
    value: function listenDOM(eventName, node, handler) {
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.listeners[eventName].push({ node: node, handler: handler });
    }
  }]);

  return Emitter;
}(_eventemitter2.default);

Emitter.events = {
  EDITOR_CHANGE: 'editor-change',
  SCROLL_BEFORE_UPDATE: 'scroll-before-update',
  SCROLL_OPTIMIZE: 'scroll-optimize',
  SCROLL_UPDATE: 'scroll-update',
  SELECTION_CHANGE: 'selection-change',
  TEXT_CHANGE: 'text-change'
};
Emitter.sources = {
  API: 'api',
  SILENT: 'silent',
  USER: 'user'
};

exports.default = Emitter;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Module = function Module(quill) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _classCallCheck(this, Module);

  this.quill = quill;
  this.options = options;
};

Module.DEFAULTS = {};

exports.default = Module;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
var levels = ['error', 'warn', 'log', 'info'];
var level = 'warn';

function debug(method) {
  if (levels.indexOf(method) <= levels.indexOf(level)) {
    var _console;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console
  }
}

function namespace(ns) {
  return levels.reduce(function (logger, method) {
    logger[method] = debug.bind(console, method, ns);
    return logger;
  }, {});
}

debug.level = namespace.level = function (newLevel) {
  level = newLevel;
};

exports.default = namespace;

/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_302946__) {

var pSlice = Array.prototype.slice;
var objectKeys = __nested_webpack_require_302946__(52);
var isArguments = __nested_webpack_require_302946__(53);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_306066__) {

Object.defineProperty(exports, "__esModule", { value: true });
var Registry = __nested_webpack_require_306066__(1);
var Attributor = /** @class */ (function () {
    function Attributor(attrName, keyName, options) {
        if (options === void 0) { options = {}; }
        this.attrName = attrName;
        this.keyName = keyName;
        var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
        if (options.scope != null) {
            // Ignore type bits, force attribute bit
            this.scope = (options.scope & Registry.Scope.LEVEL) | attributeBit;
        }
        else {
            this.scope = Registry.Scope.ATTRIBUTE;
        }
        if (options.whitelist != null)
            this.whitelist = options.whitelist;
    }
    Attributor.keys = function (node) {
        return [].map.call(node.attributes, function (item) {
            return item.name;
        });
    };
    Attributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        node.setAttribute(this.keyName, value);
        return true;
    };
    Attributor.prototype.canAdd = function (node, value) {
        var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
        if (match == null)
            return false;
        if (this.whitelist == null)
            return true;
        if (typeof value === 'string') {
            return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
        }
        else {
            return this.whitelist.indexOf(value) > -1;
        }
    };
    Attributor.prototype.remove = function (node) {
        node.removeAttribute(this.keyName);
    };
    Attributor.prototype.value = function (node) {
        var value = node.getAttribute(this.keyName);
        if (this.canAdd(node, value) && value) {
            return value;
        }
        return '';
    };
    return Attributor;
}());
exports.default = Attributor;


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_308098__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Code = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _quillDelta = __nested_webpack_require_308098__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __nested_webpack_require_308098__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __nested_webpack_require_308098__(4);

var _block2 = _interopRequireDefault(_block);

var _inline = __nested_webpack_require_308098__(6);

var _inline2 = _interopRequireDefault(_inline);

var _text = __nested_webpack_require_308098__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Code = function (_Inline) {
  _inherits(Code, _Inline);

  function Code() {
    _classCallCheck(this, Code);

    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
  }

  return Code;
}(_inline2.default);

Code.blotName = 'code';
Code.tagName = 'CODE';

var CodeBlock = function (_Block) {
  _inherits(CodeBlock, _Block);

  function CodeBlock() {
    _classCallCheck(this, CodeBlock);

    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
  }

  _createClass(CodeBlock, [{
    key: 'delta',
    value: function delta() {
      var _this3 = this;

      var text = this.domNode.textContent;
      if (text.endsWith('\n')) {
        // Should always be true
        text = text.slice(0, -1);
      }
      return text.split('\n').reduce(function (delta, frag) {
        return delta.insert(frag).insert('\n', _this3.formats());
      }, new _quillDelta2.default());
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      if (name === this.statics.blotName && value) return;

      var _descendant = this.descendant(_text2.default, this.length() - 1),
          _descendant2 = _slicedToArray(_descendant, 1),
          text = _descendant2[0];

      if (text != null) {
        text.deleteAt(text.length() - 1, 1);
      }
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, name, value) {
      if (length === 0) return;
      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
        return;
      }
      var nextNewline = this.newlineIndex(index);
      if (nextNewline < 0 || nextNewline >= index + length) return;
      var prevNewline = this.newlineIndex(index, true) + 1;
      var isolateLength = nextNewline - prevNewline + 1;
      var blot = this.isolate(prevNewline, isolateLength);
      var next = blot.next;
      blot.format(name, value);
      if (next instanceof CodeBlock) {
        next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
      }
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null) return;

      var _descendant3 = this.descendant(_text2.default, index),
          _descendant4 = _slicedToArray(_descendant3, 2),
          text = _descendant4[0],
          offset = _descendant4[1];

      text.insertAt(offset, value);
    }
  }, {
    key: 'length',
    value: function length() {
      var length = this.domNode.textContent.length;
      if (!this.domNode.textContent.endsWith('\n')) {
        return length + 1;
      }
      return length;
    }
  }, {
    key: 'newlineIndex',
    value: function newlineIndex(searchIndex) {
      var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!reverse) {
        var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
        return offset > -1 ? searchIndex + offset : -1;
      } else {
        return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      if (!this.domNode.textContent.endsWith('\n')) {
        this.appendChild(_parchment2.default.create('text', '\n'));
      }
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
      var next = this.next;
      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
        next.optimize(context);
        next.moveChildren(this);
        next.remove();
      }
    }
  }, {
    key: 'replace',
    value: function replace(target) {
      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
      [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
        var blot = _parchment2.default.find(node);
        if (blot == null) {
          node.parentNode.removeChild(node);
        } else if (blot instanceof _parchment2.default.Embed) {
          blot.remove();
        } else {
          blot.unwrap();
        }
      });
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
      domNode.setAttribute('spellcheck', false);
      return domNode;
    }
  }, {
    key: 'formats',
    value: function formats() {
      return true;
    }
  }]);

  return CodeBlock;
}(_block2.default);

CodeBlock.blotName = 'code-block';
CodeBlock.tagName = 'PRE';
CodeBlock.TAB = '  ';

exports.Code = Code;
exports.default = CodeBlock;

/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_316504__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _quillDelta = __nested_webpack_require_316504__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _op = __nested_webpack_require_316504__(20);

var _op2 = _interopRequireDefault(_op);

var _parchment = __nested_webpack_require_316504__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _code = __nested_webpack_require_316504__(13);

var _code2 = _interopRequireDefault(_code);

var _cursor = __nested_webpack_require_316504__(24);

var _cursor2 = _interopRequireDefault(_cursor);

var _block = __nested_webpack_require_316504__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __nested_webpack_require_316504__(16);

var _break2 = _interopRequireDefault(_break);

var _clone = __nested_webpack_require_316504__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __nested_webpack_require_316504__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _extend = __nested_webpack_require_316504__(3);

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ASCII = /^[ -~]*$/;

var Editor = function () {
  function Editor(scroll) {
    _classCallCheck(this, Editor);

    this.scroll = scroll;
    this.delta = this.getDelta();
  }

  _createClass(Editor, [{
    key: 'applyDelta',
    value: function applyDelta(delta) {
      var _this = this;

      var consumeNextNewline = false;
      this.scroll.update();
      var scrollLength = this.scroll.length();
      this.scroll.batchStart();
      delta = normalizeDelta(delta);
      delta.reduce(function (index, op) {
        var length = op.retain || op.delete || op.insert.length || 1;
        var attributes = op.attributes || {};
        if (op.insert != null) {
          if (typeof op.insert === 'string') {
            var text = op.insert;
            if (text.endsWith('\n') && consumeNextNewline) {
              consumeNextNewline = false;
              text = text.slice(0, -1);
            }
            if (index >= scrollLength && !text.endsWith('\n')) {
              consumeNextNewline = true;
            }
            _this.scroll.insertAt(index, text);

            var _scroll$line = _this.scroll.line(index),
                _scroll$line2 = _slicedToArray(_scroll$line, 2),
                line = _scroll$line2[0],
                offset = _scroll$line2[1];

            var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
            if (line instanceof _block2.default) {
              var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                  _line$descendant2 = _slicedToArray(_line$descendant, 1),
                  leaf = _line$descendant2[0];

              formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
            }
            attributes = _op2.default.attributes.diff(formats, attributes) || {};
          } else if (_typeof(op.insert) === 'object') {
            var key = Object.keys(op.insert)[0]; // There should only be one key
            if (key == null) return index;
            _this.scroll.insertAt(index, key, op.insert[key]);
          }
          scrollLength += length;
        }
        Object.keys(attributes).forEach(function (name) {
          _this.scroll.formatAt(index, length, name, attributes[name]);
        });
        return index + length;
      }, 0);
      delta.reduce(function (index, op) {
        if (typeof op.delete === 'number') {
          _this.scroll.deleteAt(index, op.delete);
          return index;
        }
        return index + (op.retain || op.insert.length || 1);
      }, 0);
      this.scroll.batchEnd();
      return this.update(delta);
    }
  }, {
    key: 'deleteText',
    value: function deleteText(index, length) {
      this.scroll.deleteAt(index, length);
      return this.update(new _quillDelta2.default().retain(index).delete(length));
    }
  }, {
    key: 'formatLine',
    value: function formatLine(index, length) {
      var _this2 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this.scroll.update();
      Object.keys(formats).forEach(function (format) {
        if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;
        var lines = _this2.scroll.lines(index, Math.max(length, 1));
        var lengthRemaining = length;
        lines.forEach(function (line) {
          var lineLength = line.length();
          if (!(line instanceof _code2.default)) {
            line.format(format, formats[format]);
          } else {
            var codeIndex = index - line.offset(_this2.scroll);
            var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
            line.formatAt(codeIndex, codeLength, format, formats[format]);
          }
          lengthRemaining -= lineLength;
        });
      });
      this.scroll.optimize();
      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'formatText',
    value: function formatText(index, length) {
      var _this3 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      Object.keys(formats).forEach(function (format) {
        _this3.scroll.formatAt(index, length, format, formats[format]);
      });
      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'getContents',
    value: function getContents(index, length) {
      return this.delta.slice(index, index + length);
    }
  }, {
    key: 'getDelta',
    value: function getDelta() {
      return this.scroll.lines().reduce(function (delta, line) {
        return delta.concat(line.delta());
      }, new _quillDelta2.default());
    }
  }, {
    key: 'getFormat',
    value: function getFormat(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var lines = [],
          leaves = [];
      if (length === 0) {
        this.scroll.path(index).forEach(function (path) {
          var _path = _slicedToArray(path, 1),
              blot = _path[0];

          if (blot instanceof _block2.default) {
            lines.push(blot);
          } else if (blot instanceof _parchment2.default.Leaf) {
            leaves.push(blot);
          }
        });
      } else {
        lines = this.scroll.lines(index, length);
        leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
      }
      var formatsArr = [lines, leaves].map(function (blots) {
        if (blots.length === 0) return {};
        var formats = (0, _block.bubbleFormats)(blots.shift());
        while (Object.keys(formats).length > 0) {
          var blot = blots.shift();
          if (blot == null) return formats;
          formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
        }
        return formats;
      });
      return _extend2.default.apply(_extend2.default, formatsArr);
    }
  }, {
    key: 'getText',
    value: function getText(index, length) {
      return this.getContents(index, length).filter(function (op) {
        return typeof op.insert === 'string';
      }).map(function (op) {
        return op.insert;
      }).join('');
    }
  }, {
    key: 'insertEmbed',
    value: function insertEmbed(index, embed, value) {
      this.scroll.insertAt(index, embed, value);
      return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
    }
  }, {
    key: 'insertText',
    value: function insertText(index, text) {
      var _this4 = this;

      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      this.scroll.insertAt(index, text);
      Object.keys(formats).forEach(function (format) {
        _this4.scroll.formatAt(index, text.length, format, formats[format]);
      });
      return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
    }
  }, {
    key: 'isBlank',
    value: function isBlank() {
      if (this.scroll.children.length == 0) return true;
      if (this.scroll.children.length > 1) return false;
      var block = this.scroll.children.head;
      if (block.statics.blotName !== _block2.default.blotName) return false;
      if (block.children.length > 1) return false;
      return block.children.head instanceof _break2.default;
    }
  }, {
    key: 'removeFormat',
    value: function removeFormat(index, length) {
      var text = this.getText(index, length);

      var _scroll$line3 = this.scroll.line(index + length),
          _scroll$line4 = _slicedToArray(_scroll$line3, 2),
          line = _scroll$line4[0],
          offset = _scroll$line4[1];

      var suffixLength = 0,
          suffix = new _quillDelta2.default();
      if (line != null) {
        if (!(line instanceof _code2.default)) {
          suffixLength = line.length() - offset;
        } else {
          suffixLength = line.newlineIndex(offset) - offset + 1;
        }
        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
      }
      var contents = this.getContents(index, length + suffixLength);
      var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
      var delta = new _quillDelta2.default().retain(index).concat(diff);
      return this.applyDelta(delta);
    }
  }, {
    key: 'update',
    value: function update(change) {
      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      var oldDelta = this.delta;
      if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
        // Optimization for character changes
        var textBlot = _parchment2.default.find(mutations[0].target);
        var formats = (0, _block.bubbleFormats)(textBlot);
        var index = textBlot.offset(this.scroll);
        var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
        var oldText = new _quillDelta2.default().insert(oldValue);
        var newText = new _quillDelta2.default().insert(textBlot.value());
        var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
        change = diffDelta.reduce(function (delta, op) {
          if (op.insert) {
            return delta.insert(op.insert, formats);
          } else {
            return delta.push(op);
          }
        }, new _quillDelta2.default());
        this.delta = oldDelta.compose(change);
      } else {
        this.delta = this.getDelta();
        if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
          change = oldDelta.diff(this.delta, cursorIndex);
        }
      }
      return change;
    }
  }]);

  return Editor;
}();

function combineFormats(formats, combined) {
  return Object.keys(combined).reduce(function (merged, name) {
    if (formats[name] == null) return merged;
    if (combined[name] === formats[name]) {
      merged[name] = combined[name];
    } else if (Array.isArray(combined[name])) {
      if (combined[name].indexOf(formats[name]) < 0) {
        merged[name] = combined[name].concat([formats[name]]);
      }
    } else {
      merged[name] = [combined[name], formats[name]];
    }
    return merged;
  }, {});
}

function normalizeDelta(delta) {
  return delta.reduce(function (delta, op) {
    if (op.insert === 1) {
      var attributes = (0, _clone2.default)(op.attributes);
      delete attributes['image'];
      return delta.insert({ image: op.attributes.image }, attributes);
    }
    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
      op = (0, _clone2.default)(op);
      if (op.attributes.list) {
        op.attributes.list = 'ordered';
      } else {
        op.attributes.list = 'bullet';
        delete op.attributes.bullet;
      }
    }
    if (typeof op.insert === 'string') {
      var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      return delta.insert(text, op.attributes);
    }
    return delta.push(op);
  }, new _quillDelta2.default());
}

exports.default = Editor;

/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_330905__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Range = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __nested_webpack_require_330905__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _clone = __nested_webpack_require_330905__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __nested_webpack_require_330905__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _emitter3 = __nested_webpack_require_330905__(8);

var _emitter4 = _interopRequireDefault(_emitter3);

var _logger = __nested_webpack_require_330905__(10);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _logger2.default)('quill:selection');

var Range = function Range(index) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  _classCallCheck(this, Range);

  this.index = index;
  this.length = length;
};

var Selection = function () {
  function Selection(scroll, emitter) {
    var _this = this;

    _classCallCheck(this, Selection);

    this.emitter = emitter;
    this.scroll = scroll;
    this.composing = false;
    this.mouseDown = false;
    this.root = this.scroll.domNode;
    this.cursor = _parchment2.default.create('cursor', this);
    // savedRange is last non-null range
    this.lastRange = this.savedRange = new Range(0, 0);
    this.handleComposition();
    this.handleDragging();
    this.emitter.listenDOM('selectionchange', document, function () {
      if (!_this.mouseDown) {
        setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
      }
    });
    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
      if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
        _this.update(_emitter4.default.sources.SILENT);
      }
    });
    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
      if (!_this.hasFocus()) return;
      var native = _this.getNativeRange();
      if (native == null) return;
      if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
      // TODO unclear if this has negative side effects
      _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
        try {
          _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
        } catch (ignored) {}
      });
    });
    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
      if (context.range) {
        var _context$range = context.range,
            startNode = _context$range.startNode,
            startOffset = _context$range.startOffset,
            endNode = _context$range.endNode,
            endOffset = _context$range.endOffset;

        _this.setNativeRange(startNode, startOffset, endNode, endOffset);
      }
    });
    this.update(_emitter4.default.sources.SILENT);
  }

  _createClass(Selection, [{
    key: 'handleComposition',
    value: function handleComposition() {
      var _this2 = this;

      this.root.addEventListener('compositionstart', function () {
        _this2.composing = true;
      });
      this.root.addEventListener('compositionend', function () {
        _this2.composing = false;
        if (_this2.cursor.parent) {
          var range = _this2.cursor.restore();
          if (!range) return;
          setTimeout(function () {
            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }, 1);
        }
      });
    }
  }, {
    key: 'handleDragging',
    value: function handleDragging() {
      var _this3 = this;

      this.emitter.listenDOM('mousedown', document.body, function () {
        _this3.mouseDown = true;
      });
      this.emitter.listenDOM('mouseup', document.body, function () {
        _this3.mouseDown = false;
        _this3.update(_emitter4.default.sources.USER);
      });
    }
  }, {
    key: 'focus',
    value: function focus() {
      if (this.hasFocus()) return;
      this.root.focus();
      this.setRange(this.savedRange);
    }
  }, {
    key: 'format',
    value: function format(_format, value) {
      if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
      this.scroll.update();
      var nativeRange = this.getNativeRange();
      if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
      if (nativeRange.start.node !== this.cursor.textNode) {
        var blot = _parchment2.default.find(nativeRange.start.node, false);
        if (blot == null) return;
        // TODO Give blot ability to not split
        if (blot instanceof _parchment2.default.Leaf) {
          var after = blot.split(nativeRange.start.offset);
          blot.parent.insertBefore(this.cursor, after);
        } else {
          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
        }
        this.cursor.attach();
      }
      this.cursor.format(_format, value);
      this.scroll.optimize();
      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
      this.update();
    }
  }, {
    key: 'getBounds',
    value: function getBounds(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var scrollLength = this.scroll.length();
      index = Math.min(index, scrollLength - 1);
      length = Math.min(index + length, scrollLength - 1) - index;
      var node = void 0,
          _scroll$leaf = this.scroll.leaf(index),
          _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
          leaf = _scroll$leaf2[0],
          offset = _scroll$leaf2[1];
      if (leaf == null) return null;

      var _leaf$position = leaf.position(offset, true);

      var _leaf$position2 = _slicedToArray(_leaf$position, 2);

      node = _leaf$position2[0];
      offset = _leaf$position2[1];

      var range = document.createRange();
      if (length > 0) {
        range.setStart(node, offset);

        var _scroll$leaf3 = this.scroll.leaf(index + length);

        var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);

        leaf = _scroll$leaf4[0];
        offset = _scroll$leaf4[1];

        if (leaf == null) return null;

        var _leaf$position3 = leaf.position(offset, true);

        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);

        node = _leaf$position4[0];
        offset = _leaf$position4[1];

        range.setEnd(node, offset);
        return range.getBoundingClientRect();
      } else {
        var side = 'left';
        var rect = void 0;
        if (node instanceof Text) {
          if (offset < node.data.length) {
            range.setStart(node, offset);
            range.setEnd(node, offset + 1);
          } else {
            range.setStart(node, offset - 1);
            range.setEnd(node, offset);
            side = 'right';
          }
          rect = range.getBoundingClientRect();
        } else {
          rect = leaf.domNode.getBoundingClientRect();
          if (offset > 0) side = 'right';
        }
        return {
          bottom: rect.top + rect.height,
          height: rect.height,
          left: rect[side],
          right: rect[side],
          top: rect.top,
          width: 0
        };
      }
    }
  }, {
    key: 'getNativeRange',
    value: function getNativeRange() {
      var selection = document.getSelection();
      if (selection == null || selection.rangeCount <= 0) return null;
      var nativeRange = selection.getRangeAt(0);
      if (nativeRange == null) return null;
      var range = this.normalizeNative(nativeRange);
      debug.info('getNativeRange', range);
      return range;
    }
  }, {
    key: 'getRange',
    value: function getRange() {
      var normalized = this.getNativeRange();
      if (normalized == null) return [null, null];
      var range = this.normalizedToRange(normalized);
      return [range, normalized];
    }
  }, {
    key: 'hasFocus',
    value: function hasFocus() {
      return document.activeElement === this.root;
    }
  }, {
    key: 'normalizedToRange',
    value: function normalizedToRange(range) {
      var _this4 = this;

      var positions = [[range.start.node, range.start.offset]];
      if (!range.native.collapsed) {
        positions.push([range.end.node, range.end.offset]);
      }
      var indexes = positions.map(function (position) {
        var _position = _slicedToArray(position, 2),
            node = _position[0],
            offset = _position[1];

        var blot = _parchment2.default.find(node, true);
        var index = blot.offset(_this4.scroll);
        if (offset === 0) {
          return index;
        } else if (blot instanceof _parchment2.default.Container) {
          return index + blot.length();
        } else {
          return index + blot.index(node, offset);
        }
      });
      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
      return new Range(start, end - start);
    }
  }, {
    key: 'normalizeNative',
    value: function normalizeNative(nativeRange) {
      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
        return null;
      }
      var range = {
        start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
        end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
        native: nativeRange
      };
      [range.start, range.end].forEach(function (position) {
        var node = position.node,
            offset = position.offset;
        while (!(node instanceof Text) && node.childNodes.length > 0) {
          if (node.childNodes.length > offset) {
            node = node.childNodes[offset];
            offset = 0;
          } else if (node.childNodes.length === offset) {
            node = node.lastChild;
            offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
          } else {
            break;
          }
        }
        position.node = node, position.offset = offset;
      });
      return range;
    }
  }, {
    key: 'rangeToNative',
    value: function rangeToNative(range) {
      var _this5 = this;

      var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
      var args = [];
      var scrollLength = this.scroll.length();
      indexes.forEach(function (index, i) {
        index = Math.min(scrollLength - 1, index);
        var node = void 0,
            _scroll$leaf5 = _this5.scroll.leaf(index),
            _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
            leaf = _scroll$leaf6[0],
            offset = _scroll$leaf6[1];
        var _leaf$position5 = leaf.position(offset, i !== 0);

        var _leaf$position6 = _slicedToArray(_leaf$position5, 2);

        node = _leaf$position6[0];
        offset = _leaf$position6[1];

        args.push(node, offset);
      });
      if (args.length < 2) {
        args = args.concat(args);
      }
      return args;
    }
  }, {
    key: 'scrollIntoView',
    value: function scrollIntoView(scrollingContainer) {
      var range = this.lastRange;
      if (range == null) return;
      var bounds = this.getBounds(range.index, range.length);
      if (bounds == null) return;
      var limit = this.scroll.length() - 1;

      var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
          _scroll$line2 = _slicedToArray(_scroll$line, 1),
          first = _scroll$line2[0];

      var last = first;
      if (range.length > 0) {
        var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));

        var _scroll$line4 = _slicedToArray(_scroll$line3, 1);

        last = _scroll$line4[0];
      }
      if (first == null || last == null) return;
      var scrollBounds = scrollingContainer.getBoundingClientRect();
      if (bounds.top < scrollBounds.top) {
        scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
      } else if (bounds.bottom > scrollBounds.bottom) {
        scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
      }
    }
  }, {
    key: 'setNativeRange',
    value: function setNativeRange(startNode, startOffset) {
      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
        return;
      }
      var selection = document.getSelection();
      if (selection == null) return;
      if (startNode != null) {
        if (!this.hasFocus()) this.root.focus();
        var native = (this.getNativeRange() || {}).native;
        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {

          if (startNode.tagName == "BR") {
            startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
            startNode = startNode.parentNode;
          }
          if (endNode.tagName == "BR") {
            endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
            endNode = endNode.parentNode;
          }
          var range = document.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      } else {
        selection.removeAllRanges();
        this.root.blur();
        document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
      }
    }
  }, {
    key: 'setRange',
    value: function setRange(range) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

      if (typeof force === 'string') {
        source = force;
        force = false;
      }
      debug.info('setRange', range);
      if (range != null) {
        var args = this.rangeToNative(range);
        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
      } else {
        this.setNativeRange(null);
      }
      this.update(source);
    }
  }, {
    key: 'update',
    value: function update() {
      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

      var oldRange = this.lastRange;

      var _getRange = this.getRange(),
          _getRange2 = _slicedToArray(_getRange, 2),
          lastRange = _getRange2[0],
          nativeRange = _getRange2[1];

      this.lastRange = lastRange;
      if (this.lastRange != null) {
        this.savedRange = this.lastRange;
      }
      if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
        var _emitter;

        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
          this.cursor.restore();
        }
        var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
        if (source !== _emitter4.default.sources.SILENT) {
          var _emitter2;

          (_emitter2 = this.emitter).emit.apply(_emitter2, args);
        }
      }
    }
  }]);

  return Selection;
}();

function contains(parent, descendant) {
  try {
    // Firefox inserts inaccessible nodes around video elements
    descendant.parentNode;
  } catch (e) {
    return false;
  }
  // IE11 has bug with Text nodes
  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
  if (descendant instanceof Text) {
    descendant = descendant.parentNode;
  }
  return parent.contains(descendant);
}

exports.Range = Range;
exports.default = Selection;

/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_349110__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_349110__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Break = function (_Parchment$Embed) {
  _inherits(Break, _Parchment$Embed);

  function Break() {
    _classCallCheck(this, Break);

    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
  }

  _createClass(Break, [{
    key: 'insertInto',
    value: function insertInto(parent, ref) {
      if (parent.children.length === 0) {
        _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
      } else {
        this.remove();
      }
    }
  }, {
    key: 'length',
    value: function length() {
      return 0;
    }
  }, {
    key: 'value',
    value: function value() {
      return '';
    }
  }], [{
    key: 'value',
    value: function value() {
      return undefined;
    }
  }]);

  return Break;
}(_parchment2.default.Embed);

Break.blotName = 'break';
Break.tagName = 'BR';

exports.default = Break;

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_352349__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var linked_list_1 = __nested_webpack_require_352349__(44);
var shadow_1 = __nested_webpack_require_352349__(30);
var Registry = __nested_webpack_require_352349__(1);
var ContainerBlot = /** @class */ (function (_super) {
    __extends(ContainerBlot, _super);
    function ContainerBlot(domNode) {
        var _this = _super.call(this, domNode) || this;
        _this.build();
        return _this;
    }
    ContainerBlot.prototype.appendChild = function (other) {
        this.insertBefore(other);
    };
    ContainerBlot.prototype.attach = function () {
        _super.prototype.attach.call(this);
        this.children.forEach(function (child) {
            child.attach();
        });
    };
    ContainerBlot.prototype.build = function () {
        var _this = this;
        this.children = new linked_list_1.default();
        // Need to be reversed for if DOM nodes already in order
        [].slice
            .call(this.domNode.childNodes)
            .reverse()
            .forEach(function (node) {
            try {
                var child = makeBlot(node);
                _this.insertBefore(child, _this.children.head || undefined);
            }
            catch (err) {
                if (err instanceof Registry.ParchmentError)
                    return;
                else
                    throw err;
            }
        });
    };
    ContainerBlot.prototype.deleteAt = function (index, length) {
        if (index === 0 && length === this.length()) {
            return this.remove();
        }
        this.children.forEachAt(index, length, function (child, offset, length) {
            child.deleteAt(offset, length);
        });
    };
    ContainerBlot.prototype.descendant = function (criteria, index) {
        var _a = this.children.find(index), child = _a[0], offset = _a[1];
        if ((criteria.blotName == null && criteria(child)) ||
            (criteria.blotName != null && child instanceof criteria)) {
            return [child, offset];
        }
        else if (child instanceof ContainerBlot) {
            return child.descendant(criteria, offset);
        }
        else {
            return [null, -1];
        }
    };
    ContainerBlot.prototype.descendants = function (criteria, index, length) {
        if (index === void 0) { index = 0; }
        if (length === void 0) { length = Number.MAX_VALUE; }
        var descendants = [];
        var lengthLeft = length;
        this.children.forEachAt(index, length, function (child, index, length) {
            if ((criteria.blotName == null && criteria(child)) ||
                (criteria.blotName != null && child instanceof criteria)) {
                descendants.push(child);
            }
            if (child instanceof ContainerBlot) {
                descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
            }
            lengthLeft -= length;
        });
        return descendants;
    };
    ContainerBlot.prototype.detach = function () {
        this.children.forEach(function (child) {
            child.detach();
        });
        _super.prototype.detach.call(this);
    };
    ContainerBlot.prototype.formatAt = function (index, length, name, value) {
        this.children.forEachAt(index, length, function (child, offset, length) {
            child.formatAt(offset, length, name, value);
        });
    };
    ContainerBlot.prototype.insertAt = function (index, value, def) {
        var _a = this.children.find(index), child = _a[0], offset = _a[1];
        if (child) {
            child.insertAt(offset, value, def);
        }
        else {
            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
            this.appendChild(blot);
        }
    };
    ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
        if (this.statics.allowedChildren != null &&
            !this.statics.allowedChildren.some(function (child) {
                return childBlot instanceof child;
            })) {
            throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
        }
        childBlot.insertInto(this, refBlot);
    };
    ContainerBlot.prototype.length = function () {
        return this.children.reduce(function (memo, child) {
            return memo + child.length();
        }, 0);
    };
    ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
        this.children.forEach(function (child) {
            targetParent.insertBefore(child, refNode);
        });
    };
    ContainerBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        if (this.children.length === 0) {
            if (this.statics.defaultChild != null) {
                var child = Registry.create(this.statics.defaultChild);
                this.appendChild(child);
                child.optimize(context);
            }
            else {
                this.remove();
            }
        }
    };
    ContainerBlot.prototype.path = function (index, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];
        var position = [[this, index]];
        if (child instanceof ContainerBlot) {
            return position.concat(child.path(offset, inclusive));
        }
        else if (child != null) {
            position.push([child, offset]);
        }
        return position;
    };
    ContainerBlot.prototype.removeChild = function (child) {
        this.children.remove(child);
    };
    ContainerBlot.prototype.replace = function (target) {
        if (target instanceof ContainerBlot) {
            target.moveChildren(this);
        }
        _super.prototype.replace.call(this, target);
    };
    ContainerBlot.prototype.split = function (index, force) {
        if (force === void 0) { force = false; }
        if (!force) {
            if (index === 0)
                return this;
            if (index === this.length())
                return this.next;
        }
        var after = this.clone();
        this.parent.insertBefore(after, this.next);
        this.children.forEachAt(index, this.length(), function (child, offset, length) {
            child = child.split(offset, force);
            after.appendChild(child);
        });
        return after;
    };
    ContainerBlot.prototype.unwrap = function () {
        this.moveChildren(this.parent, this.next);
        this.remove();
    };
    ContainerBlot.prototype.update = function (mutations, context) {
        var _this = this;
        var addedNodes = [];
        var removedNodes = [];
        mutations.forEach(function (mutation) {
            if (mutation.target === _this.domNode && mutation.type === 'childList') {
                addedNodes.push.apply(addedNodes, mutation.addedNodes);
                removedNodes.push.apply(removedNodes, mutation.removedNodes);
            }
        });
        removedNodes.forEach(function (node) {
            // Check node has actually been removed
            // One exception is Chrome does not immediately remove IFRAMEs
            // from DOM but MutationRecord is correct in its reported removal
            if (node.parentNode != null &&
                // @ts-ignore
                node.tagName !== 'IFRAME' &&
                document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return;
            }
            var blot = Registry.find(node);
            if (blot == null)
                return;
            if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                blot.detach();
            }
        });
        addedNodes
            .filter(function (node) {
            return node.parentNode == _this.domNode;
        })
            .sort(function (a, b) {
            if (a === b)
                return 0;
            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                return 1;
            }
            return -1;
        })
            .forEach(function (node) {
            var refBlot = null;
            if (node.nextSibling != null) {
                refBlot = Registry.find(node.nextSibling);
            }
            var blot = makeBlot(node);
            if (blot.next != refBlot || blot.next == null) {
                if (blot.parent != null) {
                    blot.parent.removeChild(_this);
                }
                _this.insertBefore(blot, refBlot || undefined);
            }
        });
    };
    return ContainerBlot;
}(shadow_1.default));
function makeBlot(node) {
    var blot = Registry.find(node);
    if (blot == null) {
        try {
            blot = Registry.create(node);
        }
        catch (e) {
            blot = Registry.create(Registry.Scope.INLINE);
            [].slice.call(node.childNodes).forEach(function (child) {
                // @ts-ignore
                blot.domNode.appendChild(child);
            });
            if (node.parentNode) {
                node.parentNode.replaceChild(blot.domNode, node);
            }
            blot.attach();
        }
    }
    return blot;
}
exports.default = ContainerBlot;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_362260__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __nested_webpack_require_362260__(12);
var store_1 = __nested_webpack_require_362260__(31);
var container_1 = __nested_webpack_require_362260__(17);
var Registry = __nested_webpack_require_362260__(1);
var FormatBlot = /** @class */ (function (_super) {
    __extends(FormatBlot, _super);
    function FormatBlot(domNode) {
        var _this = _super.call(this, domNode) || this;
        _this.attributes = new store_1.default(_this.domNode);
        return _this;
    }
    FormatBlot.formats = function (domNode) {
        if (typeof this.tagName === 'string') {
            return true;
        }
        else if (Array.isArray(this.tagName)) {
            return domNode.tagName.toLowerCase();
        }
        return undefined;
    };
    FormatBlot.prototype.format = function (name, value) {
        var format = Registry.query(name);
        if (format instanceof attributor_1.default) {
            this.attributes.attribute(format, value);
        }
        else if (value) {
            if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                this.replaceWith(name, value);
            }
        }
    };
    FormatBlot.prototype.formats = function () {
        var formats = this.attributes.values();
        var format = this.statics.formats(this.domNode);
        if (format != null) {
            formats[this.statics.blotName] = format;
        }
        return formats;
    };
    FormatBlot.prototype.replaceWith = function (name, value) {
        var replacement = _super.prototype.replaceWith.call(this, name, value);
        this.attributes.copy(replacement);
        return replacement;
    };
    FormatBlot.prototype.update = function (mutations, context) {
        var _this = this;
        _super.prototype.update.call(this, mutations, context);
        if (mutations.some(function (mutation) {
            return mutation.target === _this.domNode && mutation.type === 'attributes';
        })) {
            this.attributes.build();
        }
    };
    FormatBlot.prototype.wrap = function (name, value) {
        var wrapper = _super.prototype.wrap.call(this, name, value);
        if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
            this.attributes.move(wrapper);
        }
        return wrapper;
    };
    return FormatBlot;
}(container_1.default));
exports.default = FormatBlot;


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_365268__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var shadow_1 = __nested_webpack_require_365268__(30);
var Registry = __nested_webpack_require_365268__(1);
var LeafBlot = /** @class */ (function (_super) {
    __extends(LeafBlot, _super);
    function LeafBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LeafBlot.value = function (domNode) {
        return true;
    };
    LeafBlot.prototype.index = function (node, offset) {
        if (this.domNode === node ||
            this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return Math.min(offset, 1);
        }
        return -1;
    };
    LeafBlot.prototype.position = function (index, inclusive) {
        var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
        if (index > 0)
            offset += 1;
        return [this.parent.domNode, offset];
    };
    LeafBlot.prototype.value = function () {
        var _a;
        return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
    };
    LeafBlot.scope = Registry.Scope.INLINE_BLOT;
    return LeafBlot;
}(shadow_1.default));
exports.default = LeafBlot;


/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_367040__) {

var equal = __nested_webpack_require_367040__(11);
var extend = __nested_webpack_require_367040__(3);


var lib = {
  attributes: {
    compose: function (a, b, keepNull) {
      if (typeof a !== 'object') a = {};
      if (typeof b !== 'object') b = {};
      var attributes = extend(true, {}, b);
      if (!keepNull) {
        attributes = Object.keys(attributes).reduce(function (copy, key) {
          if (attributes[key] != null) {
            copy[key] = attributes[key];
          }
          return copy;
        }, {});
      }
      for (var key in a) {
        if (a[key] !== undefined && b[key] === undefined) {
          attributes[key] = a[key];
        }
      }
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    diff: function(a, b) {
      if (typeof a !== 'object') a = {};
      if (typeof b !== 'object') b = {};
      var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
        if (!equal(a[key], b[key])) {
          attributes[key] = b[key] === undefined ? null : b[key];
        }
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    transform: function (a, b, priority) {
      if (typeof a !== 'object') return b;
      if (typeof b !== 'object') return undefined;
      if (!priority) return b;  // b simply overwrites us without priority
      var attributes = Object.keys(b).reduce(function (attributes, key) {
        if (a[key] === undefined) attributes[key] = b[key];  // null is a valid value
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    }
  },

  iterator: function (ops) {
    return new Iterator(ops);
  },

  length: function (op) {
    if (typeof op['delete'] === 'number') {
      return op['delete'];
    } else if (typeof op.retain === 'number') {
      return op.retain;
    } else {
      return typeof op.insert === 'string' ? op.insert.length : 1;
    }
  }
};


function Iterator(ops) {
  this.ops = ops;
  this.index = 0;
  this.offset = 0;
}
Iterator.prototype.hasNext = function () {
  return this.peekLength() < Infinity;
};

Iterator.prototype.next = function (length) {
  if (!length) length = Infinity;
  var nextOp = this.ops[this.index];
  if (nextOp) {
    var offset = this.offset;
    var opLength = lib.length(nextOp);
    if (length >= opLength - offset) {
      length = opLength - offset;
      this.index += 1;
      this.offset = 0;
    } else {
      this.offset += length;
    }
    if (typeof nextOp['delete'] === 'number') {
      return { 'delete': length };
    } else {
      var retOp = {};
      if (nextOp.attributes) {
        retOp.attributes = nextOp.attributes;
      }
      if (typeof nextOp.retain === 'number') {
        retOp.retain = length;
      } else if (typeof nextOp.insert === 'string') {
        retOp.insert = nextOp.insert.substr(offset, length);
      } else {
        // offset should === 0, length should === 1
        retOp.insert = nextOp.insert;
      }
      return retOp;
    }
  } else {
    return { retain: Infinity };
  }
};

Iterator.prototype.peek = function () {
  return this.ops[this.index];
};

Iterator.prototype.peekLength = function () {
  if (this.ops[this.index]) {
    // Should never return 0 if our index is being managed correctly
    return lib.length(this.ops[this.index]) - this.offset;
  } else {
    return Infinity;
  }
};

Iterator.prototype.peekType = function () {
  if (this.ops[this.index]) {
    if (typeof this.ops[this.index]['delete'] === 'number') {
      return 'delete';
    } else if (typeof this.ops[this.index].retain === 'number') {
      return 'retain';
    } else {
      return 'insert';
    }
  }
  return 'retain';
};

Iterator.prototype.rest = function () {
  if (!this.hasNext()) {
    return [];
  } else if (this.offset === 0) {
    return this.ops.slice(this.index);
  } else {
    var offset = this.offset;
    var index = this.index;
    var next = this.next();
    var rest = this.ops.slice(this.index);
    this.offset = offset;
    this.index = index;
    return [next].concat(rest);
  }
};


module.exports = lib;


/***/ }),
/* 21 */
/***/ (function(module, exports) {

var clone = (function() {

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_378624__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_378624__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _emitter = __nested_webpack_require_378624__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _block = __nested_webpack_require_378624__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __nested_webpack_require_378624__(16);

var _break2 = _interopRequireDefault(_break);

var _code = __nested_webpack_require_378624__(13);

var _code2 = _interopRequireDefault(_code);

var _container = __nested_webpack_require_378624__(25);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function isLine(blot) {
  return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
}

var Scroll = function (_Parchment$Scroll) {
  _inherits(Scroll, _Parchment$Scroll);

  function Scroll(domNode, config) {
    _classCallCheck(this, Scroll);

    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));

    _this.emitter = config.emitter;
    if (Array.isArray(config.whitelist)) {
      _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
        whitelist[format] = true;
        return whitelist;
      }, {});
    }
    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari
    _this.domNode.addEventListener('DOMNodeInserted', function () {});
    _this.optimize();
    _this.enable();
    return _this;
  }

  _createClass(Scroll, [{
    key: 'batchStart',
    value: function batchStart() {
      this.batch = true;
    }
  }, {
    key: 'batchEnd',
    value: function batchEnd() {
      this.batch = false;
      this.optimize();
    }
  }, {
    key: 'deleteAt',
    value: function deleteAt(index, length) {
      var _line = this.line(index),
          _line2 = _slicedToArray(_line, 2),
          first = _line2[0],
          offset = _line2[1];

      var _line3 = this.line(index + length),
          _line4 = _slicedToArray(_line3, 1),
          last = _line4[0];

      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
      if (last != null && first !== last && offset > 0) {
        if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
          this.optimize();
          return;
        }
        if (first instanceof _code2.default) {
          var newlineIndex = first.newlineIndex(first.length(), true);
          if (newlineIndex > -1) {
            first = first.split(newlineIndex + 1);
            if (first === last) {
              this.optimize();
              return;
            }
          }
        } else if (last instanceof _code2.default) {
          var _newlineIndex = last.newlineIndex(0);
          if (_newlineIndex > -1) {
            last.split(_newlineIndex + 1);
          }
        }
        var ref = last.children.head instanceof _break2.default ? null : last.children.head;
        first.moveChildren(last, ref);
        first.remove();
      }
      this.optimize();
    }
  }, {
    key: 'enable',
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.domNode.setAttribute('contenteditable', enabled);
    }
  }, {
    key: 'formatAt',
    value: function formatAt(index, length, format, value) {
      if (this.whitelist != null && !this.whitelist[format]) return;
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
      this.optimize();
    }
  }, {
    key: 'insertAt',
    value: function insertAt(index, value, def) {
      if (def != null && this.whitelist != null && !this.whitelist[value]) return;
      if (index >= this.length()) {
        if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
          var blot = _parchment2.default.create(this.statics.defaultChild);
          this.appendChild(blot);
          if (def == null && value.endsWith('\n')) {
            value = value.slice(0, -1);
          }
          blot.insertAt(0, value, def);
        } else {
          var embed = _parchment2.default.create(value, def);
          this.appendChild(embed);
        }
      } else {
        _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
      }
      this.optimize();
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
        var wrapper = _parchment2.default.create(this.statics.defaultChild);
        wrapper.appendChild(blot);
        blot = wrapper;
      }
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
    }
  }, {
    key: 'leaf',
    value: function leaf(index) {
      return this.path(index).pop() || [null, -1];
    }
  }, {
    key: 'line',
    value: function line(index) {
      if (index === this.length()) {
        return this.line(index - 1);
      }
      return this.descendant(isLine, index);
    }
  }, {
    key: 'lines',
    value: function lines() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

      var getLines = function getLines(blot, index, length) {
        var lines = [],
            lengthLeft = length;
        blot.children.forEachAt(index, length, function (child, index, length) {
          if (isLine(child)) {
            lines.push(child);
          } else if (child instanceof _parchment2.default.Container) {
            lines = lines.concat(getLines(child, index, lengthLeft));
          }
          lengthLeft -= length;
        });
        return lines;
      };
      return getLines(this, index, length);
    }
  }, {
    key: 'optimize',
    value: function optimize() {
      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.batch === true) return;
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
      }
    }
  }, {
    key: 'path',
    value: function path(index) {
      return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
    }
  }, {
    key: 'update',
    value: function update(mutations) {
      if (this.batch === true) return;
      var source = _emitter2.default.sources.USER;
      if (typeof mutations === 'string') {
        source = mutations;
      }
      if (!Array.isArray(mutations)) {
        mutations = this.observer.takeRecords();
      }
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
      }
      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy
      if (mutations.length > 0) {
        this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
      }
    }
  }]);

  return Scroll;
}(_parchment2.default.Scroll);

Scroll.blotName = 'scroll';
Scroll.className = 'ql-editor';
Scroll.tagName = 'DIV';
Scroll.defaultChild = 'block';
Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];

exports.default = Scroll;

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_389223__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SHORTKEY = exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _clone = __nested_webpack_require_389223__(21);

var _clone2 = _interopRequireDefault(_clone);

var _deepEqual = __nested_webpack_require_389223__(11);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _extend = __nested_webpack_require_389223__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __nested_webpack_require_389223__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _op = __nested_webpack_require_389223__(20);

var _op2 = _interopRequireDefault(_op);

var _parchment = __nested_webpack_require_389223__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_389223__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __nested_webpack_require_389223__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __nested_webpack_require_389223__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:keyboard');

var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';

var Keyboard = function (_Module) {
  _inherits(Keyboard, _Module);

  _createClass(Keyboard, null, [{
    key: 'match',
    value: function match(evt, binding) {
      binding = normalize(binding);
      if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
        return !!binding[key] !== evt[key] && binding[key] !== null;
      })) {
        return false;
      }
      return binding.key === (evt.which || evt.keyCode);
    }
  }]);

  function Keyboard(quill, options) {
    _classCallCheck(this, Keyboard);

    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));

    _this.bindings = {};
    Object.keys(_this.options.bindings).forEach(function (name) {
      if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
        return;
      }
      if (_this.options.bindings[name]) {
        _this.addBinding(_this.options.bindings[name]);
      }
    });
    _this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);
    _this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function () {});
    if (/Firefox/i.test(navigator.userAgent)) {
      // Need to handle delete and backspace for Firefox in the general case #1171
      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);
    } else {
      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
    }
    _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
    _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);
    _this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
    _this.listen();
    return _this;
  }

  _createClass(Keyboard, [{
    key: 'addBinding',
    value: function addBinding(key) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var binding = normalize(key);
      if (binding == null || binding.key == null) {
        return debug.warn('Attempted to add invalid keyboard binding', binding);
      }
      if (typeof context === 'function') {
        context = { handler: context };
      }
      if (typeof handler === 'function') {
        handler = { handler: handler };
      }
      binding = (0, _extend2.default)(binding, context, handler);
      this.bindings[binding.key] = this.bindings[binding.key] || [];
      this.bindings[binding.key].push(binding);
    }
  }, {
    key: 'listen',
    value: function listen() {
      var _this2 = this;

      this.quill.root.addEventListener('keydown', function (evt) {
        if (evt.defaultPrevented) return;
        var which = evt.which || evt.keyCode;
        var bindings = (_this2.bindings[which] || []).filter(function (binding) {
          return Keyboard.match(evt, binding);
        });
        if (bindings.length === 0) return;
        var range = _this2.quill.getSelection();
        if (range == null || !_this2.quill.hasFocus()) return;

        var _quill$getLine = _this2.quill.getLine(range.index),
            _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
            line = _quill$getLine2[0],
            offset = _quill$getLine2[1];

        var _quill$getLeaf = _this2.quill.getLeaf(range.index),
            _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
            leafStart = _quill$getLeaf2[0],
            offsetStart = _quill$getLeaf2[1];

        var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
            _ref2 = _slicedToArray(_ref, 2),
            leafEnd = _ref2[0],
            offsetEnd = _ref2[1];

        var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
        var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
        var curContext = {
          collapsed: range.length === 0,
          empty: range.length === 0 && line.length() <= 1,
          format: _this2.quill.getFormat(range),
          offset: offset,
          prefix: prefixText,
          suffix: suffixText
        };
        var prevented = bindings.some(function (binding) {
          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
          if (binding.empty != null && binding.empty !== curContext.empty) return false;
          if (binding.offset != null && binding.offset !== curContext.offset) return false;
          if (Array.isArray(binding.format)) {
            // any format is present
            if (binding.format.every(function (name) {
              return curContext.format[name] == null;
            })) {
              return false;
            }
          } else if (_typeof(binding.format) === 'object') {
            // all formats must match
            if (!Object.keys(binding.format).every(function (name) {
              if (binding.format[name] === true) return curContext.format[name] != null;
              if (binding.format[name] === false) return curContext.format[name] == null;
              return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
            })) {
              return false;
            }
          }
          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
          return binding.handler.call(_this2, range, curContext) !== true;
        });
        if (prevented) {
          evt.preventDefault();
        }
      });
    }
  }]);

  return Keyboard;
}(_module2.default);

Keyboard.keys = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46
};

Keyboard.DEFAULTS = {
  bindings: {
    'bold': makeFormatHandler('bold'),
    'italic': makeFormatHandler('italic'),
    'underline': makeFormatHandler('underline'),
    'indent': {
      // highlight tab or tab at beginning of list, indent or blockquote
      key: Keyboard.keys.TAB,
      format: ['blockquote', 'indent', 'list'],
      handler: function handler(range, context) {
        if (context.collapsed && context.offset !== 0) return true;
        this.quill.format('indent', '+1', _quill2.default.sources.USER);
      }
    },
    'outdent': {
      key: Keyboard.keys.TAB,
      shiftKey: true,
      format: ['blockquote', 'indent', 'list'],
      // highlight tab or tab at beginning of list, indent or blockquote
      handler: function handler(range, context) {
        if (context.collapsed && context.offset !== 0) return true;
        this.quill.format('indent', '-1', _quill2.default.sources.USER);
      }
    },
    'outdent backspace': {
      key: Keyboard.keys.BACKSPACE,
      collapsed: true,
      shiftKey: null,
      metaKey: null,
      ctrlKey: null,
      altKey: null,
      format: ['indent', 'list'],
      offset: 0,
      handler: function handler(range, context) {
        if (context.format.indent != null) {
          this.quill.format('indent', '-1', _quill2.default.sources.USER);
        } else if (context.format.list != null) {
          this.quill.format('list', false, _quill2.default.sources.USER);
        }
      }
    },
    'indent code-block': makeCodeBlockHandler(true),
    'outdent code-block': makeCodeBlockHandler(false),
    'remove tab': {
      key: Keyboard.keys.TAB,
      shiftKey: true,
      collapsed: true,
      prefix: /\t$/,
      handler: function handler(range) {
        this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
      }
    },
    'tab': {
      key: Keyboard.keys.TAB,
      handler: function handler(range) {
        this.quill.history.cutoff();
        var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.history.cutoff();
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
      }
    },
    'list empty enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['list'],
      empty: true,
      handler: function handler(range, context) {
        this.quill.format('list', false, _quill2.default.sources.USER);
        if (context.format.indent) {
          this.quill.format('indent', false, _quill2.default.sources.USER);
        }
      }
    },
    'checklist enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: { list: 'checked' },
      handler: function handler(range) {
        var _quill$getLine3 = this.quill.getLine(range.index),
            _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
            line = _quill$getLine4[0],
            offset = _quill$getLine4[1];

        var formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });
        var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
        this.quill.scrollIntoView();
      }
    },
    'header enter': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['header'],
      suffix: /^$/,
      handler: function handler(range, context) {
        var _quill$getLine5 = this.quill.getLine(range.index),
            _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
            line = _quill$getLine6[0],
            offset = _quill$getLine6[1];

        var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
        this.quill.scrollIntoView();
      }
    },
    'list autofill': {
      key: ' ',
      collapsed: true,
      format: { list: false },
      prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
      handler: function handler(range, context) {
        var length = context.prefix.length;

        var _quill$getLine7 = this.quill.getLine(range.index),
            _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
            line = _quill$getLine8[0],
            offset = _quill$getLine8[1];

        if (offset > length) return true;
        var value = void 0;
        switch (context.prefix.trim()) {
          case '[]':case '[ ]':
            value = 'unchecked';
            break;
          case '[x]':
            value = 'checked';
            break;
          case '-':case '*':
            value = 'bullet';
            break;
          default:
            value = 'ordered';
        }
        this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
        this.quill.history.cutoff();
        var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });
        this.quill.updateContents(delta, _quill2.default.sources.USER);
        this.quill.history.cutoff();
        this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
      }
    },
    'code exit': {
      key: Keyboard.keys.ENTER,
      collapsed: true,
      format: ['code-block'],
      prefix: /\n\n$/,
      suffix: /^\s+$/,
      handler: function handler(range) {
        var _quill$getLine9 = this.quill.getLine(range.index),
            _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
            line = _quill$getLine10[0],
            offset = _quill$getLine10[1];

        var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);
        this.quill.updateContents(delta, _quill2.default.sources.USER);
      }
    },
    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
  }
};

function makeEmbedArrowHandler(key, shiftKey) {
  var _ref3;

  var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
  return _ref3 = {
    key: key,
    shiftKey: shiftKey,
    altKey: null
  }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
    var index = range.index;
    if (key === Keyboard.keys.RIGHT) {
      index += range.length + 1;
    }

    var _quill$getLeaf3 = this.quill.getLeaf(index),
        _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
        leaf = _quill$getLeaf4[0];

    if (!(leaf instanceof _parchment2.default.Embed)) return true;
    if (key === Keyboard.keys.LEFT) {
      if (shiftKey) {
        this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
      } else {
        this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
      }
    } else {
      if (shiftKey) {
        this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
      } else {
        this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
      }
    }
    return false;
  }), _ref3;
}

function handleBackspace(range, context) {
  if (range.index === 0 || this.quill.getLength() <= 1) return;

  var _quill$getLine11 = this.quill.getLine(range.index),
      _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
      line = _quill$getLine12[0];

  var formats = {};
  if (context.offset === 0) {
    var _quill$getLine13 = this.quill.getLine(range.index - 1),
        _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
        prev = _quill$getLine14[0];

    if (prev != null && prev.length() > 1) {
      var curFormats = line.formats();
      var prevFormats = this.quill.getFormat(range.index - 1, 1);
      formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
    }
  }
  // Check for astral symbols
  var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
  this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
  }
  this.quill.focus();
}

function handleDelete(range, context) {
  // Check for astral symbols
  var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
  if (range.index >= this.quill.getLength() - length) return;
  var formats = {},
      nextLength = 0;

  var _quill$getLine15 = this.quill.getLine(range.index),
      _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
      line = _quill$getLine16[0];

  if (context.offset >= line.length() - 1) {
    var _quill$getLine17 = this.quill.getLine(range.index + 1),
        _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
        next = _quill$getLine18[0];

    if (next) {
      var curFormats = line.formats();
      var nextFormats = this.quill.getFormat(range.index, 1);
      formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
      nextLength = next.length();
    }
  }
  this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
  }
}

function handleDeleteRange(range) {
  var lines = this.quill.getLines(range);
  var formats = {};
  if (lines.length > 1) {
    var firstFormats = lines[0].formats();
    var lastFormats = lines[lines.length - 1].formats();
    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
  }
  this.quill.deleteText(range, _quill2.default.sources.USER);
  if (Object.keys(formats).length > 0) {
    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
  }
  this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
  this.quill.focus();
}

function handleEnter(range, context) {
  var _this3 = this;

  if (range.length > 0) {
    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
  }
  var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
      lineFormats[format] = context.format[format];
    }
    return lineFormats;
  }, {});
  this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
  // Earlier scroll.deleteAt might have messed up our selection,
  // so insertText's built in selection preservation is not reliable
  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
  this.quill.focus();
  Object.keys(context.format).forEach(function (name) {
    if (lineFormats[name] != null) return;
    if (Array.isArray(context.format[name])) return;
    if (name === 'link') return;
    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
  });
}

function makeCodeBlockHandler(indent) {
  return {
    key: Keyboard.keys.TAB,
    shiftKey: !indent,
    format: { 'code-block': true },
    handler: function handler(range) {
      var CodeBlock = _parchment2.default.query('code-block');
      var index = range.index,
          length = range.length;

      var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
          _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
          block = _quill$scroll$descend2[0],
          offset = _quill$scroll$descend2[1];

      if (block == null) return;
      var scrollIndex = this.quill.getIndex(block);
      var start = block.newlineIndex(offset, true) + 1;
      var end = block.newlineIndex(scrollIndex + offset + length);
      var lines = block.domNode.textContent.slice(start, end).split('\n');
      offset = 0;
      lines.forEach(function (line, i) {
        if (indent) {
          block.insertAt(start + offset, CodeBlock.TAB);
          offset += CodeBlock.TAB.length;
          if (i === 0) {
            index += CodeBlock.TAB.length;
          } else {
            length += CodeBlock.TAB.length;
          }
        } else if (line.startsWith(CodeBlock.TAB)) {
          block.deleteAt(start + offset, CodeBlock.TAB.length);
          offset -= CodeBlock.TAB.length;
          if (i === 0) {
            index -= CodeBlock.TAB.length;
          } else {
            length -= CodeBlock.TAB.length;
          }
        }
        offset += line.length + 1;
      });
      this.quill.update(_quill2.default.sources.USER);
      this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
    }
  };
}

function makeFormatHandler(format) {
  return {
    key: format[0].toUpperCase(),
    shortKey: true,
    handler: function handler(range, context) {
      this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
    }
  };
}

function normalize(binding) {
  if (typeof binding === 'string' || typeof binding === 'number') {
    return normalize({ key: binding });
  }
  if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
    binding = (0, _clone2.default)(binding, false);
  }
  if (typeof binding.key === 'string') {
    if (Keyboard.keys[binding.key.toUpperCase()] != null) {
      binding.key = Keyboard.keys[binding.key.toUpperCase()];
    } else if (binding.key.length === 1) {
      binding.key = binding.key.toUpperCase().charCodeAt(0);
    } else {
      return null;
    }
  }
  if (binding.shortKey) {
    binding[SHORTKEY] = binding.shortKey;
    delete binding.shortKey;
  }
  return binding;
}

exports.default = Keyboard;
exports.SHORTKEY = SHORTKEY;

/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_413551__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __nested_webpack_require_413551__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _text = __nested_webpack_require_413551__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = function (_Parchment$Embed) {
  _inherits(Cursor, _Parchment$Embed);

  _createClass(Cursor, null, [{
    key: 'value',
    value: function value() {
      return undefined;
    }
  }]);

  function Cursor(domNode, selection) {
    _classCallCheck(this, Cursor);

    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));

    _this.selection = selection;
    _this.textNode = document.createTextNode(Cursor.CONTENTS);
    _this.domNode.appendChild(_this.textNode);
    _this._length = 0;
    return _this;
  }

  _createClass(Cursor, [{
    key: 'detach',
    value: function detach() {
      // super.detach() will also clear domNode.__blot
      if (this.parent != null) this.parent.removeChild(this);
    }
  }, {
    key: 'format',
    value: function format(name, value) {
      if (this._length !== 0) {
        return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
      }
      var target = this,
          index = 0;
      while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
        index += target.offset(target.parent);
        target = target.parent;
      }
      if (target != null) {
        this._length = Cursor.CONTENTS.length;
        target.optimize();
        target.formatAt(index, Cursor.CONTENTS.length, name, value);
        this._length = 0;
      }
    }
  }, {
    key: 'index',
    value: function index(node, offset) {
      if (node === this.textNode) return 0;
      return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
    }
  }, {
    key: 'length',
    value: function length() {
      return this._length;
    }
  }, {
    key: 'position',
    value: function position() {
      return [this.textNode, this.textNode.data.length];
    }
  }, {
    key: 'remove',
    value: function remove() {
      _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
      this.parent = null;
    }
  }, {
    key: 'restore',
    value: function restore() {
      if (this.selection.composing || this.parent == null) return;
      var textNode = this.textNode;
      var range = this.selection.getNativeRange();
      var restoreText = void 0,
          start = void 0,
          end = void 0;
      if (range != null && range.start.node === textNode && range.end.node === textNode) {
        var _ref = [textNode, range.start.offset, range.end.offset];
        restoreText = _ref[0];
        start = _ref[1];
        end = _ref[2];
      }
      // Link format will insert text outside of anchor tag
      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
      }
      if (this.textNode.data !== Cursor.CONTENTS) {
        var text = this.textNode.data.split(Cursor.CONTENTS).join('');
        if (this.next instanceof _text2.default) {
          restoreText = this.next.domNode;
          this.next.insertAt(0, text);
          this.textNode.data = Cursor.CONTENTS;
        } else {
          this.textNode.data = text;
          this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
          this.textNode = document.createTextNode(Cursor.CONTENTS);
          this.domNode.appendChild(this.textNode);
        }
      }
      this.remove();
      if (start != null) {
        var _map = [start, end].map(function (offset) {
          return Math.max(0, Math.min(restoreText.data.length, offset - 1));
        });

        var _map2 = _slicedToArray(_map, 2);

        start = _map2[0];
        end = _map2[1];

        return {
          startNode: restoreText,
          startOffset: start,
          endNode: restoreText,
          endOffset: end
        };
      }
    }
  }, {
    key: 'update',
    value: function update(mutations, context) {
      var _this2 = this;

      if (mutations.some(function (mutation) {
        return mutation.type === 'characterData' && mutation.target === _this2.textNode;
      })) {
        var range = this.restore();
        if (range) context.range = range;
      }
    }
  }, {
    key: 'value',
    value: function value() {
      return '';
    }
  }]);

  return Cursor;
}(_parchment2.default.Embed);

Cursor.blotName = 'cursor';
Cursor.className = 'ql-cursor';
Cursor.tagName = 'span';
Cursor.CONTENTS = '\uFEFF'; // Zero width no break space


exports.default = Cursor;

/***/ }),
/* 25 */
/***/ (function(module, exports, __nested_webpack_require_421182__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __nested_webpack_require_421182__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __nested_webpack_require_421182__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Parchment$Container) {
  _inherits(Container, _Parchment$Container);

  function Container() {
    _classCallCheck(this, Container);

    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
  }

  return Container;
}(_parchment2.default.Container);

Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];

exports.default = Container;

/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_422953__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_422953__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorAttributor = function (_Parchment$Attributor) {
  _inherits(ColorAttributor, _Parchment$Attributor);

  function ColorAttributor() {
    _classCallCheck(this, ColorAttributor);

    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
  }

  _createClass(ColorAttributor, [{
    key: 'value',
    value: function value(domNode) {
      var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
      if (!value.startsWith('rgb(')) return value;
      value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
      return '#' + value.split(',').map(function (component) {
        return ('00' + parseInt(component).toString(16)).slice(-2);
      }).join('');
    }
  }]);

  return ColorAttributor;
}(_parchment2.default.Attributor.Style);

var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
  scope: _parchment2.default.Scope.INLINE
});
var ColorStyle = new ColorAttributor('color', 'color', {
  scope: _parchment2.default.Scope.INLINE
});

exports.ColorAttributor = ColorAttributor;
exports.ColorClass = ColorClass;
exports.ColorStyle = ColorStyle;

/***/ }),
/* 27 */
/***/ (function(module, exports, __nested_webpack_require_426581__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitize = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __nested_webpack_require_426581__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Link = function (_Inline) {
  _inherits(Link, _Inline);

  function Link() {
    _classCallCheck(this, Link);

    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
  }

  _createClass(Link, [{
    key: 'format',
    value: function format(name, value) {
      if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
      value = this.constructor.sanitize(value);
      this.domNode.setAttribute('href', value);
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
      value = this.sanitize(value);
      node.setAttribute('href', value);
      node.setAttribute('rel', 'noopener noreferrer');
      node.setAttribute('target', '_blank');
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return domNode.getAttribute('href');
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
    }
  }]);

  return Link;
}(_inline2.default);

Link.blotName = 'link';
Link.tagName = 'A';
Link.SANITIZED_URL = 'about:blank';
Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];

function _sanitize(url, protocols) {
  var anchor = document.createElement('a');
  anchor.href = url;
  var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
  return protocols.indexOf(protocol) > -1;
}

exports.default = Link;
exports.sanitize = _sanitize;

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_430596__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _keyboard = __nested_webpack_require_430596__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

var _dropdown = __nested_webpack_require_430596__(107);

var _dropdown2 = _interopRequireDefault(_dropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var optionsCounter = 0;

function toggleAriaAttribute(element, attribute) {
  element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
}

var Picker = function () {
  function Picker(select) {
    var _this = this;

    _classCallCheck(this, Picker);

    this.select = select;
    this.container = document.createElement('span');
    this.buildPicker();
    this.select.style.display = 'none';
    this.select.parentNode.insertBefore(this.container, this.select);

    this.label.addEventListener('mousedown', function () {
      _this.togglePicker();
    });
    this.label.addEventListener('keydown', function (event) {
      switch (event.keyCode) {
        // Allows the "Enter" key to open the picker
        case _keyboard2.default.keys.ENTER:
          _this.togglePicker();
          break;

        // Allows the "Escape" key to close the picker
        case _keyboard2.default.keys.ESCAPE:
          _this.escape();
          event.preventDefault();
          break;
      }
    });
    this.select.addEventListener('change', this.update.bind(this));
  }

  _createClass(Picker, [{
    key: 'togglePicker',
    value: function togglePicker() {
      this.container.classList.toggle('ql-expanded');
      // Toggle aria-expanded and aria-hidden to make the picker accessible
      toggleAriaAttribute(this.label, 'aria-expanded');
      toggleAriaAttribute(this.options, 'aria-hidden');
    }
  }, {
    key: 'buildItem',
    value: function buildItem(option) {
      var _this2 = this;

      var item = document.createElement('span');
      item.tabIndex = '0';
      item.setAttribute('role', 'button');

      item.classList.add('ql-picker-item');
      if (option.hasAttribute('value')) {
        item.setAttribute('data-value', option.getAttribute('value'));
      }
      if (option.textContent) {
        item.setAttribute('data-label', option.textContent);
      }
      item.addEventListener('click', function () {
        _this2.selectItem(item, true);
      });
      item.addEventListener('keydown', function (event) {
        switch (event.keyCode) {
          // Allows the "Enter" key to select an item
          case _keyboard2.default.keys.ENTER:
            _this2.selectItem(item, true);
            event.preventDefault();
            break;

          // Allows the "Escape" key to close the picker
          case _keyboard2.default.keys.ESCAPE:
            _this2.escape();
            event.preventDefault();
            break;
        }
      });

      return item;
    }
  }, {
    key: 'buildLabel',
    value: function buildLabel() {
      var label = document.createElement('span');
      label.classList.add('ql-picker-label');
      label.innerHTML = _dropdown2.default;
      label.tabIndex = '0';
      label.setAttribute('role', 'button');
      label.setAttribute('aria-expanded', 'false');
      this.container.appendChild(label);
      return label;
    }
  }, {
    key: 'buildOptions',
    value: function buildOptions() {
      var _this3 = this;

      var options = document.createElement('span');
      options.classList.add('ql-picker-options');

      // Don't want screen readers to read this until options are visible
      options.setAttribute('aria-hidden', 'true');
      options.tabIndex = '-1';

      // Need a unique id for aria-controls
      options.id = 'ql-picker-options-' + optionsCounter;
      optionsCounter += 1;
      this.label.setAttribute('aria-controls', options.id);

      this.options = options;

      [].slice.call(this.select.options).forEach(function (option) {
        var item = _this3.buildItem(option);
        options.appendChild(item);
        if (option.selected === true) {
          _this3.selectItem(item);
        }
      });
      this.container.appendChild(options);
    }
  }, {
    key: 'buildPicker',
    value: function buildPicker() {
      var _this4 = this;

      [].slice.call(this.select.attributes).forEach(function (item) {
        _this4.container.setAttribute(item.name, item.value);
      });
      this.container.classList.add('ql-picker');
      this.label = this.buildLabel();
      this.buildOptions();
    }
  }, {
    key: 'escape',
    value: function escape() {
      var _this5 = this;

      // Close menu and return focus to trigger label
      this.close();
      // Need setTimeout for accessibility to ensure that the browser executes
      // focus on the next process thread and after any DOM content changes
      setTimeout(function () {
        return _this5.label.focus();
      }, 1);
    }
  }, {
    key: 'close',
    value: function close() {
      this.container.classList.remove('ql-expanded');
      this.label.setAttribute('aria-expanded', 'false');
      this.options.setAttribute('aria-hidden', 'true');
    }
  }, {
    key: 'selectItem',
    value: function selectItem(item) {
      var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var selected = this.container.querySelector('.ql-selected');
      if (item === selected) return;
      if (selected != null) {
        selected.classList.remove('ql-selected');
      }
      if (item == null) return;
      item.classList.add('ql-selected');
      this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
      if (item.hasAttribute('data-value')) {
        this.label.setAttribute('data-value', item.getAttribute('data-value'));
      } else {
        this.label.removeAttribute('data-value');
      }
      if (item.hasAttribute('data-label')) {
        this.label.setAttribute('data-label', item.getAttribute('data-label'));
      } else {
        this.label.removeAttribute('data-label');
      }
      if (trigger) {
        if (typeof Event === 'function') {
          this.select.dispatchEvent(new Event('change'));
        } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
          // IE11
          var event = document.createEvent('Event');
          event.initEvent('change', true, true);
          this.select.dispatchEvent(event);
        }
        this.close();
      }
    }
  }, {
    key: 'update',
    value: function update() {
      var option = void 0;
      if (this.select.selectedIndex > -1) {
        var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
        option = this.select.options[this.select.selectedIndex];
        this.selectItem(item);
      } else {
        this.selectItem(null);
      }
      var isActive = option != null && option !== this.select.querySelector('option[selected]');
      this.label.classList.toggle('ql-active', isActive);
    }
  }]);

  return Picker;
}();

exports.default = Picker;

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_438739__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parchment = __nested_webpack_require_438739__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_438739__(5);

var _quill2 = _interopRequireDefault(_quill);

var _block = __nested_webpack_require_438739__(4);

var _block2 = _interopRequireDefault(_block);

var _break = __nested_webpack_require_438739__(16);

var _break2 = _interopRequireDefault(_break);

var _container = __nested_webpack_require_438739__(25);

var _container2 = _interopRequireDefault(_container);

var _cursor = __nested_webpack_require_438739__(24);

var _cursor2 = _interopRequireDefault(_cursor);

var _embed = __nested_webpack_require_438739__(35);

var _embed2 = _interopRequireDefault(_embed);

var _inline = __nested_webpack_require_438739__(6);

var _inline2 = _interopRequireDefault(_inline);

var _scroll = __nested_webpack_require_438739__(22);

var _scroll2 = _interopRequireDefault(_scroll);

var _text = __nested_webpack_require_438739__(7);

var _text2 = _interopRequireDefault(_text);

var _clipboard = __nested_webpack_require_438739__(55);

var _clipboard2 = _interopRequireDefault(_clipboard);

var _history = __nested_webpack_require_438739__(42);

var _history2 = _interopRequireDefault(_history);

var _keyboard = __nested_webpack_require_438739__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_quill2.default.register({
  'blots/block': _block2.default,
  'blots/block/embed': _block.BlockEmbed,
  'blots/break': _break2.default,
  'blots/container': _container2.default,
  'blots/cursor': _cursor2.default,
  'blots/embed': _embed2.default,
  'blots/inline': _inline2.default,
  'blots/scroll': _scroll2.default,
  'blots/text': _text2.default,

  'modules/clipboard': _clipboard2.default,
  'modules/history': _history2.default,
  'modules/keyboard': _keyboard2.default
});

_parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);

exports.default = _quill2.default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_440804__) {

Object.defineProperty(exports, "__esModule", { value: true });
var Registry = __nested_webpack_require_440804__(1);
var ShadowBlot = /** @class */ (function () {
    function ShadowBlot(domNode) {
        this.domNode = domNode;
        // @ts-ignore
        this.domNode[Registry.DATA_KEY] = { blot: this };
    }
    Object.defineProperty(ShadowBlot.prototype, "statics", {
        // Hack for accessing inherited static methods
        get: function () {
            return this.constructor;
        },
        enumerable: true,
        configurable: true
    });
    ShadowBlot.create = function (value) {
        if (this.tagName == null) {
            throw new Registry.ParchmentError('Blot definition missing tagName');
        }
        var node;
        if (Array.isArray(this.tagName)) {
            if (typeof value === 'string') {
                value = value.toUpperCase();
                if (parseInt(value).toString() === value) {
                    value = parseInt(value);
                }
            }
            if (typeof value === 'number') {
                node = document.createElement(this.tagName[value - 1]);
            }
            else if (this.tagName.indexOf(value) > -1) {
                node = document.createElement(value);
            }
            else {
                node = document.createElement(this.tagName[0]);
            }
        }
        else {
            node = document.createElement(this.tagName);
        }
        if (this.className) {
            node.classList.add(this.className);
        }
        return node;
    };
    ShadowBlot.prototype.attach = function () {
        if (this.parent != null) {
            this.scroll = this.parent.scroll;
        }
    };
    ShadowBlot.prototype.clone = function () {
        var domNode = this.domNode.cloneNode(false);
        return Registry.create(domNode);
    };
    ShadowBlot.prototype.detach = function () {
        if (this.parent != null)
            this.parent.removeChild(this);
        // @ts-ignore
        delete this.domNode[Registry.DATA_KEY];
    };
    ShadowBlot.prototype.deleteAt = function (index, length) {
        var blot = this.isolate(index, length);
        blot.remove();
    };
    ShadowBlot.prototype.formatAt = function (index, length, name, value) {
        var blot = this.isolate(index, length);
        if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
            blot.wrap(name, value);
        }
        else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
            var parent = Registry.create(this.statics.scope);
            blot.wrap(parent);
            parent.format(name, value);
        }
    };
    ShadowBlot.prototype.insertAt = function (index, value, def) {
        var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
        var ref = this.split(index);
        this.parent.insertBefore(blot, ref);
    };
    ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
        if (refBlot === void 0) { refBlot = null; }
        if (this.parent != null) {
            this.parent.children.remove(this);
        }
        var refDomNode = null;
        parentBlot.children.insertBefore(this, refBlot);
        if (refBlot != null) {
            refDomNode = refBlot.domNode;
        }
        if (this.domNode.parentNode != parentBlot.domNode ||
            this.domNode.nextSibling != refDomNode) {
            parentBlot.domNode.insertBefore(this.domNode, refDomNode);
        }
        this.parent = parentBlot;
        this.attach();
    };
    ShadowBlot.prototype.isolate = function (index, length) {
        var target = this.split(index);
        target.split(length);
        return target;
    };
    ShadowBlot.prototype.length = function () {
        return 1;
    };
    ShadowBlot.prototype.offset = function (root) {
        if (root === void 0) { root = this.parent; }
        if (this.parent == null || this == root)
            return 0;
        return this.parent.children.offset(this) + this.parent.offset(root);
    };
    ShadowBlot.prototype.optimize = function (context) {
        // TODO clean up once we use WeakMap
        // @ts-ignore
        if (this.domNode[Registry.DATA_KEY] != null) {
            // @ts-ignore
            delete this.domNode[Registry.DATA_KEY].mutations;
        }
    };
    ShadowBlot.prototype.remove = function () {
        if (this.domNode.parentNode != null) {
            this.domNode.parentNode.removeChild(this.domNode);
        }
        this.detach();
    };
    ShadowBlot.prototype.replace = function (target) {
        if (target.parent == null)
            return;
        target.parent.insertBefore(this, target.next);
        target.remove();
    };
    ShadowBlot.prototype.replaceWith = function (name, value) {
        var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
        replacement.replace(this);
        return replacement;
    };
    ShadowBlot.prototype.split = function (index, force) {
        return index === 0 ? this : this.next;
    };
    ShadowBlot.prototype.update = function (mutations, context) {
        // Nothing to do by default
    };
    ShadowBlot.prototype.wrap = function (name, value) {
        var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
        if (this.parent != null) {
            this.parent.insertBefore(wrapper, this.next);
        }
        wrapper.appendChild(this);
        return wrapper;
    };
    ShadowBlot.blotName = 'abstract';
    return ShadowBlot;
}());
exports.default = ShadowBlot;


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_446486__) {

Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __nested_webpack_require_446486__(12);
var class_1 = __nested_webpack_require_446486__(32);
var style_1 = __nested_webpack_require_446486__(33);
var Registry = __nested_webpack_require_446486__(1);
var AttributorStore = /** @class */ (function () {
    function AttributorStore(domNode) {
        this.attributes = {};
        this.domNode = domNode;
        this.build();
    }
    AttributorStore.prototype.attribute = function (attribute, value) {
        // verb
        if (value) {
            if (attribute.add(this.domNode, value)) {
                if (attribute.value(this.domNode) != null) {
                    this.attributes[attribute.attrName] = attribute;
                }
                else {
                    delete this.attributes[attribute.attrName];
                }
            }
        }
        else {
            attribute.remove(this.domNode);
            delete this.attributes[attribute.attrName];
        }
    };
    AttributorStore.prototype.build = function () {
        var _this = this;
        this.attributes = {};
        var attributes = attributor_1.default.keys(this.domNode);
        var classes = class_1.default.keys(this.domNode);
        var styles = style_1.default.keys(this.domNode);
        attributes
            .concat(classes)
            .concat(styles)
            .forEach(function (name) {
            var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
            if (attr instanceof attributor_1.default) {
                _this.attributes[attr.attrName] = attr;
            }
        });
    };
    AttributorStore.prototype.copy = function (target) {
        var _this = this;
        Object.keys(this.attributes).forEach(function (key) {
            var value = _this.attributes[key].value(_this.domNode);
            target.format(key, value);
        });
    };
    AttributorStore.prototype.move = function (target) {
        var _this = this;
        this.copy(target);
        Object.keys(this.attributes).forEach(function (key) {
            _this.attributes[key].remove(_this.domNode);
        });
        this.attributes = {};
    };
    AttributorStore.prototype.values = function () {
        var _this = this;
        return Object.keys(this.attributes).reduce(function (attributes, name) {
            attributes[name] = _this.attributes[name].value(_this.domNode);
            return attributes;
        }, {});
    };
    return AttributorStore;
}());
exports.default = AttributorStore;


/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_449069__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __nested_webpack_require_449069__(12);
function match(node, prefix) {
    var className = node.getAttribute('class') || '';
    return className.split(/\s+/).filter(function (name) {
        return name.indexOf(prefix + "-") === 0;
    });
}
var ClassAttributor = /** @class */ (function (_super) {
    __extends(ClassAttributor, _super);
    function ClassAttributor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClassAttributor.keys = function (node) {
        return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
            return name
                .split('-')
                .slice(0, -1)
                .join('-');
        });
    };
    ClassAttributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        this.remove(node);
        node.classList.add(this.keyName + "-" + value);
        return true;
    };
    ClassAttributor.prototype.remove = function (node) {
        var matches = match(node, this.keyName);
        matches.forEach(function (name) {
            node.classList.remove(name);
        });
        if (node.classList.length === 0) {
            node.removeAttribute('class');
        }
    };
    ClassAttributor.prototype.value = function (node) {
        var result = match(node, this.keyName)[0] || '';
        var value = result.slice(this.keyName.length + 1); // +1 for hyphen
        return this.canAdd(node, value) ? value : '';
    };
    return ClassAttributor;
}(attributor_1.default));
exports.default = ClassAttributor;


/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_451298__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var attributor_1 = __nested_webpack_require_451298__(12);
function camelize(name) {
    var parts = name.split('-');
    var rest = parts
        .slice(1)
        .map(function (part) {
        return part[0].toUpperCase() + part.slice(1);
    })
        .join('');
    return parts[0] + rest;
}
var StyleAttributor = /** @class */ (function (_super) {
    __extends(StyleAttributor, _super);
    function StyleAttributor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StyleAttributor.keys = function (node) {
        return (node.getAttribute('style') || '').split(';').map(function (value) {
            var arr = value.split(':');
            return arr[0].trim();
        });
    };
    StyleAttributor.prototype.add = function (node, value) {
        if (!this.canAdd(node, value))
            return false;
        // @ts-ignore
        node.style[camelize(this.keyName)] = value;
        return true;
    };
    StyleAttributor.prototype.remove = function (node) {
        // @ts-ignore
        node.style[camelize(this.keyName)] = '';
        if (!node.getAttribute('style')) {
            node.removeAttribute('style');
        }
    };
    StyleAttributor.prototype.value = function (node) {
        // @ts-ignore
        var value = node.style[camelize(this.keyName)];
        return this.canAdd(node, value) ? value : '';
    };
    return StyleAttributor;
}(attributor_1.default));
exports.default = StyleAttributor;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Theme = function () {
  function Theme(quill, options) {
    _classCallCheck(this, Theme);

    this.quill = quill;
    this.options = options;
    this.modules = {};
  }

  _createClass(Theme, [{
    key: 'init',
    value: function init() {
      var _this = this;

      Object.keys(this.options.modules).forEach(function (name) {
        if (_this.modules[name] == null) {
          _this.addModule(name);
        }
      });
    }
  }, {
    key: 'addModule',
    value: function addModule(name) {
      var moduleClass = this.quill.constructor.import('modules/' + name);
      this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
      return this.modules[name];
    }
  }]);

  return Theme;
}();

Theme.DEFAULTS = {
  modules: {}
};
Theme.themes = {
  'default': Theme
};

exports.default = Theme;

/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_455095__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_455095__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _text = __nested_webpack_require_455095__(7);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GUARD_TEXT = '\uFEFF';

var Embed = function (_Parchment$Embed) {
  _inherits(Embed, _Parchment$Embed);

  function Embed(node) {
    _classCallCheck(this, Embed);

    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));

    _this.contentNode = document.createElement('span');
    _this.contentNode.setAttribute('contenteditable', false);
    [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
      _this.contentNode.appendChild(childNode);
    });
    _this.leftGuard = document.createTextNode(GUARD_TEXT);
    _this.rightGuard = document.createTextNode(GUARD_TEXT);
    _this.domNode.appendChild(_this.leftGuard);
    _this.domNode.appendChild(_this.contentNode);
    _this.domNode.appendChild(_this.rightGuard);
    return _this;
  }

  _createClass(Embed, [{
    key: 'index',
    value: function index(node, offset) {
      if (node === this.leftGuard) return 0;
      if (node === this.rightGuard) return 1;
      return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
    }
  }, {
    key: 'restore',
    value: function restore(node) {
      var range = void 0,
          textNode = void 0;
      var text = node.data.split(GUARD_TEXT).join('');
      if (node === this.leftGuard) {
        if (this.prev instanceof _text2.default) {
          var prevLength = this.prev.length();
          this.prev.insertAt(prevLength, text);
          range = {
            startNode: this.prev.domNode,
            startOffset: prevLength + text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(_parchment2.default.create(textNode), this);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      } else if (node === this.rightGuard) {
        if (this.next instanceof _text2.default) {
          this.next.insertAt(0, text);
          range = {
            startNode: this.next.domNode,
            startOffset: text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      }
      node.data = GUARD_TEXT;
      return range;
    }
  }, {
    key: 'update',
    value: function update(mutations, context) {
      var _this2 = this;

      mutations.forEach(function (mutation) {
        if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
          var range = _this2.restore(mutation.target);
          if (range) context.range = range;
        }
      });
    }
  }]);

  return Embed;
}(_parchment2.default.Embed);

exports.default = Embed;

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_460408__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;

var _parchment = __nested_webpack_require_460408__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: ['right', 'center', 'justify']
};

var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);

exports.AlignAttribute = AlignAttribute;
exports.AlignClass = AlignClass;
exports.AlignStyle = AlignStyle;

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_461308__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BackgroundStyle = exports.BackgroundClass = undefined;

var _parchment = __nested_webpack_require_461308__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _color = __nested_webpack_require_461308__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
  scope: _parchment2.default.Scope.INLINE
});
var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
  scope: _parchment2.default.Scope.INLINE
});

exports.BackgroundClass = BackgroundClass;
exports.BackgroundStyle = BackgroundStyle;

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_462100__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;

var _parchment = __nested_webpack_require_462100__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: ['rtl']
};

var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);

exports.DirectionAttribute = DirectionAttribute;
exports.DirectionClass = DirectionClass;
exports.DirectionStyle = DirectionStyle;

/***/ }),
/* 39 */
/***/ (function(module, exports, __nested_webpack_require_463038__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FontClass = exports.FontStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_463038__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var config = {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['serif', 'monospace']
};

var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);

var FontStyleAttributor = function (_Parchment$Attributor) {
  _inherits(FontStyleAttributor, _Parchment$Attributor);

  function FontStyleAttributor() {
    _classCallCheck(this, FontStyleAttributor);

    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
  }

  _createClass(FontStyleAttributor, [{
    key: 'value',
    value: function value(node) {
      return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
    }
  }]);

  return FontStyleAttributor;
}(_parchment2.default.Attributor.Style);

var FontStyle = new FontStyleAttributor('font', 'font-family', config);

exports.FontStyle = FontStyle;
exports.FontClass = FontClass;

/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_466399__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SizeStyle = exports.SizeClass = undefined;

var _parchment = __nested_webpack_require_466399__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['small', 'large', 'huge']
});
var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
  scope: _parchment2.default.Scope.INLINE,
  whitelist: ['10px', '18px', '32px']
});

exports.SizeClass = SizeClass;
exports.SizeStyle = SizeStyle;

/***/ }),
/* 41 */
/***/ (function(module, exports, __nested_webpack_require_467181__) {


module.exports = {
  'align': {
    '': __nested_webpack_require_467181__(76),
    'center': __nested_webpack_require_467181__(77),
    'right': __nested_webpack_require_467181__(78),
    'justify': __nested_webpack_require_467181__(79)
  },
  'background': __nested_webpack_require_467181__(80),
  'blockquote': __nested_webpack_require_467181__(81),
  'bold': __nested_webpack_require_467181__(82),
  'clean': __nested_webpack_require_467181__(83),
  'code': __nested_webpack_require_467181__(58),
  'code-block': __nested_webpack_require_467181__(58),
  'color': __nested_webpack_require_467181__(84),
  'direction': {
    '': __nested_webpack_require_467181__(85),
    'rtl': __nested_webpack_require_467181__(86)
  },
  'float': {
    'center': __nested_webpack_require_467181__(87),
    'full': __nested_webpack_require_467181__(88),
    'left': __nested_webpack_require_467181__(89),
    'right': __nested_webpack_require_467181__(90)
  },
  'formula': __nested_webpack_require_467181__(91),
  'header': {
    '1': __nested_webpack_require_467181__(92),
    '2': __nested_webpack_require_467181__(93)
  },
  'italic': __nested_webpack_require_467181__(94),
  'image': __nested_webpack_require_467181__(95),
  'indent': {
    '+1': __nested_webpack_require_467181__(96),
    '-1': __nested_webpack_require_467181__(97)
  },
  'link': __nested_webpack_require_467181__(98),
  'list': {
    'ordered': __nested_webpack_require_467181__(99),
    'bullet': __nested_webpack_require_467181__(100),
    'check': __nested_webpack_require_467181__(101)
  },
  'script': {
    'sub': __nested_webpack_require_467181__(102),
    'super': __nested_webpack_require_467181__(103)
  },
  'strike': __nested_webpack_require_467181__(104),
  'underline': __nested_webpack_require_467181__(105),
  'video': __nested_webpack_require_467181__(106)
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_468635__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLastChangeIndex = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parchment = __nested_webpack_require_468635__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_468635__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __nested_webpack_require_468635__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var History = function (_Module) {
  _inherits(History, _Module);

  function History(quill, options) {
    _classCallCheck(this, History);

    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));

    _this.lastRecorded = 0;
    _this.ignoreChange = false;
    _this.clear();
    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
      if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
      if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
        _this.record(delta, oldDelta);
      } else {
        _this.transform(delta);
      }
    });
    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true }, _this.undo.bind(_this));
    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true, shiftKey: true }, _this.redo.bind(_this));
    if (/Win/i.test(navigator.platform)) {
      _this.quill.keyboard.addBinding({ key: 'Y', shortKey: true }, _this.redo.bind(_this));
    }
    return _this;
  }

  _createClass(History, [{
    key: 'change',
    value: function change(source, dest) {
      if (this.stack[source].length === 0) return;
      var delta = this.stack[source].pop();
      this.stack[dest].push(delta);
      this.lastRecorded = 0;
      this.ignoreChange = true;
      this.quill.updateContents(delta[source], _quill2.default.sources.USER);
      this.ignoreChange = false;
      var index = getLastChangeIndex(delta[source]);
      this.quill.setSelection(index);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.stack = { undo: [], redo: [] };
    }
  }, {
    key: 'cutoff',
    value: function cutoff() {
      this.lastRecorded = 0;
    }
  }, {
    key: 'record',
    value: function record(changeDelta, oldDelta) {
      if (changeDelta.ops.length === 0) return;
      this.stack.redo = [];
      var undoDelta = this.quill.getContents().diff(oldDelta);
      var timestamp = Date.now();
      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
        var delta = this.stack.undo.pop();
        undoDelta = undoDelta.compose(delta.undo);
        changeDelta = delta.redo.compose(changeDelta);
      } else {
        this.lastRecorded = timestamp;
      }
      this.stack.undo.push({
        redo: changeDelta,
        undo: undoDelta
      });
      if (this.stack.undo.length > this.options.maxStack) {
        this.stack.undo.shift();
      }
    }
  }, {
    key: 'redo',
    value: function redo() {
      this.change('redo', 'undo');
    }
  }, {
    key: 'transform',
    value: function transform(delta) {
      this.stack.undo.forEach(function (change) {
        change.undo = delta.transform(change.undo, true);
        change.redo = delta.transform(change.redo, true);
      });
      this.stack.redo.forEach(function (change) {
        change.undo = delta.transform(change.undo, true);
        change.redo = delta.transform(change.redo, true);
      });
    }
  }, {
    key: 'undo',
    value: function undo() {
      this.change('undo', 'redo');
    }
  }]);

  return History;
}(_module2.default);

History.DEFAULTS = {
  delay: 1000,
  maxStack: 100,
  userOnly: false
};

function endsWithNewlineChange(delta) {
  var lastOp = delta.ops[delta.ops.length - 1];
  if (lastOp == null) return false;
  if (lastOp.insert != null) {
    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
  }
  if (lastOp.attributes != null) {
    return Object.keys(lastOp.attributes).some(function (attr) {
      return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
    });
  }
  return false;
}

function getLastChangeIndex(delta) {
  var deleteLength = delta.reduce(function (length, op) {
    length += op.delete || 0;
    return length;
  }, 0);
  var changeIndex = delta.length() - deleteLength;
  if (endsWithNewlineChange(delta)) {
    changeIndex -= 1;
  }
  return changeIndex;
}

exports.default = History;
exports.getLastChangeIndex = getLastChangeIndex;

/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_474755__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BaseTooltip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extend = __nested_webpack_require_474755__(3);

var _extend2 = _interopRequireDefault(_extend);

var _quillDelta = __nested_webpack_require_474755__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _emitter = __nested_webpack_require_474755__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _keyboard = __nested_webpack_require_474755__(23);

var _keyboard2 = _interopRequireDefault(_keyboard);

var _theme = __nested_webpack_require_474755__(34);

var _theme2 = _interopRequireDefault(_theme);

var _colorPicker = __nested_webpack_require_474755__(59);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _iconPicker = __nested_webpack_require_474755__(60);

var _iconPicker2 = _interopRequireDefault(_iconPicker);

var _picker = __nested_webpack_require_474755__(28);

var _picker2 = _interopRequireDefault(_picker);

var _tooltip = __nested_webpack_require_474755__(61);

var _tooltip2 = _interopRequireDefault(_tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ALIGNS = [false, 'center', 'right', 'justify'];

var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];

var FONTS = [false, 'serif', 'monospace'];

var HEADERS = ['1', '2', '3', false];

var SIZES = ['small', false, 'large', 'huge'];

var BaseTheme = function (_Theme) {
  _inherits(BaseTheme, _Theme);

  function BaseTheme(quill, options) {
    _classCallCheck(this, BaseTheme);

    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));

    var listener = function listener(e) {
      if (!document.body.contains(quill.root)) {
        return document.body.removeEventListener('click', listener);
      }
      if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
        _this.tooltip.hide();
      }
      if (_this.pickers != null) {
        _this.pickers.forEach(function (picker) {
          if (!picker.container.contains(e.target)) {
            picker.close();
          }
        });
      }
    };
    quill.emitter.listenDOM('click', document.body, listener);
    return _this;
  }

  _createClass(BaseTheme, [{
    key: 'addModule',
    value: function addModule(name) {
      var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
      if (name === 'toolbar') {
        this.extendToolbar(module);
      }
      return module;
    }
  }, {
    key: 'buildButtons',
    value: function buildButtons(buttons, icons) {
      buttons.forEach(function (button) {
        var className = button.getAttribute('class') || '';
        className.split(/\s+/).forEach(function (name) {
          if (!name.startsWith('ql-')) return;
          name = name.slice('ql-'.length);
          if (icons[name] == null) return;
          if (name === 'direction') {
            button.innerHTML = icons[name][''] + icons[name]['rtl'];
          } else if (typeof icons[name] === 'string') {
            button.innerHTML = icons[name];
          } else {
            var value = button.value || '';
            if (value != null && icons[name][value]) {
              button.innerHTML = icons[name][value];
            }
          }
        });
      });
    }
  }, {
    key: 'buildPickers',
    value: function buildPickers(selects, icons) {
      var _this2 = this;

      this.pickers = selects.map(function (select) {
        if (select.classList.contains('ql-align')) {
          if (select.querySelector('option') == null) {
            fillSelect(select, ALIGNS);
          }
          return new _iconPicker2.default(select, icons.align);
        } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
          var format = select.classList.contains('ql-background') ? 'background' : 'color';
          if (select.querySelector('option') == null) {
            fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
          }
          return new _colorPicker2.default(select, icons[format]);
        } else {
          if (select.querySelector('option') == null) {
            if (select.classList.contains('ql-font')) {
              fillSelect(select, FONTS);
            } else if (select.classList.contains('ql-header')) {
              fillSelect(select, HEADERS);
            } else if (select.classList.contains('ql-size')) {
              fillSelect(select, SIZES);
            }
          }
          return new _picker2.default(select);
        }
      });
      var update = function update() {
        _this2.pickers.forEach(function (picker) {
          picker.update();
        });
      };
      this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
    }
  }]);

  return BaseTheme;
}(_theme2.default);

BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        formula: function formula() {
          this.quill.theme.tooltip.edit('formula');
        },
        image: function image() {
          var _this3 = this;

          var fileInput = this.container.querySelector('input.ql-image[type=file]');
          if (fileInput == null) {
            fileInput = document.createElement('input');
            fileInput.setAttribute('type', 'file');
            fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
            fileInput.classList.add('ql-image');
            fileInput.addEventListener('change', function () {
              if (fileInput.files != null && fileInput.files[0] != null) {
                var reader = new FileReader();
                reader.onload = function (e) {
                  var range = _this3.quill.getSelection(true);
                  _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);
                  _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                  fileInput.value = "";
                };
                reader.readAsDataURL(fileInput.files[0]);
              }
            });
            this.container.appendChild(fileInput);
          }
          fileInput.click();
        },
        video: function video() {
          this.quill.theme.tooltip.edit('video');
        }
      }
    }
  }
});

var BaseTooltip = function (_Tooltip) {
  _inherits(BaseTooltip, _Tooltip);

  function BaseTooltip(quill, boundsContainer) {
    _classCallCheck(this, BaseTooltip);

    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));

    _this4.textbox = _this4.root.querySelector('input[type="text"]');
    _this4.listen();
    return _this4;
  }

  _createClass(BaseTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this5 = this;

      this.textbox.addEventListener('keydown', function (event) {
        if (_keyboard2.default.match(event, 'enter')) {
          _this5.save();
          event.preventDefault();
        } else if (_keyboard2.default.match(event, 'escape')) {
          _this5.cancel();
          event.preventDefault();
        }
      });
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this.hide();
    }
  }, {
    key: 'edit',
    value: function edit() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
      var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this.root.classList.remove('ql-hidden');
      this.root.classList.add('ql-editing');
      if (preview != null) {
        this.textbox.value = preview;
      } else if (mode !== this.root.getAttribute('data-mode')) {
        this.textbox.value = '';
      }
      this.position(this.quill.getBounds(this.quill.selection.savedRange));
      this.textbox.select();
      this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
      this.root.setAttribute('data-mode', mode);
    }
  }, {
    key: 'restoreFocus',
    value: function restoreFocus() {
      var scrollTop = this.quill.scrollingContainer.scrollTop;
      this.quill.focus();
      this.quill.scrollingContainer.scrollTop = scrollTop;
    }
  }, {
    key: 'save',
    value: function save() {
      var value = this.textbox.value;
      switch (this.root.getAttribute('data-mode')) {
        case 'link':
          {
            var scrollTop = this.quill.root.scrollTop;
            if (this.linkRange) {
              this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
              delete this.linkRange;
            } else {
              this.restoreFocus();
              this.quill.format('link', value, _emitter2.default.sources.USER);
            }
            this.quill.root.scrollTop = scrollTop;
            break;
          }
        case 'video':
          {
            value = extractVideoUrl(value);
          } // eslint-disable-next-line no-fallthrough
        case 'formula':
          {
            if (!value) break;
            var range = this.quill.getSelection(true);
            if (range != null) {
              var index = range.index + range.length;
              this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
              if (this.root.getAttribute('data-mode') === 'formula') {
                this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
              }
              this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
            }
            break;
          }
      }
      this.textbox.value = '';
      this.hide();
    }
  }]);

  return BaseTooltip;
}(_tooltip2.default);

function extractVideoUrl(url) {
  var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
  if (match) {
    return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
  }
  if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
    // eslint-disable-line no-cond-assign
    return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
  }
  return url;
}

function fillSelect(select, values) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  values.forEach(function (value) {
    var option = document.createElement('option');
    if (value === defaultValue) {
      option.setAttribute('selected', 'selected');
    } else {
      option.setAttribute('value', value);
    }
    select.appendChild(option);
  });
}

exports.BaseTooltip = BaseTooltip;
exports.default = BaseTheme;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        this.head = this.tail = null;
        this.length = 0;
    }
    LinkedList.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        this.insertBefore(nodes[0], null);
        if (nodes.length > 1) {
            this.append.apply(this, nodes.slice(1));
        }
    };
    LinkedList.prototype.contains = function (node) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            if (cur === node)
                return true;
        }
        return false;
    };
    LinkedList.prototype.insertBefore = function (node, refNode) {
        if (!node)
            return;
        node.next = refNode;
        if (refNode != null) {
            node.prev = refNode.prev;
            if (refNode.prev != null) {
                refNode.prev.next = node;
            }
            refNode.prev = node;
            if (refNode === this.head) {
                this.head = node;
            }
        }
        else if (this.tail != null) {
            this.tail.next = node;
            node.prev = this.tail;
            this.tail = node;
        }
        else {
            node.prev = null;
            this.head = this.tail = node;
        }
        this.length += 1;
    };
    LinkedList.prototype.offset = function (target) {
        var index = 0, cur = this.head;
        while (cur != null) {
            if (cur === target)
                return index;
            index += cur.length();
            cur = cur.next;
        }
        return -1;
    };
    LinkedList.prototype.remove = function (node) {
        if (!this.contains(node))
            return;
        if (node.prev != null)
            node.prev.next = node.next;
        if (node.next != null)
            node.next.prev = node.prev;
        if (node === this.head)
            this.head = node.next;
        if (node === this.tail)
            this.tail = node.prev;
        this.length -= 1;
    };
    LinkedList.prototype.iterator = function (curNode) {
        if (curNode === void 0) { curNode = this.head; }
        // TODO use yield when we can
        return function () {
            var ret = curNode;
            if (curNode != null)
                curNode = curNode.next;
            return ret;
        };
    };
    LinkedList.prototype.find = function (index, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        var cur, next = this.iterator();
        while ((cur = next())) {
            var length = cur.length();
            if (index < length ||
                (inclusive && index === length && (cur.next == null || cur.next.length() !== 0))) {
                return [cur, index];
            }
            index -= length;
        }
        return [null, 0];
    };
    LinkedList.prototype.forEach = function (callback) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            callback(cur);
        }
    };
    LinkedList.prototype.forEachAt = function (index, length, callback) {
        if (length <= 0)
            return;
        var _a = this.find(index), startNode = _a[0], offset = _a[1];
        var cur, curIndex = index - offset, next = this.iterator(startNode);
        while ((cur = next()) && curIndex < index + length) {
            var curLength = cur.length();
            if (index > curIndex) {
                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
            }
            else {
                callback(cur, 0, Math.min(curLength, index + length - curIndex));
            }
            curIndex += curLength;
        }
    };
    LinkedList.prototype.map = function (callback) {
        return this.reduce(function (memo, cur) {
            memo.push(callback(cur));
            return memo;
        }, []);
    };
    LinkedList.prototype.reduce = function (callback, memo) {
        var cur, next = this.iterator();
        while ((cur = next())) {
            memo = callback(memo, cur);
        }
        return memo;
    };
    return LinkedList;
}());
exports.default = LinkedList;


/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_492525__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var container_1 = __nested_webpack_require_492525__(17);
var Registry = __nested_webpack_require_492525__(1);
var OBSERVER_CONFIG = {
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true,
};
var MAX_OPTIMIZE_ITERATIONS = 100;
var ScrollBlot = /** @class */ (function (_super) {
    __extends(ScrollBlot, _super);
    function ScrollBlot(node) {
        var _this = _super.call(this, node) || this;
        _this.scroll = _this;
        _this.observer = new MutationObserver(function (mutations) {
            _this.update(mutations);
        });
        _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
        _this.attach();
        return _this;
    }
    ScrollBlot.prototype.detach = function () {
        _super.prototype.detach.call(this);
        this.observer.disconnect();
    };
    ScrollBlot.prototype.deleteAt = function (index, length) {
        this.update();
        if (index === 0 && length === this.length()) {
            this.children.forEach(function (child) {
                child.remove();
            });
        }
        else {
            _super.prototype.deleteAt.call(this, index, length);
        }
    };
    ScrollBlot.prototype.formatAt = function (index, length, name, value) {
        this.update();
        _super.prototype.formatAt.call(this, index, length, name, value);
    };
    ScrollBlot.prototype.insertAt = function (index, value, def) {
        this.update();
        _super.prototype.insertAt.call(this, index, value, def);
    };
    ScrollBlot.prototype.optimize = function (mutations, context) {
        var _this = this;
        if (mutations === void 0) { mutations = []; }
        if (context === void 0) { context = {}; }
        _super.prototype.optimize.call(this, context);
        // We must modify mutations directly, cannot make copy and then modify
        var records = [].slice.call(this.observer.takeRecords());
        // Array.push currently seems to be implemented by a non-tail recursive function
        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
        while (records.length > 0)
            mutations.push(records.pop());
        // TODO use WeakMap
        var mark = function (blot, markParent) {
            if (markParent === void 0) { markParent = true; }
            if (blot == null || blot === _this)
                return;
            if (blot.domNode.parentNode == null)
                return;
            // @ts-ignore
            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [];
            }
            if (markParent)
                mark(blot.parent);
        };
        var optimize = function (blot) {
            // Post-order traversal
            if (
            // @ts-ignore
            blot.domNode[Registry.DATA_KEY] == null ||
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations == null) {
                return;
            }
            if (blot instanceof container_1.default) {
                blot.children.forEach(optimize);
            }
            blot.optimize(context);
        };
        var remaining = mutations;
        for (var i = 0; remaining.length > 0; i += 1) {
            if (i >= MAX_OPTIMIZE_ITERATIONS) {
                throw new Error('[Parchment] Maximum optimize iterations reached');
            }
            remaining.forEach(function (mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null)
                    return;
                if (blot.domNode === mutation.target) {
                    if (mutation.type === 'childList') {
                        mark(Registry.find(mutation.previousSibling, false));
                        [].forEach.call(mutation.addedNodes, function (node) {
                            var child = Registry.find(node, false);
                            mark(child, false);
                            if (child instanceof container_1.default) {
                                child.children.forEach(function (grandChild) {
                                    mark(grandChild, false);
                                });
                            }
                        });
                    }
                    else if (mutation.type === 'attributes') {
                        mark(blot.prev);
                    }
                }
                mark(blot);
            });
            this.children.forEach(optimize);
            remaining = [].slice.call(this.observer.takeRecords());
            records = remaining.slice();
            while (records.length > 0)
                mutations.push(records.pop());
        }
    };
    ScrollBlot.prototype.update = function (mutations, context) {
        var _this = this;
        if (context === void 0) { context = {}; }
        mutations = mutations || this.observer.takeRecords();
        // TODO use WeakMap
        mutations
            .map(function (mutation) {
            var blot = Registry.find(mutation.target, true);
            if (blot == null)
                return null;
            // @ts-ignore
            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                return blot;
            }
            else {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                return null;
            }
        })
            .forEach(function (blot) {
            if (blot == null ||
                blot === _this ||
                //@ts-ignore
                blot.domNode[Registry.DATA_KEY] == null)
                return;
            // @ts-ignore
            blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
        });
        // @ts-ignore
        if (this.domNode[Registry.DATA_KEY].mutations != null) {
            // @ts-ignore
            _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
        }
        this.optimize(mutations, context);
    };
    ScrollBlot.blotName = 'scroll';
    ScrollBlot.defaultChild = 'block';
    ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
    ScrollBlot.tagName = 'DIV';
    return ScrollBlot;
}(container_1.default));
exports.default = ScrollBlot;


/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_499624__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = __nested_webpack_require_499624__(18);
var Registry = __nested_webpack_require_499624__(1);
// Shallow object comparison
function isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
        return false;
    // @ts-ignore
    for (var prop in obj1) {
        // @ts-ignore
        if (obj1[prop] !== obj2[prop])
            return false;
    }
    return true;
}
var InlineBlot = /** @class */ (function (_super) {
    __extends(InlineBlot, _super);
    function InlineBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InlineBlot.formats = function (domNode) {
        if (domNode.tagName === InlineBlot.tagName)
            return undefined;
        return _super.formats.call(this, domNode);
    };
    InlineBlot.prototype.format = function (name, value) {
        var _this = this;
        if (name === this.statics.blotName && !value) {
            this.children.forEach(function (child) {
                if (!(child instanceof format_1.default)) {
                    child = child.wrap(InlineBlot.blotName, true);
                }
                _this.attributes.copy(child);
            });
            this.unwrap();
        }
        else {
            _super.prototype.format.call(this, name, value);
        }
    };
    InlineBlot.prototype.formatAt = function (index, length, name, value) {
        if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
            var blot = this.isolate(index, length);
            blot.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    InlineBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        var formats = this.formats();
        if (Object.keys(formats).length === 0) {
            return this.unwrap(); // unformatted span
        }
        var next = this.next;
        if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
            next.moveChildren(this);
            next.remove();
        }
    };
    InlineBlot.blotName = 'inline';
    InlineBlot.scope = Registry.Scope.INLINE_BLOT;
    InlineBlot.tagName = 'SPAN';
    return InlineBlot;
}(format_1.default));
exports.default = InlineBlot;


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_502601__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var format_1 = __nested_webpack_require_502601__(18);
var Registry = __nested_webpack_require_502601__(1);
var BlockBlot = /** @class */ (function (_super) {
    __extends(BlockBlot, _super);
    function BlockBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BlockBlot.formats = function (domNode) {
        var tagName = Registry.query(BlockBlot.blotName).tagName;
        if (domNode.tagName === tagName)
            return undefined;
        return _super.formats.call(this, domNode);
    };
    BlockBlot.prototype.format = function (name, value) {
        if (Registry.query(name, Registry.Scope.BLOCK) == null) {
            return;
        }
        else if (name === this.statics.blotName && !value) {
            this.replaceWith(BlockBlot.blotName);
        }
        else {
            _super.prototype.format.call(this, name, value);
        }
    };
    BlockBlot.prototype.formatAt = function (index, length, name, value) {
        if (Registry.query(name, Registry.Scope.BLOCK) != null) {
            this.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    BlockBlot.prototype.insertAt = function (index, value, def) {
        if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
            // Insert text or inline
            _super.prototype.insertAt.call(this, index, value, def);
        }
        else {
            var after = this.split(index);
            var blot = Registry.create(value, def);
            after.parent.insertBefore(blot, after);
        }
    };
    BlockBlot.prototype.update = function (mutations, context) {
        if (navigator.userAgent.match(/Trident/)) {
            this.build();
        }
        else {
            _super.prototype.update.call(this, mutations, context);
        }
    };
    BlockBlot.blotName = 'block';
    BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
    BlockBlot.tagName = 'P';
    return BlockBlot;
}(format_1.default));
exports.default = BlockBlot;


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_505294__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var leaf_1 = __nested_webpack_require_505294__(19);
var EmbedBlot = /** @class */ (function (_super) {
    __extends(EmbedBlot, _super);
    function EmbedBlot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EmbedBlot.formats = function (domNode) {
        return undefined;
    };
    EmbedBlot.prototype.format = function (name, value) {
        // super.formatAt wraps, which is what we want in general,
        // but this allows subclasses to overwrite for formats
        // that just apply to particular embeds
        _super.prototype.formatAt.call(this, 0, this.length(), name, value);
    };
    EmbedBlot.prototype.formatAt = function (index, length, name, value) {
        if (index === 0 && length === this.length()) {
            this.format(name, value);
        }
        else {
            _super.prototype.formatAt.call(this, index, length, name, value);
        }
    };
    EmbedBlot.prototype.formats = function () {
        return this.statics.formats(this.domNode);
    };
    return EmbedBlot;
}(leaf_1.default));
exports.default = EmbedBlot;


/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_507020__) {

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var leaf_1 = __nested_webpack_require_507020__(19);
var Registry = __nested_webpack_require_507020__(1);
var TextBlot = /** @class */ (function (_super) {
    __extends(TextBlot, _super);
    function TextBlot(node) {
        var _this = _super.call(this, node) || this;
        _this.text = _this.statics.value(_this.domNode);
        return _this;
    }
    TextBlot.create = function (value) {
        return document.createTextNode(value);
    };
    TextBlot.value = function (domNode) {
        var text = domNode.data;
        // @ts-ignore
        if (text['normalize'])
            text = text['normalize']();
        return text;
    };
    TextBlot.prototype.deleteAt = function (index, length) {
        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
    };
    TextBlot.prototype.index = function (node, offset) {
        if (this.domNode === node) {
            return offset;
        }
        return -1;
    };
    TextBlot.prototype.insertAt = function (index, value, def) {
        if (def == null) {
            this.text = this.text.slice(0, index) + value + this.text.slice(index);
            this.domNode.data = this.text;
        }
        else {
            _super.prototype.insertAt.call(this, index, value, def);
        }
    };
    TextBlot.prototype.length = function () {
        return this.text.length;
    };
    TextBlot.prototype.optimize = function (context) {
        _super.prototype.optimize.call(this, context);
        this.text = this.statics.value(this.domNode);
        if (this.text.length === 0) {
            this.remove();
        }
        else if (this.next instanceof TextBlot && this.next.prev === this) {
            this.insertAt(this.length(), this.next.value());
            this.next.remove();
        }
    };
    TextBlot.prototype.position = function (index, inclusive) {
        return [this.domNode, index];
    };
    TextBlot.prototype.split = function (index, force) {
        if (force === void 0) { force = false; }
        if (!force) {
            if (index === 0)
                return this;
            if (index === this.length())
                return this.next;
        }
        var after = Registry.create(this.domNode.splitText(index));
        this.parent.insertBefore(after, this.next);
        this.text = this.statics.value(this.domNode);
        return after;
    };
    TextBlot.prototype.update = function (mutations, context) {
        var _this = this;
        if (mutations.some(function (mutation) {
            return mutation.type === 'characterData' && mutation.target === _this.domNode;
        })) {
            this.text = this.statics.value(this.domNode);
        }
    };
    TextBlot.prototype.value = function () {
        return this.text;
    };
    TextBlot.blotName = 'text';
    TextBlot.scope = Registry.Scope.INLINE_BLOT;
    return TextBlot;
}(leaf_1.default));
exports.default = TextBlot;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {


var elem = document.createElement('div');
elem.classList.toggle('test-class', false);
if (elem.classList.contains('test-class')) {
  var _toggle = DOMTokenList.prototype.toggle;
  DOMTokenList.prototype.toggle = function (token, force) {
    if (arguments.length > 1 && !this.contains(token) === !force) {
      return force;
    } else {
      return _toggle.call(this, token);
    }
  };
}

if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.substr(position, searchString.length) === searchString;
  };
}

if (!String.prototype.endsWith) {
  String.prototype.endsWith = function (searchString, position) {
    var subjectString = this.toString();
    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}

if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, "find", {
    value: function value(predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return value;
        }
      }
      return undefined;
    }
  });
}

document.addEventListener("DOMContentLoaded", function () {
  // Disable resizing in Firefox
  document.execCommand("enableObjectResizing", false, false);
  // Disable automatic linkifying in IE11
  document.execCommand("autoUrlDetect", false, false);
});

/***/ }),
/* 51 */
/***/ (function(module, exports) {

/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int} cursor_pos Expected edit position in text1 (optional)
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos) {
  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  // Check cursor_pos within bounds
  if (cursor_pos < 0 || text1.length < cursor_pos) {
    cursor_pos = null;
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs);
  if (cursor_pos != null) {
    diffs = fix_cursor(diffs, cursor_pos);
  }
  diffs = fix_emoji(diffs);
  return diffs;
}

/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
}

/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}

/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
}

/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}

/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}

/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = diff_commonPrefix(longtext.substring(i),
                                           shorttext.substring(j));
      var suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                           shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}

/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 */
function diff_cleanupMerge(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}

var diff = diff_main;
diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;

module.exports = diff;

/*
 * Modify a diff such that the cursor position points to the start of a change:
 * E.g.
 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
 */
function cursor_normalize_diff (diffs, cursor_pos) {
  if (cursor_pos === 0) {
    return [DIFF_EQUAL, diffs];
  }
  for (var current_pos = 0, i = 0; i < diffs.length; i++) {
    var d = diffs[i];
    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
      var next_pos = current_pos + d[1].length;
      if (cursor_pos === next_pos) {
        return [i + 1, diffs];
      } else if (cursor_pos < next_pos) {
        // copy to prevent side effects
        diffs = diffs.slice();
        // split d into two diff changes
        var split_pos = cursor_pos - current_pos;
        var d_left = [d[0], d[1].slice(0, split_pos)];
        var d_right = [d[0], d[1].slice(split_pos)];
        diffs.splice(i, 1, d_left, d_right);
        return [i + 1, diffs];
      } else {
        current_pos = next_pos;
      }
    }
  }
  throw new Error('cursor_pos is out of bounds!')
}

/*
 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
 *
 * Case 1)
 *   Check if a naive shift is possible:
 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
 * Case 2)
 *   Check if the following shifts are possible:
 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
 *         ^            ^
 *         d          d_next
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} Array of diff tuples
 */
function fix_cursor (diffs, cursor_pos) {
  var norm = cursor_normalize_diff(diffs, cursor_pos);
  var ndiffs = norm[1];
  var cursor_pointer = norm[0];
  var d = ndiffs[cursor_pointer];
  var d_next = ndiffs[cursor_pointer + 1];

  if (d == null) {
    // Text was deleted from end of original string,
    // cursor is now out of bounds in new string
    return diffs;
  } else if (d[0] !== DIFF_EQUAL) {
    // A modification happened at the cursor location.
    // This is the expected outcome, so we can return the original diff.
    return diffs;
  } else {
    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
      // Case 1)
      // It is possible to perform a naive shift
      ndiffs.splice(cursor_pointer, 2, d_next, d);
      return merge_tuples(ndiffs, cursor_pointer, 2)
    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
      // Case 2)
      // d[1] is a prefix of d_next[1]
      // We can assume that d_next[0] !== 0, since d[0] === 0
      // Shift edit locations..
      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
      var suffix = d_next[1].slice(d[1].length);
      if (suffix.length > 0) {
        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
      }
      return merge_tuples(ndiffs, cursor_pointer, 3)
    } else {
      // Not possible to perform any modification
      return diffs;
    }
  }
}

/*
 * Check diff did not split surrogate pairs.
 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
 *     '\uD83D\uDC36' === '', '\uD83D\uDC2F' === ''
 *
 * @param {Array} diffs Array of diff tuples
 * @return {Array} Array of diff tuples
 */
function fix_emoji (diffs) {
  var compact = false;
  var starts_with_pair_end = function(str) {
    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
  };
  var ends_with_pair_start = function(str) {
    return str.charCodeAt(str.length-1) >= 0xD800 && str.charCodeAt(str.length-1) <= 0xDBFF;
  };
  for (var i = 2; i < diffs.length; i += 1) {
    if (diffs[i-2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i-2][1]) &&
        diffs[i-1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i-1][1]) &&
        diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
      compact = true;

      diffs[i-1][1] = diffs[i-2][1].slice(-1) + diffs[i-1][1];
      diffs[i][1] = diffs[i-2][1].slice(-1) + diffs[i][1];

      diffs[i-2][1] = diffs[i-2][1].slice(0, -1);
    }
  }
  if (!compact) {
    return diffs;
  }
  var fixed_diffs = [];
  for (var i = 0; i < diffs.length; i += 1) {
    if (diffs[i][1].length > 0) {
      fixed_diffs.push(diffs[i]);
    }
  }
  return fixed_diffs;
}

/*
 * Try to merge tuples with their neigbors in a given range.
 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
 *
 * @param {Array} diffs Array of diff tuples.
 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
 * @param {Int} length Number of consecutive elements to check.
 * @return {Array} Array of merged diff tuples.
 */
function merge_tuples (diffs, start, length) {
  // Check from (start-1) to (start+length).
  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
    if (i + 1 < diffs.length) {
      var left_d = diffs[i];
      var right_d = diffs[i+1];
      if (left_d[0] === right_d[1]) {
        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
      }
    }
  }
  return diffs;
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 53 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}
exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @api private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {Mixed} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {Array|Boolean}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn The listener function.
 * @param {Mixed} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
  else if (!this._events[evt].fn) this._events[evt].push(listener);
  else this._events[evt] = [this._events[evt], listener];

  return this;
};

/**
 * Remove the listeners of a given event.
 *
 * @param {String|Symbol} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {Mixed} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
         listeners.fn === fn
      && (!once || listeners.once)
      && (!context || listeners.context === context)
    ) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
           listeners[i].fn !== fn
        || (once && !listeners[i].once)
        || (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else if (--this._eventsCount === 0) this._events = new Events();
    else delete this._events[evt];
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {String|Symbol} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) {
      if (--this._eventsCount === 0) this._events = new Events();
      else delete this._events[evt];
    }
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_547966__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend2 = __nested_webpack_require_547966__(3);

var _extend3 = _interopRequireDefault(_extend2);

var _quillDelta = __nested_webpack_require_547966__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __nested_webpack_require_547966__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_547966__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __nested_webpack_require_547966__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __nested_webpack_require_547966__(9);

var _module2 = _interopRequireDefault(_module);

var _align = __nested_webpack_require_547966__(36);

var _background = __nested_webpack_require_547966__(37);

var _code = __nested_webpack_require_547966__(13);

var _code2 = _interopRequireDefault(_code);

var _color = __nested_webpack_require_547966__(26);

var _direction = __nested_webpack_require_547966__(38);

var _font = __nested_webpack_require_547966__(39);

var _size = __nested_webpack_require_547966__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:clipboard');

var DOM_KEY = '__ql-matcher';

var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];

var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
  memo[attr.keyName] = attr;
  return memo;
}, {});

var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
  memo[attr.keyName] = attr;
  return memo;
}, {});

var Clipboard = function (_Module) {
  _inherits(Clipboard, _Module);

  function Clipboard(quill, options) {
    _classCallCheck(this, Clipboard);

    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));

    _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
    _this.container = _this.quill.addContainer('ql-clipboard');
    _this.container.setAttribute('contenteditable', true);
    _this.container.setAttribute('tabindex', -1);
    _this.matchers = [];
    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          selector = _ref2[0],
          matcher = _ref2[1];

      if (!options.matchVisual && matcher === matchSpacing) return;
      _this.addMatcher(selector, matcher);
    });
    return _this;
  }

  _createClass(Clipboard, [{
    key: 'addMatcher',
    value: function addMatcher(selector, matcher) {
      this.matchers.push([selector, matcher]);
    }
  }, {
    key: 'convert',
    value: function convert(html) {
      if (typeof html === 'string') {
        this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags
        return this.convert();
      }
      var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
      if (formats[_code2.default.blotName]) {
        var text = this.container.innerText;
        this.container.innerHTML = '';
        return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
      }

      var _prepareMatching = this.prepareMatching(),
          _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
          elementMatchers = _prepareMatching2[0],
          textMatchers = _prepareMatching2[1];

      var delta = traverse(this.container, elementMatchers, textMatchers);
      // Remove trailing newline
      if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
        delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
      }
      debug.log('convert', this.container.innerHTML, delta);
      this.container.innerHTML = '';
      return delta;
    }
  }, {
    key: 'dangerouslyPasteHTML',
    value: function dangerouslyPasteHTML(index, html) {
      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;

      if (typeof index === 'string') {
        this.quill.setContents(this.convert(index), html);
        this.quill.setSelection(0, _quill2.default.sources.SILENT);
      } else {
        var paste = this.convert(html);
        this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
        this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
      }
    }
  }, {
    key: 'onPaste',
    value: function onPaste(e) {
      var _this2 = this;

      if (e.defaultPrevented || !this.quill.isEnabled()) return;
      var range = this.quill.getSelection();
      var delta = new _quillDelta2.default().retain(range.index);
      var scrollTop = this.quill.scrollingContainer.scrollTop;
      this.container.focus();
      this.quill.selection.update(_quill2.default.sources.SILENT);
      setTimeout(function () {
        delta = delta.concat(_this2.convert()).delete(range.length);
        _this2.quill.updateContents(delta, _quill2.default.sources.USER);
        // range.length contributes to delta.length()
        _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
        _this2.quill.scrollingContainer.scrollTop = scrollTop;
        _this2.quill.focus();
      }, 1);
    }
  }, {
    key: 'prepareMatching',
    value: function prepareMatching() {
      var _this3 = this;

      var elementMatchers = [],
          textMatchers = [];
      this.matchers.forEach(function (pair) {
        var _pair = _slicedToArray(pair, 2),
            selector = _pair[0],
            matcher = _pair[1];

        switch (selector) {
          case Node.TEXT_NODE:
            textMatchers.push(matcher);
            break;
          case Node.ELEMENT_NODE:
            elementMatchers.push(matcher);
            break;
          default:
            [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
              // TODO use weakmap
              node[DOM_KEY] = node[DOM_KEY] || [];
              node[DOM_KEY].push(matcher);
            });
            break;
        }
      });
      return [elementMatchers, textMatchers];
    }
  }]);

  return Clipboard;
}(_module2.default);

Clipboard.DEFAULTS = {
  matchers: [],
  matchVisual: true
};

function applyFormat(delta, format, value) {
  if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
    return Object.keys(format).reduce(function (delta, key) {
      return applyFormat(delta, key, format[key]);
    }, delta);
  } else {
    return delta.reduce(function (delta, op) {
      if (op.attributes && op.attributes[format]) {
        return delta.push(op);
      } else {
        return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
      }
    }, new _quillDelta2.default());
  }
}

function computeStyle(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) return {};
  var DOM_KEY = '__ql-computed-style';
  return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
}

function deltaEndsWith(delta, text) {
  var endText = "";
  for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
    var op = delta.ops[i];
    if (typeof op.insert !== 'string') break;
    endText = op.insert + endText;
  }
  return endText.slice(-1 * text.length) === text;
}

function isLine(node) {
  if (node.childNodes.length === 0) return false; // Exclude embed blocks
  var style = computeStyle(node);
  return ['block', 'list-item'].indexOf(style.display) > -1;
}

function traverse(node, elementMatchers, textMatchers) {
  // Post-order
  if (node.nodeType === node.TEXT_NODE) {
    return textMatchers.reduce(function (delta, matcher) {
      return matcher(node, delta);
    }, new _quillDelta2.default());
  } else if (node.nodeType === node.ELEMENT_NODE) {
    return [].reduce.call(node.childNodes || [], function (delta, childNode) {
      var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
      if (childNode.nodeType === node.ELEMENT_NODE) {
        childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
          return matcher(childNode, childrenDelta);
        }, childrenDelta);
        childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
          return matcher(childNode, childrenDelta);
        }, childrenDelta);
      }
      return delta.concat(childrenDelta);
    }, new _quillDelta2.default());
  } else {
    return new _quillDelta2.default();
  }
}

function matchAlias(format, node, delta) {
  return applyFormat(delta, format, true);
}

function matchAttributor(node, delta) {
  var attributes = _parchment2.default.Attributor.Attribute.keys(node);
  var classes = _parchment2.default.Attributor.Class.keys(node);
  var styles = _parchment2.default.Attributor.Style.keys(node);
  var formats = {};
  attributes.concat(classes).concat(styles).forEach(function (name) {
    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
    if (attr != null) {
      formats[attr.attrName] = attr.value(node);
      if (formats[attr.attrName]) return;
    }
    attr = ATTRIBUTE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      formats[attr.attrName] = attr.value(node) || undefined;
    }
    attr = STYLE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      attr = STYLE_ATTRIBUTORS[name];
      formats[attr.attrName] = attr.value(node) || undefined;
    }
  });
  if (Object.keys(formats).length > 0) {
    delta = applyFormat(delta, formats);
  }
  return delta;
}

function matchBlot(node, delta) {
  var match = _parchment2.default.query(node);
  if (match == null) return delta;
  if (match.prototype instanceof _parchment2.default.Embed) {
    var embed = {};
    var value = match.value(node);
    if (value != null) {
      embed[match.blotName] = value;
      delta = new _quillDelta2.default().insert(embed, match.formats(node));
    }
  } else if (typeof match.formats === 'function') {
    delta = applyFormat(delta, match.blotName, match.formats(node));
  }
  return delta;
}

function matchBreak(node, delta) {
  if (!deltaEndsWith(delta, '\n')) {
    delta.insert('\n');
  }
  return delta;
}

function matchIgnore() {
  return new _quillDelta2.default();
}

function matchIndent(node, delta) {
  var match = _parchment2.default.query(node);
  if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
    return delta;
  }
  var indent = -1,
      parent = node.parentNode;
  while (!parent.classList.contains('ql-clipboard')) {
    if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
      indent += 1;
    }
    parent = parent.parentNode;
  }
  if (indent <= 0) return delta;
  return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent: indent }));
}

function matchNewline(node, delta) {
  if (!deltaEndsWith(delta, '\n')) {
    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
      delta.insert('\n');
    }
  }
  return delta;
}

function matchSpacing(node, delta) {
  if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
      delta.insert('\n');
    }
  }
  return delta;
}

function matchStyles(node, delta) {
  var formats = {};
  var style = node.style || {};
  if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
    formats.italic = true;
  }
  if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
    formats.bold = true;
  }
  if (Object.keys(formats).length > 0) {
    delta = applyFormat(delta, formats);
  }
  if (parseFloat(style.textIndent || 0) > 0) {
    // Could be 0.5in
    delta = new _quillDelta2.default().insert('\t').concat(delta);
  }
  return delta;
}

function matchText(node, delta) {
  var text = node.data;
  // Word represents empty line with <o:p>&nbsp;</o:p>
  if (node.parentNode.tagName === 'O:P') {
    return delta.insert(text.trim());
  }
  if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
    return delta;
  }
  if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
    // eslint-disable-next-line func-style
    var replacer = function replacer(collapse, match) {
      match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;
      return match.length < 1 && collapse ? ' ' : match;
    };
    text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
    text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace
    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
      text = text.replace(/^\s+/, replacer.bind(replacer, false));
    }
    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
      text = text.replace(/\s+$/, replacer.bind(replacer, false));
    }
  }
  return delta.insert(text);
}

exports.default = Clipboard;
exports.matchAttributor = matchAttributor;
exports.matchBlot = matchBlot;
exports.matchNewline = matchNewline;
exports.matchSpacing = matchSpacing;
exports.matchText = matchText;

/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_564809__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __nested_webpack_require_564809__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Bold = function (_Inline) {
  _inherits(Bold, _Inline);

  function Bold() {
    _classCallCheck(this, Bold);

    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
  }

  _createClass(Bold, [{
    key: 'optimize',
    value: function optimize(context) {
      _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
      if (this.domNode.tagName !== this.statics.tagName[0]) {
        this.replaceWith(this.statics.blotName);
      }
    }
  }], [{
    key: 'create',
    value: function create() {
      return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
    }
  }, {
    key: 'formats',
    value: function formats() {
      return true;
    }
  }]);

  return Bold;
}(_inline2.default);

Bold.blotName = 'bold';
Bold.tagName = ['STRONG', 'B'];

exports.default = Bold;

/***/ }),
/* 57 */
/***/ (function(module, exports, __nested_webpack_require_568022__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addControls = exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _quillDelta = __nested_webpack_require_568022__(2);

var _quillDelta2 = _interopRequireDefault(_quillDelta);

var _parchment = __nested_webpack_require_568022__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_568022__(5);

var _quill2 = _interopRequireDefault(_quill);

var _logger = __nested_webpack_require_568022__(10);

var _logger2 = _interopRequireDefault(_logger);

var _module = __nested_webpack_require_568022__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _logger2.default)('quill:toolbar');

var Toolbar = function (_Module) {
  _inherits(Toolbar, _Module);

  function Toolbar(quill, options) {
    _classCallCheck(this, Toolbar);

    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));

    if (Array.isArray(_this.options.container)) {
      var container = document.createElement('div');
      addControls(container, _this.options.container);
      quill.container.parentNode.insertBefore(container, quill.container);
      _this.container = container;
    } else if (typeof _this.options.container === 'string') {
      _this.container = document.querySelector(_this.options.container);
    } else {
      _this.container = _this.options.container;
    }
    if (!(_this.container instanceof HTMLElement)) {
      var _ret;

      return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
    }
    _this.container.classList.add('ql-toolbar');
    _this.controls = [];
    _this.handlers = {};
    Object.keys(_this.options.handlers).forEach(function (format) {
      _this.addHandler(format, _this.options.handlers[format]);
    });
    [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
      _this.attach(input);
    });
    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
      if (type === _quill2.default.events.SELECTION_CHANGE) {
        _this.update(range);
      }
    });
    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
      var _this$quill$selection = _this.quill.selection.getRange(),
          _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
          range = _this$quill$selection2[0]; // quill.getSelection triggers update


      _this.update(range);
    });
    return _this;
  }

  _createClass(Toolbar, [{
    key: 'addHandler',
    value: function addHandler(format, handler) {
      this.handlers[format] = handler;
    }
  }, {
    key: 'attach',
    value: function attach(input) {
      var _this2 = this;

      var format = [].find.call(input.classList, function (className) {
        return className.indexOf('ql-') === 0;
      });
      if (!format) return;
      format = format.slice('ql-'.length);
      if (input.tagName === 'BUTTON') {
        input.setAttribute('type', 'button');
      }
      if (this.handlers[format] == null) {
        if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
          debug.warn('ignoring attaching to disabled format', format, input);
          return;
        }
        if (_parchment2.default.query(format) == null) {
          debug.warn('ignoring attaching to nonexistent format', format, input);
          return;
        }
      }
      var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
      input.addEventListener(eventName, function (e) {
        var value = void 0;
        if (input.tagName === 'SELECT') {
          if (input.selectedIndex < 0) return;
          var selected = input.options[input.selectedIndex];
          if (selected.hasAttribute('selected')) {
            value = false;
          } else {
            value = selected.value || false;
          }
        } else {
          if (input.classList.contains('ql-active')) {
            value = false;
          } else {
            value = input.value || !input.hasAttribute('value');
          }
          e.preventDefault();
        }
        _this2.quill.focus();

        var _quill$selection$getR = _this2.quill.selection.getRange(),
            _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
            range = _quill$selection$getR2[0];

        if (_this2.handlers[format] != null) {
          _this2.handlers[format].call(_this2, value);
        } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
          value = prompt('Enter ' + format);
          if (!value) return;
          _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
        } else {
          _this2.quill.format(format, value, _quill2.default.sources.USER);
        }
        _this2.update(range);
      });
      // TODO use weakmap
      this.controls.push([format, input]);
    }
  }, {
    key: 'update',
    value: function update(range) {
      var formats = range == null ? {} : this.quill.getFormat(range);
      this.controls.forEach(function (pair) {
        var _pair = _slicedToArray(pair, 2),
            format = _pair[0],
            input = _pair[1];

        if (input.tagName === 'SELECT') {
          var option = void 0;
          if (range == null) {
            option = null;
          } else if (formats[format] == null) {
            option = input.querySelector('option[selected]');
          } else if (!Array.isArray(formats[format])) {
            var value = formats[format];
            if (typeof value === 'string') {
              value = value.replace(/\"/g, '\\"');
            }
            option = input.querySelector('option[value="' + value + '"]');
          }
          if (option == null) {
            input.value = ''; // TODO make configurable?
            input.selectedIndex = -1;
          } else {
            option.selected = true;
          }
        } else {
          if (range == null) {
            input.classList.remove('ql-active');
          } else if (input.hasAttribute('value')) {
            // both being null should match (default values)
            // '1' should match with 1 (headers)
            var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
            input.classList.toggle('ql-active', isActive);
          } else {
            input.classList.toggle('ql-active', formats[format] != null);
          }
        }
      });
    }
  }]);

  return Toolbar;
}(_module2.default);

Toolbar.DEFAULTS = {};

function addButton(container, format, value) {
  var input = document.createElement('button');
  input.setAttribute('type', 'button');
  input.classList.add('ql-' + format);
  if (value != null) {
    input.value = value;
  }
  container.appendChild(input);
}

function addControls(container, groups) {
  if (!Array.isArray(groups[0])) {
    groups = [groups];
  }
  groups.forEach(function (controls) {
    var group = document.createElement('span');
    group.classList.add('ql-formats');
    controls.forEach(function (control) {
      if (typeof control === 'string') {
        addButton(group, control);
      } else {
        var format = Object.keys(control)[0];
        var value = control[format];
        if (Array.isArray(value)) {
          addSelect(group, format, value);
        } else {
          addButton(group, format, value);
        }
      }
    });
    container.appendChild(group);
  });
}

function addSelect(container, format, values) {
  var input = document.createElement('select');
  input.classList.add('ql-' + format);
  values.forEach(function (value) {
    var option = document.createElement('option');
    if (value !== false) {
      option.setAttribute('value', value);
    } else {
      option.setAttribute('selected', 'selected');
    }
    input.appendChild(option);
  });
  container.appendChild(input);
}

Toolbar.DEFAULTS = {
  container: null,
  handlers: {
    clean: function clean() {
      var _this3 = this;

      var range = this.quill.getSelection();
      if (range == null) return;
      if (range.length == 0) {
        var formats = this.quill.getFormat();
        Object.keys(formats).forEach(function (name) {
          // Clean functionality in existing apps only clean inline formats
          if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
            _this3.quill.format(name, false);
          }
        });
      } else {
        this.quill.removeFormat(range, _quill2.default.sources.USER);
      }
    },
    direction: function direction(value) {
      var align = this.quill.getFormat()['align'];
      if (value === 'rtl' && align == null) {
        this.quill.format('align', 'right', _quill2.default.sources.USER);
      } else if (!value && align === 'right') {
        this.quill.format('align', false, _quill2.default.sources.USER);
      }
      this.quill.format('direction', value, _quill2.default.sources.USER);
    },
    indent: function indent(value) {
      var range = this.quill.getSelection();
      var formats = this.quill.getFormat(range);
      var indent = parseInt(formats.indent || 0);
      if (value === '+1' || value === '-1') {
        var modifier = value === '+1' ? 1 : -1;
        if (formats.direction === 'rtl') modifier *= -1;
        this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
      }
    },
    link: function link(value) {
      if (value === true) {
        value = prompt('Enter link URL:');
      }
      this.quill.format('link', value, _quill2.default.sources.USER);
    },
    list: function list(value) {
      var range = this.quill.getSelection();
      var formats = this.quill.getFormat(range);
      if (value === 'check') {
        if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
          this.quill.format('list', false, _quill2.default.sources.USER);
        } else {
          this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
        }
      } else {
        this.quill.format('list', value, _quill2.default.sources.USER);
      }
    }
  }
};

exports.default = Toolbar;
exports.addControls = addControls;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";

/***/ }),
/* 59 */
/***/ (function(module, exports, __nested_webpack_require_581286__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _picker = __nested_webpack_require_581286__(28);

var _picker2 = _interopRequireDefault(_picker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorPicker = function (_Picker) {
  _inherits(ColorPicker, _Picker);

  function ColorPicker(select, label) {
    _classCallCheck(this, ColorPicker);

    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));

    _this.label.innerHTML = label;
    _this.container.classList.add('ql-color-picker');
    [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
      item.classList.add('ql-primary');
    });
    return _this;
  }

  _createClass(ColorPicker, [{
    key: 'buildItem',
    value: function buildItem(option) {
      var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
      item.style.backgroundColor = option.getAttribute('value') || '';
      return item;
    }
  }, {
    key: 'selectItem',
    value: function selectItem(item, trigger) {
      _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
      var colorLabel = this.label.querySelector('.ql-color-label');
      var value = item ? item.getAttribute('data-value') || '' : '';
      if (colorLabel) {
        if (colorLabel.tagName === 'line') {
          colorLabel.style.stroke = value;
        } else {
          colorLabel.style.fill = value;
        }
      }
    }
  }]);

  return ColorPicker;
}(_picker2.default);

exports.default = ColorPicker;

/***/ }),
/* 60 */
/***/ (function(module, exports, __nested_webpack_require_585082__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _picker = __nested_webpack_require_585082__(28);

var _picker2 = _interopRequireDefault(_picker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IconPicker = function (_Picker) {
  _inherits(IconPicker, _Picker);

  function IconPicker(select, icons) {
    _classCallCheck(this, IconPicker);

    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));

    _this.container.classList.add('ql-icon-picker');
    [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
      item.innerHTML = icons[item.getAttribute('data-value') || ''];
    });
    _this.defaultItem = _this.container.querySelector('.ql-selected');
    _this.selectItem(_this.defaultItem);
    return _this;
  }

  _createClass(IconPicker, [{
    key: 'selectItem',
    value: function selectItem(item, trigger) {
      _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
      item = item || this.defaultItem;
      this.label.innerHTML = item.innerHTML;
    }
  }]);

  return IconPicker;
}(_picker2.default);

exports.default = IconPicker;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = function () {
  function Tooltip(quill, boundsContainer) {
    var _this = this;

    _classCallCheck(this, Tooltip);

    this.quill = quill;
    this.boundsContainer = boundsContainer || document.body;
    this.root = quill.addContainer('ql-tooltip');
    this.root.innerHTML = this.constructor.TEMPLATE;
    if (this.quill.root === this.quill.scrollingContainer) {
      this.quill.root.addEventListener('scroll', function () {
        _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
      });
    }
    this.hide();
  }

  _createClass(Tooltip, [{
    key: 'hide',
    value: function hide() {
      this.root.classList.add('ql-hidden');
    }
  }, {
    key: 'position',
    value: function position(reference) {
      var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
      // root.scrollTop should be 0 if scrollContainer !== root
      var top = reference.bottom + this.quill.root.scrollTop;
      this.root.style.left = left + 'px';
      this.root.style.top = top + 'px';
      this.root.classList.remove('ql-flip');
      var containerBounds = this.boundsContainer.getBoundingClientRect();
      var rootBounds = this.root.getBoundingClientRect();
      var shift = 0;
      if (rootBounds.right > containerBounds.right) {
        shift = containerBounds.right - rootBounds.right;
        this.root.style.left = left + shift + 'px';
      }
      if (rootBounds.left < containerBounds.left) {
        shift = containerBounds.left - rootBounds.left;
        this.root.style.left = left + shift + 'px';
      }
      if (rootBounds.bottom > containerBounds.bottom) {
        var height = rootBounds.bottom - rootBounds.top;
        var verticalShift = reference.bottom - reference.top + height;
        this.root.style.top = top - verticalShift + 'px';
        this.root.classList.add('ql-flip');
      }
      return shift;
    }
  }, {
    key: 'show',
    value: function show() {
      this.root.classList.remove('ql-editing');
      this.root.classList.remove('ql-hidden');
    }
  }]);

  return Tooltip;
}();

exports.default = Tooltip;

/***/ }),
/* 62 */
/***/ (function(module, exports, __nested_webpack_require_591392__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend = __nested_webpack_require_591392__(3);

var _extend2 = _interopRequireDefault(_extend);

var _emitter = __nested_webpack_require_591392__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _base = __nested_webpack_require_591392__(43);

var _base2 = _interopRequireDefault(_base);

var _link = __nested_webpack_require_591392__(27);

var _link2 = _interopRequireDefault(_link);

var _selection = __nested_webpack_require_591392__(15);

var _icons = __nested_webpack_require_591392__(41);

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TOOLBAR_CONFIG = [[{ header: ['1', '2', '3', false] }], ['bold', 'italic', 'underline', 'link'], [{ list: 'ordered' }, { list: 'bullet' }], ['clean']];

var SnowTheme = function (_BaseTheme) {
  _inherits(SnowTheme, _BaseTheme);

  function SnowTheme(quill, options) {
    _classCallCheck(this, SnowTheme);

    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
      options.modules.toolbar.container = TOOLBAR_CONFIG;
    }

    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));

    _this.quill.container.classList.add('ql-snow');
    return _this;
  }

  _createClass(SnowTheme, [{
    key: 'extendToolbar',
    value: function extendToolbar(toolbar) {
      toolbar.container.classList.add('ql-snow');
      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
      this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
      if (toolbar.container.querySelector('.ql-link')) {
        this.quill.keyboard.addBinding({ key: 'K', shortKey: true }, function (range, context) {
          toolbar.handlers['link'].call(toolbar, !context.format.link);
        });
      }
    }
  }]);

  return SnowTheme;
}(_base2.default);

SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link: function link(value) {
          if (value) {
            var range = this.quill.getSelection();
            if (range == null || range.length == 0) return;
            var preview = this.quill.getText(range);
            if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
              preview = 'mailto:' + preview;
            }
            var tooltip = this.quill.theme.tooltip;
            tooltip.edit('link', preview);
          } else {
            this.quill.format('link', false);
          }
        }
      }
    }
  }
});

var SnowTooltip = function (_BaseTooltip) {
  _inherits(SnowTooltip, _BaseTooltip);

  function SnowTooltip(quill, bounds) {
    _classCallCheck(this, SnowTooltip);

    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));

    _this2.preview = _this2.root.querySelector('a.ql-preview');
    return _this2;
  }

  _createClass(SnowTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this3 = this;

      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
      this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
        if (_this3.root.classList.contains('ql-editing')) {
          _this3.save();
        } else {
          _this3.edit('link', _this3.preview.textContent);
        }
        event.preventDefault();
      });
      this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
        if (_this3.linkRange != null) {
          var range = _this3.linkRange;
          _this3.restoreFocus();
          _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
          delete _this3.linkRange;
        }
        event.preventDefault();
        _this3.hide();
      });
      this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
        if (range == null) return;
        if (range.length === 0 && source === _emitter2.default.sources.USER) {
          var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
              _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
              link = _quill$scroll$descend2[0],
              offset = _quill$scroll$descend2[1];

          if (link != null) {
            _this3.linkRange = new _selection.Range(range.index - offset, link.length());
            var preview = _link2.default.formats(link.domNode);
            _this3.preview.textContent = preview;
            _this3.preview.setAttribute('href', preview);
            _this3.show();
            _this3.position(_this3.quill.getBounds(_this3.linkRange));
            return;
          }
        } else {
          delete _this3.linkRange;
        }
        _this3.hide();
      });
    }
  }, {
    key: 'show',
    value: function show() {
      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
      this.root.removeAttribute('data-mode');
    }
  }]);

  return SnowTooltip;
}(_base.BaseTooltip);

SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');

exports.default = SnowTheme;

/***/ }),
/* 63 */
/***/ (function(module, exports, __nested_webpack_require_599761__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = __nested_webpack_require_599761__(29);

var _core2 = _interopRequireDefault(_core);

var _align = __nested_webpack_require_599761__(36);

var _direction = __nested_webpack_require_599761__(38);

var _indent = __nested_webpack_require_599761__(64);

var _blockquote = __nested_webpack_require_599761__(65);

var _blockquote2 = _interopRequireDefault(_blockquote);

var _header = __nested_webpack_require_599761__(66);

var _header2 = _interopRequireDefault(_header);

var _list = __nested_webpack_require_599761__(67);

var _list2 = _interopRequireDefault(_list);

var _background = __nested_webpack_require_599761__(37);

var _color = __nested_webpack_require_599761__(26);

var _font = __nested_webpack_require_599761__(39);

var _size = __nested_webpack_require_599761__(40);

var _bold = __nested_webpack_require_599761__(56);

var _bold2 = _interopRequireDefault(_bold);

var _italic = __nested_webpack_require_599761__(68);

var _italic2 = _interopRequireDefault(_italic);

var _link = __nested_webpack_require_599761__(27);

var _link2 = _interopRequireDefault(_link);

var _script = __nested_webpack_require_599761__(69);

var _script2 = _interopRequireDefault(_script);

var _strike = __nested_webpack_require_599761__(70);

var _strike2 = _interopRequireDefault(_strike);

var _underline = __nested_webpack_require_599761__(71);

var _underline2 = _interopRequireDefault(_underline);

var _image = __nested_webpack_require_599761__(72);

var _image2 = _interopRequireDefault(_image);

var _video = __nested_webpack_require_599761__(73);

var _video2 = _interopRequireDefault(_video);

var _code = __nested_webpack_require_599761__(13);

var _code2 = _interopRequireDefault(_code);

var _formula = __nested_webpack_require_599761__(74);

var _formula2 = _interopRequireDefault(_formula);

var _syntax = __nested_webpack_require_599761__(75);

var _syntax2 = _interopRequireDefault(_syntax);

var _toolbar = __nested_webpack_require_599761__(57);

var _toolbar2 = _interopRequireDefault(_toolbar);

var _icons = __nested_webpack_require_599761__(41);

var _icons2 = _interopRequireDefault(_icons);

var _picker = __nested_webpack_require_599761__(28);

var _picker2 = _interopRequireDefault(_picker);

var _colorPicker = __nested_webpack_require_599761__(59);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _iconPicker = __nested_webpack_require_599761__(60);

var _iconPicker2 = _interopRequireDefault(_iconPicker);

var _tooltip = __nested_webpack_require_599761__(61);

var _tooltip2 = _interopRequireDefault(_tooltip);

var _bubble = __nested_webpack_require_599761__(108);

var _bubble2 = _interopRequireDefault(_bubble);

var _snow = __nested_webpack_require_599761__(62);

var _snow2 = _interopRequireDefault(_snow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_core2.default.register({
  'attributors/attribute/direction': _direction.DirectionAttribute,

  'attributors/class/align': _align.AlignClass,
  'attributors/class/background': _background.BackgroundClass,
  'attributors/class/color': _color.ColorClass,
  'attributors/class/direction': _direction.DirectionClass,
  'attributors/class/font': _font.FontClass,
  'attributors/class/size': _size.SizeClass,

  'attributors/style/align': _align.AlignStyle,
  'attributors/style/background': _background.BackgroundStyle,
  'attributors/style/color': _color.ColorStyle,
  'attributors/style/direction': _direction.DirectionStyle,
  'attributors/style/font': _font.FontStyle,
  'attributors/style/size': _size.SizeStyle
}, true);

_core2.default.register({
  'formats/align': _align.AlignClass,
  'formats/direction': _direction.DirectionClass,
  'formats/indent': _indent.IndentClass,

  'formats/background': _background.BackgroundStyle,
  'formats/color': _color.ColorStyle,
  'formats/font': _font.FontClass,
  'formats/size': _size.SizeClass,

  'formats/blockquote': _blockquote2.default,
  'formats/code-block': _code2.default,
  'formats/header': _header2.default,
  'formats/list': _list2.default,

  'formats/bold': _bold2.default,
  'formats/code': _code.Code,
  'formats/italic': _italic2.default,
  'formats/link': _link2.default,
  'formats/script': _script2.default,
  'formats/strike': _strike2.default,
  'formats/underline': _underline2.default,

  'formats/image': _image2.default,
  'formats/video': _video2.default,

  'formats/list/item': _list.ListItem,

  'modules/formula': _formula2.default,
  'modules/syntax': _syntax2.default,
  'modules/toolbar': _toolbar2.default,

  'themes/bubble': _bubble2.default,
  'themes/snow': _snow2.default,

  'ui/icons': _icons2.default,
  'ui/picker': _picker2.default,
  'ui/icon-picker': _iconPicker2.default,
  'ui/color-picker': _colorPicker2.default,
  'ui/tooltip': _tooltip2.default
}, true);

exports.default = _core2.default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __nested_webpack_require_604333__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndentClass = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_604333__(0);

var _parchment2 = _interopRequireDefault(_parchment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IdentAttributor = function (_Parchment$Attributor) {
  _inherits(IdentAttributor, _Parchment$Attributor);

  function IdentAttributor() {
    _classCallCheck(this, IdentAttributor);

    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
  }

  _createClass(IdentAttributor, [{
    key: 'add',
    value: function add(node, value) {
      if (value === '+1' || value === '-1') {
        var indent = this.value(node) || 0;
        value = value === '+1' ? indent + 1 : indent - 1;
      }
      if (value === 0) {
        this.remove(node);
        return true;
      } else {
        return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
      }
    }
  }, {
    key: 'canAdd',
    value: function canAdd(node, value) {
      return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
    }
  }, {
    key: 'value',
    value: function value(node) {
      return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
    }
  }]);

  return IdentAttributor;
}(_parchment2.default.Attributor.Class);

var IndentClass = new IdentAttributor('indent', 'ql-indent', {
  scope: _parchment2.default.Scope.BLOCK,
  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
});

exports.IndentClass = IndentClass;

/***/ }),
/* 65 */
/***/ (function(module, exports, __nested_webpack_require_608358__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _block = __nested_webpack_require_608358__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Blockquote = function (_Block) {
  _inherits(Blockquote, _Block);

  function Blockquote() {
    _classCallCheck(this, Blockquote);

    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
  }

  return Blockquote;
}(_block2.default);

Blockquote.blotName = 'blockquote';
Blockquote.tagName = 'blockquote';

exports.default = Blockquote;

/***/ }),
/* 66 */
/***/ (function(module, exports, __nested_webpack_require_609992__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _block = __nested_webpack_require_609992__(4);

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_Block) {
  _inherits(Header, _Block);

  function Header() {
    _classCallCheck(this, Header);

    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
  }

  _createClass(Header, null, [{
    key: 'formats',
    value: function formats(domNode) {
      return this.tagName.indexOf(domNode.tagName) + 1;
    }
  }]);

  return Header;
}(_block2.default);

Header.blotName = 'header';
Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];

exports.default = Header;

/***/ }),
/* 67 */
/***/ (function(module, exports, __nested_webpack_require_612333__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ListItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_612333__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _block = __nested_webpack_require_612333__(4);

var _block2 = _interopRequireDefault(_block);

var _container = __nested_webpack_require_612333__(25);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ListItem = function (_Block) {
  _inherits(ListItem, _Block);

  function ListItem() {
    _classCallCheck(this, ListItem);

    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
  }

  _createClass(ListItem, [{
    key: 'format',
    value: function format(name, value) {
      if (name === List.blotName && !value) {
        this.replaceWith(_parchment2.default.create(this.statics.scope));
      } else {
        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
      }
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (this.prev == null && this.next == null) {
        this.parent.remove();
      } else {
        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
      }
    }
  }, {
    key: 'replaceWith',
    value: function replaceWith(name, value) {
      this.parent.isolate(this.offset(this.parent), this.length());
      if (name === this.parent.statics.blotName) {
        this.parent.replaceWith(name, value);
        return this;
      } else {
        this.parent.unwrap();
        return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
      }
    }
  }], [{
    key: 'formats',
    value: function formats(domNode) {
      return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
    }
  }]);

  return ListItem;
}(_block2.default);

ListItem.blotName = 'list-item';
ListItem.tagName = 'LI';

var List = function (_Container) {
  _inherits(List, _Container);

  _createClass(List, null, [{
    key: 'create',
    value: function create(value) {
      var tagName = value === 'ordered' ? 'OL' : 'UL';
      var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
      if (value === 'checked' || value === 'unchecked') {
        node.setAttribute('data-checked', value === 'checked');
      }
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      if (domNode.tagName === 'OL') return 'ordered';
      if (domNode.tagName === 'UL') {
        if (domNode.hasAttribute('data-checked')) {
          return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
        } else {
          return 'bullet';
        }
      }
      return undefined;
    }
  }]);

  function List(domNode) {
    _classCallCheck(this, List);

    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));

    var listEventHandler = function listEventHandler(e) {
      if (e.target.parentNode !== domNode) return;
      var format = _this2.statics.formats(domNode);
      var blot = _parchment2.default.find(e.target);
      if (format === 'checked') {
        blot.format('list', 'unchecked');
      } else if (format === 'unchecked') {
        blot.format('list', 'checked');
      }
    };

    domNode.addEventListener('touchstart', listEventHandler);
    domNode.addEventListener('mousedown', listEventHandler);
    return _this2;
  }

  _createClass(List, [{
    key: 'format',
    value: function format(name, value) {
      if (this.children.length > 0) {
        this.children.tail.format(name, value);
      }
    }
  }, {
    key: 'formats',
    value: function formats() {
      // We don't inherit from FormatBlot
      return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(blot, ref) {
      if (blot instanceof ListItem) {
        _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
      } else {
        var index = ref == null ? this.length() : ref.offset(this);
        var after = this.split(index);
        after.parent.insertBefore(blot, after);
      }
    }
  }, {
    key: 'optimize',
    value: function optimize(context) {
      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
      var next = this.next;
      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
        next.moveChildren(this);
        next.remove();
      }
    }
  }, {
    key: 'replace',
    value: function replace(target) {
      if (target.statics.blotName !== this.statics.blotName) {
        var item = _parchment2.default.create(this.statics.defaultChild);
        target.moveChildren(item);
        this.appendChild(item);
      }
      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
    }
  }]);

  return List;
}(_container2.default);

List.blotName = 'list';
List.scope = _parchment2.default.Scope.BLOCK_BLOT;
List.tagName = ['OL', 'UL'];
List.defaultChild = 'list-item';
List.allowedChildren = [ListItem];

exports.ListItem = ListItem;
exports.default = List;

/***/ }),
/* 68 */
/***/ (function(module, exports, __nested_webpack_require_620370__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bold = __nested_webpack_require_620370__(56);

var _bold2 = _interopRequireDefault(_bold);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Italic = function (_Bold) {
  _inherits(Italic, _Bold);

  function Italic() {
    _classCallCheck(this, Italic);

    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
  }

  return Italic;
}(_bold2.default);

Italic.blotName = 'italic';
Italic.tagName = ['EM', 'I'];

exports.default = Italic;

/***/ }),
/* 69 */
/***/ (function(module, exports, __nested_webpack_require_621954__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inline = __nested_webpack_require_621954__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Script = function (_Inline) {
  _inherits(Script, _Inline);

  function Script() {
    _classCallCheck(this, Script);

    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
  }

  _createClass(Script, null, [{
    key: 'create',
    value: function create(value) {
      if (value === 'super') {
        return document.createElement('sup');
      } else if (value === 'sub') {
        return document.createElement('sub');
      } else {
        return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
      }
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      if (domNode.tagName === 'SUB') return 'sub';
      if (domNode.tagName === 'SUP') return 'super';
      return undefined;
    }
  }]);

  return Script;
}(_inline2.default);

Script.blotName = 'script';
Script.tagName = ['SUB', 'SUP'];

exports.default = Script;

/***/ }),
/* 70 */
/***/ (function(module, exports, __nested_webpack_require_625200__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inline = __nested_webpack_require_625200__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Strike = function (_Inline) {
  _inherits(Strike, _Inline);

  function Strike() {
    _classCallCheck(this, Strike);

    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
  }

  return Strike;
}(_inline2.default);

Strike.blotName = 'strike';
Strike.tagName = 'S';

exports.default = Strike;

/***/ }),
/* 71 */
/***/ (function(module, exports, __nested_webpack_require_626787__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inline = __nested_webpack_require_626787__(6);

var _inline2 = _interopRequireDefault(_inline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Underline = function (_Inline) {
  _inherits(Underline, _Inline);

  function Underline() {
    _classCallCheck(this, Underline);

    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
  }

  return Underline;
}(_inline2.default);

Underline.blotName = 'underline';
Underline.tagName = 'U';

exports.default = Underline;

/***/ }),
/* 72 */
/***/ (function(module, exports, __nested_webpack_require_628407__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_628407__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _link = __nested_webpack_require_628407__(27);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ATTRIBUTES = ['alt', 'height', 'width'];

var Image = function (_Parchment$Embed) {
  _inherits(Image, _Parchment$Embed);

  function Image() {
    _classCallCheck(this, Image);

    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
  }

  _createClass(Image, [{
    key: 'format',
    value: function format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
      }
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
      if (typeof value === 'string') {
        node.setAttribute('src', this.sanitize(value));
      }
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return ATTRIBUTES.reduce(function (formats, attribute) {
        if (domNode.hasAttribute(attribute)) {
          formats[attribute] = domNode.getAttribute(attribute);
        }
        return formats;
      }, {});
    }
  }, {
    key: 'match',
    value: function match(url) {
      return (/\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url)
      );
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('src');
    }
  }]);

  return Image;
}(_parchment2.default.Embed);

Image.blotName = 'image';
Image.tagName = 'IMG';

exports.default = Image;

/***/ }),
/* 73 */
/***/ (function(module, exports, __nested_webpack_require_632606__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _block = __nested_webpack_require_632606__(4);

var _link = __nested_webpack_require_632606__(27);

var _link2 = _interopRequireDefault(_link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ATTRIBUTES = ['height', 'width'];

var Video = function (_BlockEmbed) {
  _inherits(Video, _BlockEmbed);

  function Video() {
    _classCallCheck(this, Video);

    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
  }

  _createClass(Video, [{
    key: 'format',
    value: function format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
      }
    }
  }], [{
    key: 'create',
    value: function create(value) {
      var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
      node.setAttribute('frameborder', '0');
      node.setAttribute('allowfullscreen', true);
      node.setAttribute('src', this.sanitize(value));
      return node;
    }
  }, {
    key: 'formats',
    value: function formats(domNode) {
      return ATTRIBUTES.reduce(function (formats, attribute) {
        if (domNode.hasAttribute(attribute)) {
          formats[attribute] = domNode.getAttribute(attribute);
        }
        return formats;
      }, {});
    }
  }, {
    key: 'sanitize',
    value: function sanitize(url) {
      return _link2.default.sanitize(url);
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('src');
    }
  }]);

  return Video;
}(_block.BlockEmbed);

Video.blotName = 'video';
Video.className = 'ql-video';
Video.tagName = 'IFRAME';

exports.default = Video;

/***/ }),
/* 74 */
/***/ (function(module, exports, __nested_webpack_require_636651__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FormulaBlot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _embed = __nested_webpack_require_636651__(35);

var _embed2 = _interopRequireDefault(_embed);

var _quill = __nested_webpack_require_636651__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __nested_webpack_require_636651__(9);

var _module2 = _interopRequireDefault(_module);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FormulaBlot = function (_Embed) {
  _inherits(FormulaBlot, _Embed);

  function FormulaBlot() {
    _classCallCheck(this, FormulaBlot);

    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
  }

  _createClass(FormulaBlot, null, [{
    key: 'create',
    value: function create(value) {
      var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
      if (typeof value === 'string') {
        window.katex.render(value, node, {
          throwOnError: false,
          errorColor: '#f00'
        });
        node.setAttribute('data-value', value);
      }
      return node;
    }
  }, {
    key: 'value',
    value: function value(domNode) {
      return domNode.getAttribute('data-value');
    }
  }]);

  return FormulaBlot;
}(_embed2.default);

FormulaBlot.blotName = 'formula';
FormulaBlot.className = 'ql-formula';
FormulaBlot.tagName = 'SPAN';

var Formula = function (_Module) {
  _inherits(Formula, _Module);

  _createClass(Formula, null, [{
    key: 'register',
    value: function register() {
      _quill2.default.register(FormulaBlot, true);
    }
  }]);

  function Formula() {
    _classCallCheck(this, Formula);

    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));

    if (window.katex == null) {
      throw new Error('Formula module requires KaTeX.');
    }
    return _this2;
  }

  return Formula;
}(_module2.default);

exports.FormulaBlot = FormulaBlot;
exports.default = Formula;

/***/ }),
/* 75 */
/***/ (function(module, exports, __nested_webpack_require_640765__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CodeToken = exports.CodeBlock = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _parchment = __nested_webpack_require_640765__(0);

var _parchment2 = _interopRequireDefault(_parchment);

var _quill = __nested_webpack_require_640765__(5);

var _quill2 = _interopRequireDefault(_quill);

var _module = __nested_webpack_require_640765__(9);

var _module2 = _interopRequireDefault(_module);

var _code = __nested_webpack_require_640765__(13);

var _code2 = _interopRequireDefault(_code);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SyntaxCodeBlock = function (_CodeBlock) {
  _inherits(SyntaxCodeBlock, _CodeBlock);

  function SyntaxCodeBlock() {
    _classCallCheck(this, SyntaxCodeBlock);

    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
  }

  _createClass(SyntaxCodeBlock, [{
    key: 'replaceWith',
    value: function replaceWith(block) {
      this.domNode.textContent = this.domNode.textContent;
      this.attach();
      _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
    }
  }, {
    key: 'highlight',
    value: function highlight(_highlight) {
      var text = this.domNode.textContent;
      if (this.cachedText !== text) {
        if (text.trim().length > 0 || this.cachedText == null) {
          this.domNode.innerHTML = _highlight(text);
          this.domNode.normalize();
          this.attach();
        }
        this.cachedText = text;
      }
    }
  }]);

  return SyntaxCodeBlock;
}(_code2.default);

SyntaxCodeBlock.className = 'ql-syntax';

var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
  scope: _parchment2.default.Scope.INLINE
});

var Syntax = function (_Module) {
  _inherits(Syntax, _Module);

  _createClass(Syntax, null, [{
    key: 'register',
    value: function register() {
      _quill2.default.register(CodeToken, true);
      _quill2.default.register(SyntaxCodeBlock, true);
    }
  }]);

  function Syntax(quill, options) {
    _classCallCheck(this, Syntax);

    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));

    if (typeof _this2.options.highlight !== 'function') {
      throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
    }
    var timer = null;
    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
      clearTimeout(timer);
      timer = setTimeout(function () {
        _this2.highlight();
        timer = null;
      }, _this2.options.interval);
    });
    _this2.highlight();
    return _this2;
  }

  _createClass(Syntax, [{
    key: 'highlight',
    value: function highlight() {
      var _this3 = this;

      if (this.quill.selection.composing) return;
      this.quill.update(_quill2.default.sources.USER);
      var range = this.quill.getSelection();
      this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
        code.highlight(_this3.options.highlight);
      });
      this.quill.update(_quill2.default.sources.SILENT);
      if (range != null) {
        this.quill.setSelection(range, _quill2.default.sources.SILENT);
      }
    }
  }]);

  return Syntax;
}(_module2.default);

Syntax.DEFAULTS = {
  highlight: function () {
    if (window.hljs == null) return null;
    return function (text) {
      var result = window.hljs.highlightAuto(text);
      return result.value;
    };
  }(),
  interval: 1000
};

exports.CodeBlock = SyntaxCodeBlock;
exports.CodeToken = CodeToken;
exports.default = Syntax;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";

/***/ }),
/* 108 */
/***/ (function(module, exports, __nested_webpack_require_663516__) {


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BubbleTooltip = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extend = __nested_webpack_require_663516__(3);

var _extend2 = _interopRequireDefault(_extend);

var _emitter = __nested_webpack_require_663516__(8);

var _emitter2 = _interopRequireDefault(_emitter);

var _base = __nested_webpack_require_663516__(43);

var _base2 = _interopRequireDefault(_base);

var _selection = __nested_webpack_require_663516__(15);

var _icons = __nested_webpack_require_663516__(41);

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{ header: 1 }, { header: 2 }, 'blockquote']];

var BubbleTheme = function (_BaseTheme) {
  _inherits(BubbleTheme, _BaseTheme);

  function BubbleTheme(quill, options) {
    _classCallCheck(this, BubbleTheme);

    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
      options.modules.toolbar.container = TOOLBAR_CONFIG;
    }

    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));

    _this.quill.container.classList.add('ql-bubble');
    return _this;
  }

  _createClass(BubbleTheme, [{
    key: 'extendToolbar',
    value: function extendToolbar(toolbar) {
      this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
      this.tooltip.root.appendChild(toolbar.container);
      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
    }
  }]);

  return BubbleTheme;
}(_base2.default);

BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link: function link(value) {
          if (!value) {
            this.quill.format('link', false);
          } else {
            this.quill.theme.tooltip.edit();
          }
        }
      }
    }
  }
});

var BubbleTooltip = function (_BaseTooltip) {
  _inherits(BubbleTooltip, _BaseTooltip);

  function BubbleTooltip(quill, bounds) {
    _classCallCheck(this, BubbleTooltip);

    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));

    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
      if (type !== _emitter2.default.events.SELECTION_CHANGE) return;
      if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
        _this2.show();
        // Lock our width so we will expand beyond our offsetParent boundaries
        _this2.root.style.left = '0px';
        _this2.root.style.width = '';
        _this2.root.style.width = _this2.root.offsetWidth + 'px';
        var lines = _this2.quill.getLines(range.index, range.length);
        if (lines.length === 1) {
          _this2.position(_this2.quill.getBounds(range));
        } else {
          var lastLine = lines[lines.length - 1];
          var index = _this2.quill.getIndex(lastLine);
          var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
          var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
          _this2.position(_bounds);
        }
      } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
        _this2.hide();
      }
    });
    return _this2;
  }

  _createClass(BubbleTooltip, [{
    key: 'listen',
    value: function listen() {
      var _this3 = this;

      _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
      this.root.querySelector('.ql-close').addEventListener('click', function () {
        _this3.root.classList.remove('ql-editing');
      });
      this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
        // Let selection be restored by toolbar handlers before repositioning
        setTimeout(function () {
          if (_this3.root.classList.contains('ql-hidden')) return;
          var range = _this3.quill.getSelection();
          if (range != null) {
            _this3.position(_this3.quill.getBounds(range));
          }
        }, 1);
      });
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this.show();
    }
  }, {
    key: 'position',
    value: function position(reference) {
      var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
      var arrow = this.root.querySelector('.ql-tooltip-arrow');
      arrow.style.marginLeft = '';
      if (shift === 0) return shift;
      arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
    }
  }]);

  return BubbleTooltip;
}(_base.BaseTooltip);

BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');

exports.BubbleTooltip = BubbleTooltip;
exports.default = BubbleTheme;

/***/ }),
/* 109 */
/***/ (function(module, exports, __nested_webpack_require_670823__) {

module.exports = __nested_webpack_require_670823__(63);


/***/ })
/******/ ])["default"];
});
});

var Quill = /*@__PURE__*/getDefaultExportFromCjs(quill);

var randomColor = createCommonjsModule(function (module, exports) {
(function(root, factory) {

  // Support CommonJS
  {
    var randomColor = factory();

    // Support NodeJS & Component, which allow module.exports to be a function
    if (module && module.exports) {
      exports = module.exports = randomColor;
    }

    // Support CommonJS 1.1.1 spec
    exports.randomColor = randomColor;

  // Support AMD
  }

}(commonjsGlobal, function() {

  // Seed to get repeatable colors
  var seed = null;

  // Shared color dictionary
  var colorDictionary = {};

  // Populate the color dictionary
  loadColorBounds();

  // check if a range is taken
  var colorRanges = [];

  var randomColor = function (options) {

    options = options || {};

    // Check if there is a seed and ensure it's an
    // integer. Otherwise, reset the seed value.
    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
      seed = options.seed;

    // A string was passed as a seed
    } else if (typeof options.seed === 'string') {
      seed = stringToInteger(options.seed);

    // Something was passed as a seed but it wasn't an integer or string
    } else if (options.seed !== undefined && options.seed !== null) {
      throw new TypeError('The seed value must be an integer or string');

    // No seed, reset the value outside.
    } else {
      seed = null;
    }

    var H,S,B;

    // Check if we need to generate multiple colors
    if (options.count !== null && options.count !== undefined) {

      var totalColors = options.count,
          colors = [];
      // Value false at index i means the range i is not taken yet.
      for (var i = 0; i < options.count; i++) {
        colorRanges.push(false);
        }
      options.count = null;

      while (totalColors > colors.length) {

        var color = randomColor(options);

        if (seed !== null) {
          options.seed = seed;
        }

        colors.push(color);
      }

      options.count = totalColors;

      return colors;
    }

    // First we pick a hue (H)
    H = pickHue(options);

    // Then use H to determine saturation (S)
    S = pickSaturation(H, options);

    // Then use S and H to determine brightness (B).
    B = pickBrightness(H, S, options);

    // Then we return the HSB color in the desired format
    return setFormat([H,S,B], options);
  };

  function pickHue(options) {
    if (colorRanges.length > 0) {
      var hueRange = getRealHueRange(options.hue);

      var hue = randomWithin(hueRange);

      //Each of colorRanges.length ranges has a length equal approximatelly one step
      var step = (hueRange[1] - hueRange[0]) / colorRanges.length;

      var j = parseInt((hue - hueRange[0]) / step);

      //Check if the range j is taken
      if (colorRanges[j] === true) {
        j = (j + 2) % colorRanges.length;
      }
      else {
        colorRanges[j] = true;
           }

      var min = (hueRange[0] + j * step) % 359,
          max = (hueRange[0] + (j + 1) * step) % 359;

      hueRange = [min, max];

      hue = randomWithin(hueRange);

      if (hue < 0) {hue = 360 + hue;}
      return hue
    }
    else {
      var hueRange = getHueRange(options.hue);

      hue = randomWithin(hueRange);
      // Instead of storing red as two seperate ranges,
      // we group them, using negative numbers
      if (hue < 0) {
        hue = 360 + hue;
      }

      return hue;
    }
  }

  function pickSaturation (hue, options) {

    if (options.hue === 'monochrome') {
      return 0;
    }

    if (options.luminosity === 'random') {
      return randomWithin([0,100]);
    }

    var saturationRange = getSaturationRange(hue);

    var sMin = saturationRange[0],
        sMax = saturationRange[1];

    switch (options.luminosity) {

      case 'bright':
        sMin = 55;
        break;

      case 'dark':
        sMin = sMax - 10;
        break;

      case 'light':
        sMax = 55;
        break;
   }

    return randomWithin([sMin, sMax]);

  }

  function pickBrightness (H, S, options) {

    var bMin = getMinimumBrightness(H, S),
        bMax = 100;

    switch (options.luminosity) {

      case 'dark':
        bMax = bMin + 20;
        break;

      case 'light':
        bMin = (bMax + bMin)/2;
        break;

      case 'random':
        bMin = 0;
        bMax = 100;
        break;
    }

    return randomWithin([bMin, bMax]);
  }

  function setFormat (hsv, options) {

    switch (options.format) {

      case 'hsvArray':
        return hsv;

      case 'hslArray':
        return HSVtoHSL(hsv);

      case 'hsl':
        var hsl = HSVtoHSL(hsv);
        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';

      case 'hsla':
        var hslColor = HSVtoHSL(hsv);
        var alpha = options.alpha || Math.random();
        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';

      case 'rgbArray':
        return HSVtoRGB(hsv);

      case 'rgb':
        var rgb = HSVtoRGB(hsv);
        return 'rgb(' + rgb.join(', ') + ')';

      case 'rgba':
        var rgbColor = HSVtoRGB(hsv);
        var alpha = options.alpha || Math.random();
        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';

      default:
        return HSVtoHex(hsv);
    }

  }

  function getMinimumBrightness(H, S) {

    var lowerBounds = getColorInfo(H).lowerBounds;

    for (var i = 0; i < lowerBounds.length - 1; i++) {

      var s1 = lowerBounds[i][0],
          v1 = lowerBounds[i][1];

      var s2 = lowerBounds[i+1][0],
          v2 = lowerBounds[i+1][1];

      if (S >= s1 && S <= s2) {

         var m = (v2 - v1)/(s2 - s1),
             b = v1 - m*s1;

         return m*S + b;
      }

    }

    return 0;
  }

  function getHueRange (colorInput) {

    if (typeof parseInt(colorInput) === 'number') {

      var number = parseInt(colorInput);

      if (number < 360 && number > 0) {
        return [number, number];
      }

    }

    if (typeof colorInput === 'string') {

      if (colorDictionary[colorInput]) {
        var color = colorDictionary[colorInput];
        if (color.hueRange) {return color.hueRange;}
      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorInput)[0];
        return [ hue, hue ];
      }
    }

    return [0,360];

  }

  function getSaturationRange (hue) {
    return getColorInfo(hue).saturationRange;
  }

  function getColorInfo (hue) {

    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) {
      hue-= 360;
    }

    for (var colorName in colorDictionary) {
       var color = colorDictionary[colorName];
       if (color.hueRange &&
           hue >= color.hueRange[0] &&
           hue <= color.hueRange[1]) {
          return colorDictionary[colorName];
       }
    } return 'Color not found';
  }

  function randomWithin (range) {
    if (seed === null) {
      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
      var golden_ratio = 0.618033988749895;
      var r=Math.random();
      r += golden_ratio;
      r %= 1;
      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));
    } else {
      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/
      var max = range[1] || 1;
      var min = range[0] || 0;
      seed = (seed * 9301 + 49297) % 233280;
      var rnd = seed / 233280.0;
      return Math.floor(min + rnd * (max - min));
}
  }

  function HSVtoHex (hsv){

    var rgb = HSVtoRGB(hsv);

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? '0' + hex : hex;
    }

    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);

    return hex;

  }

  function defineColor (name, hueRange, lowerBounds) {

    var sMin = lowerBounds[0][0],
        sMax = lowerBounds[lowerBounds.length - 1][0],

        bMin = lowerBounds[lowerBounds.length - 1][1],
        bMax = lowerBounds[0][1];

    colorDictionary[name] = {
      hueRange: hueRange,
      lowerBounds: lowerBounds,
      saturationRange: [sMin, sMax],
      brightnessRange: [bMin, bMax]
    };

  }

  function loadColorBounds () {

    defineColor(
      'monochrome',
      null,
      [[0,0],[100,0]]
    );

    defineColor(
      'red',
      [-26,18],
      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
    );

    defineColor(
      'orange',
      [18,46],
      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
    );

    defineColor(
      'yellow',
      [46,62],
      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
    );

    defineColor(
      'green',
      [62,178],
      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
    );

    defineColor(
      'blue',
      [178, 257],
      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
    );

    defineColor(
      'purple',
      [257, 282],
      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
    );

    defineColor(
      'pink',
      [282, 334],
      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
    );

  }

  function HSVtoRGB (hsv) {

    // this doesn't work for the values of 0 and 360
    // here's the hacky fix
    var h = hsv[0];
    if (h === 0) {h = 1;}
    if (h === 360) {h = 359;}

    // Rebase the h,s,v values
    h = h/360;
    var s = hsv[1]/100,
        v = hsv[2]/100;

    var h_i = Math.floor(h*6),
      f = h * 6 - h_i,
      p = v * (1 - s),
      q = v * (1 - f*s),
      t = v * (1 - (1 - f)*s),
      r = 256,
      g = 256,
      b = 256;

    switch(h_i) {
      case 0: r = v; g = t; b = p;  break;
      case 1: r = q; g = v; b = p;  break;
      case 2: r = p; g = v; b = t;  break;
      case 3: r = p; g = q; b = v;  break;
      case 4: r = t; g = p; b = v;  break;
      case 5: r = v; g = p; b = q;  break;
    }

    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
    return result;
  }

  function HexToHSB (hex) {
    hex = hex.replace(/^#/, '');
    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;

    var red = parseInt(hex.substr(0, 2), 16) / 255,
          green = parseInt(hex.substr(2, 2), 16) / 255,
          blue = parseInt(hex.substr(4, 2), 16) / 255;

    var cMax = Math.max(red, green, blue),
          delta = cMax - Math.min(red, green, blue),
          saturation = cMax ? (delta / cMax) : 0;

    switch (cMax) {
      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];
      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];
      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];
    }
  }

  function HSVtoHSL (hsv) {
    var h = hsv[0],
      s = hsv[1]/100,
      v = hsv[2]/100,
      k = (2-s)*v;

    return [
      h,
      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,
      k/2 * 100
    ];
  }

  function stringToInteger (string) {
    var total = 0;
    for (var i = 0; i !== string.length; i++) {
      if (total >= Number.MAX_SAFE_INTEGER) break;
      total += string.charCodeAt(i);
    }
    return total
  }

  // get The range of given hue when options.count!=0
  function getRealHueRange(colorHue)
  { if (!isNaN(colorHue)) {
    var number = parseInt(colorHue);

    if (number < 360 && number > 0) {
      return getColorInfo(colorHue).hueRange
    }
  }
    else if (typeof colorHue === 'string') {

      if (colorDictionary[colorHue]) {
        var color = colorDictionary[colorHue];

        if (color.hueRange) {
          return color.hueRange
       }
    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorHue)[0];
        return getColorInfo(hue).hueRange
    }
  }

    return [0,360]
}
  return randomColor;
}));
});

class TextInput {
    // The input element
    el;
    quill;
    groups;
    parentElement;
    droppedText;
    constructor(parentElement) {
        this.parentElement = parentElement;
        this.el = document.createElement('div');
        this.el.id = 'regextool-' + this.parentElement.toolNumber + '-regex-input';
        this.el.classList.add('regex-input');
        this.quill = null;
        this.groups = new Array();
        this.droppedText = false;
    }
    initQuill = () => {
        // initializing quill
        this.quill = new Quill('#regextool-' + this.parentElement.toolNumber + '-regex-input', {
            modules: {
                toolbar: false
            },
        });
        this.quill.keyboard.addBinding({
            key: 'C',
            shortKey: true,
        }, (range, context) => {
            const freeKeyboardEvent = {
                'event-type': 'text-input-keyboard',
                range: range,
                keys: ['ctrl', 'c']
            };
            if (this.parentElement) {
                this.parentElement.logEvent(freeKeyboardEvent);
            }
            return true;
        });
        this.quill.keyboard.addBinding({
            key: 'V',
            shortKey: true,
        }, (range, context) => {
            const freeKeyboardEvent = {
                'event-type': 'text-input-keyboard',
                range: range,
                keys: ['ctrl', 'v']
            };
            if (this.parentElement) {
                this.parentElement.logEvent(freeKeyboardEvent);
            }
            return true;
        });
        this.el.ondrop = (event) => {
            this.droppedText = true;
        };
    };
    getText = () => {
        if (this.quill != null) {
            return this.quill.getText(0, this.quill.getLength() - 1);
        }
        else {
            return '';
        }
    };
    highlightGroup = (colors) => {
        this.calculateGroup();
        console.log(this.groups);
        this.quill?.removeFormat(0, this.quill.getLength() - 1, 'silent');
        // generate new colors for group if current colors are not enough
        const groupCount = this.groups.length;
        if (colors.length < groupCount) {
            this.generateColor(colors, groupCount - colors.length);
        }
        // highlight the groups
        for (let i = 0; i < this.groups.length; ++i) {
            this.quill?.formatText(this.groups[i].start, this.groups[i].end - this.groups[i].start, {
                'background': colors[i]
            }, 'silent');
        }
    };
    calculateGroup = () => {
        let stack = new Array();
        this.groups = new Array();
        const pattern = this.getText();
        this.groups.push({ start: 0, end: pattern.length });
        for (let i = 0; i < pattern.length; ++i) {
            if (pattern[i] == '(') {
                stack.push(this.groups.length);
                this.groups.push({ start: i, end: -1 });
            }
            else if (pattern[i] == ')') {
                const startIndex = stack.pop();
                if (startIndex) {
                    this.groups[startIndex].end = i + 1;
                }
            }
        }
    };
    // TODO: (structure) move this function to the main element after adding highlight to input
    generateColor = (colors, cnt) => {
        for (let i = 0; i < cnt; ++i) {
            colors.push(randomColor.randomColor());
        }
    };
    updateTestStatus = (result) => {
        if (this.el.classList.contains(result)) {
            return;
        }
        if (this.el.classList.contains('Pass')) {
            this.el.classList.remove('Pass');
        }
        else if (this.el.classList.contains('Fail')) {
            this.el.classList.remove('Fail');
        }
        else if (this.el.classList.contains('Error')) {
            this.el.classList.remove('Error');
        }
        this.el.classList.add(result);
    };
    removeFormat = () => {
        this.quill?.removeFormat(0, this.quill.getLength() - 1, 'silent');
    };
    highlightError = (position) => {
        this.quill?.formatText(position, 1, {
            'background': '#ff99b3'
        }, 'silent');
    };
    restoreAnswer(type, answer) {
        // TODO: add logging to restoring answer
        if (type != 'text' || typeof answer !== 'string') {
            return;
        }
        this.quill?.setText(answer);
    }
    setIndent = (indent) => {
    };
}

core.registerLanguage('javascript', javascript_1);
core.registerLanguage('sql', sql_1);
core.registerLanguage('java', java_1);
core.registerLanguage('xml', xml_1);
core.registerLanguage('python', python_1);
class HParsonsElement extends HTMLElement {
    root;
    _parsonsData;
    parsonsExplanation;
    hparsonsInput;
    inputType;
    static toolCount = 0;
    toolNumber;
    temporaryInputEvent;
    inputDiv;
    language;
    contextBefore;
    contextAfter;
    constructor() {
        super();
        HParsonsElement.toolCount += 1;
        // console.log(RegexElement.toolCount);
        this.toolNumber = HParsonsElement.toolCount;
        // this.root = this.attachShadow({ mode: 'open' });
        this.root = this;
        this.addStyle();
        this.inputDiv = document.createElement('div');
        this.inputDiv.classList.add('hparsons-input');
        this.root.append(this.inputDiv);
        const reusable = this.getAttribute('reuse-blocks') ? true : false;
        const randomize = this.getAttribute('randomize') ? true : false;
        this.hparsonsInput = new ParsonsInput(this, reusable, randomize);
        // console.log(reusable)
        // a div wrapping the input and the test case status
        // init regex input based on the input type
        this._parsonsData = new Array();
        this.parsonsExplanation = null;
        this.inputType = 'parsons';
        // this.regexErrorMessage = document.createElement('div');
        // this.regexErrorPosition = -1;
        this.initRegexInput();
        this.temporaryInputEvent = {};
        let languageMap = new Map(Object.entries({
            'html': 'xml',
            'python': 'python',
            'javascript': 'javascript',
            'java': 'java',
            'sql': 'sql'
        }));
        this.language = languageMap.get(this.getAttribute('language') || 'none');
        this.contextBefore = this.contextAfter = null;
    }
    set parsonsData(data) {
        this._parsonsData = data;
        if (this.inputType == 'parsons') {
            this.hparsonsInput.setSourceBlocks(data, this.parsonsExplanation);
        }
    }
    get parsonsData() {
        return this._parsonsData;
    }
    // TODO[refactor]: put stylesheet in a separate css/scss file
    addStyle = () => {
        const sheet = document.createElement('style');
        // parsons block
        sheet.innerHTML += '.hparsons-input {padding: 15px;}\n';
        sheet.innerHTML += '.hparsons-tip { font-style: italic; }\n';
        sheet.innerHTML += '.parsons-block {display: inline-block; font-family: monospace; border-color:gray; margin: 0 1px; position: relative; border-radius: 10px; background-color: #efefef; border: 1px solid #d3d3d3; padding: 5px 10px; margin-top: 5px;}\n';
        sheet.innerHTML += '.drop-area .parsons-block.incorrectPosition {background-color: #ffbaba; border: 1px solid red;}\n';
        sheet.innerHTML += '.parsons-block:hover, .parsons-block:focus { border-color: black;}\n';
        sheet.innerHTML += '.drop-area { background-color: #ffa; padding: 0 5px; height: 42px; margin: 2px 0;}\n';
        sheet.innerHTML += '.drop-area.incorrect { background-color: #f2dede; border-color: #f2b6b6}\n';
        sheet.innerHTML += '.drop-area.correct { background-color: #dff0d8; border-color: #ade595}\n';
        // TODO:(UI) move the tooltip to the top of the line
        sheet.innerHTML += '.parsons-block .tooltip { visibility: hidden; width: 200px;  background-color: black; color: #fff; text-align: center; padding: 5px 0; border-radius: 6px;  position: absolute; z-index: 1; margin: 0 10px; bottom: 120%; margin-left: -100px;}\n';
        sheet.innerHTML += '.parsons-block .tooltip::after {content: " ";position: absolute; top: 100%;left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: black transparent transparent transparent;}\n';
        sheet.innerHTML += '.drag-area .parsons-block:hover .tooltip { visibility: visible;}\n';
        sheet.innerHTML += '.drag-area { background-color: #efefff; padding: 0 5px; height: 42px; margin: 2px 0; }\n';
        sheet.innerHTML += '.context.hide {display: none;}\n';
        sheet.innerHTML += '.context {padding: 0 4px; background-color: #eea; font-family: monospace;}\n';
        // unittest
        this.root.appendChild(sheet);
        const global_sheet = document.createElement('style');
        global_sheet.innerHTML += '.regex-input .ql-editor {height: fit-content;}\n';
        global_sheet.innerHTML += '.ql-editor { box-shadow: 0 0 2px 5px #b1dafa; margin: 5px; }\n';
        this.appendChild(global_sheet);
    };
    logEvent = (eventContent) => {
        // TODO: fix the logging scheme for horizontal parsons in general.
        // Right now it only dispatches event of moving parsons blocks.
        const basicEvent = {
            'input-type': this.inputType,
        };
        const ev = new CustomEvent('horizontal-parsons', { bubbles: true, detail: { ...basicEvent, ...eventContent } });
        this.dispatchEvent(ev);
    };
    // private _getTimestamp = (): string => {
    //     const timestamp = new Date();
    //     return timestamp.getFullYear() + '/' + (timestamp.getMonth() + 1) + '/' + timestamp.getDate() + '/' + timestamp.getHours() + '/' + timestamp.getMinutes() + '/' + timestamp.getSeconds() + '/' + timestamp.getMilliseconds();
    // }
    // // log regex input event along with compilation result
    // private _logRegexInputEvent = (): void => {
    //     // TODO: just using any here. but regexInputEvent is actually RegexEvent.ParsonsInputEvent or FreeInputEvent... so much trouble with typing!!
    //     let regexInputEvent: any = {
    //         ...this.temporaryInputEvent,
    //         valid: this.patternValidFlag
    //     };
    //     if (!this.patternValidFlag) {
    //         // regexInputEvent['error-message'] = this.regexErrorMessage.innerText;
    //     }
    //     this.logEvent(regexInputEvent);
    // }
    static get observedAttributes() { return ['input-type']; }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'input-type': {
                this.initRegexInput();
                break;
            }
        }
    }
    initRegexInput() {
        this.inputDiv.innerHTML = '';
        let inputType = this.getAttribute('input-type');
        this.inputType = inputType == 'parsons' ? 'parsons' : 'text';
        this._parsonsData = new Array();
        this.parsonsExplanation = null;
        // todo:(UI) fix the css for the input
        if (this.inputType == 'parsons') {
            // init elements: parsons regex input
            const reusable = this.getAttribute('reuse-blocks') != null ? true : false;
            const randomize = this.getAttribute('randomize') != null ? true : false;
            this.hparsonsInput = new ParsonsInput(this, reusable, randomize);
            this.inputDiv.appendChild(this.hparsonsInput.el);
        }
        else {
            // (this.inputType == 'text')
            const regex_slot = document.createElement('slot');
            regex_slot.name = 'regex-input';
            this.inputDiv.appendChild(regex_slot);
            // TODO: (refactor) rename RegexInput
            this.hparsonsInput = new TextInput(this);
            this.appendChild(this.hparsonsInput.el);
            this.hparsonsInput.el.slot = 'regex-input';
            this.hparsonsInput.initQuill();
            this.hparsonsInput.quill?.on('text-change', (delta) => {
                this.hparsonsInput.removeFormat();
                // logging free input event
                this.temporaryInputEvent = {
                    'event-type': 'text-input',
                    dropped: this.hparsonsInput.droppedText,
                    delta: delta,
                    answer: this.hparsonsInput.getText()
                };
                this.hparsonsInput.droppedText = false;
                // this._logRegexInputEvent();
            });
        }
    }
    resetInput() {
        if (this.inputType != 'parsons') {
            const regexInput = this.hparsonsInput;
            regexInput.quill?.setText('', 'silent');
        }
        else if (this.inputType == 'parsons') {
            this.hparsonsInput.resetInput();
        }
        const resetEvent = {
            'event-type': 'reset',
        };
        this.logEvent(resetEvent);
    }
    // restore student answer from outside storage
    restoreAnswer(type, answer) {
        if (type == undefined || answer == undefined) {
            return;
        }
        this.hparsonsInput.restoreAnswer(type, answer);
    }
    getCurrentInput() {
        return this.hparsonsInput.getText();
    }
    getParsonsTextArray() {
        return this.hparsonsInput._getTextArray();
    }
    setContext = (context) => {
        const contextBefore = this.querySelector('#hparsons-' + this.toolNumber + '-context-before');
        const contextAfter = this.querySelector('#hparsons-' + this.toolNumber + '-context-after');
        let codeIndex = -1;
        let indent = 0;
        for (let i = 0; i < context.length; ++i) {
            indent = context[i].indexOf('****');
            if (indent != -1) {
                codeIndex = i;
                break;
            }
        }
        if (this.language) {
            contextBefore.innerHTML = core.highlight(context.slice(0, codeIndex).join('\n'), { language: this.language, ignoreIllegals: true }).value;
            contextAfter.innerHTML = core.highlight(context.slice(codeIndex + 1).join('\n'), { language: this.language, ignoreIllegals: true }).value;
        }
        else {
            contextBefore.innerText = context.slice(0, codeIndex).join('\n');
            contextAfter.innerText = context.slice(codeIndex + 1).join('\n');
        }
        contextBefore.classList.remove('hide');
        contextAfter.classList.remove('hide');
        if (indent) {
            this.hparsonsInput.setIndent(indent);
        }
    };
}
customElements.define('horizontal-parsons', HParsonsElement);


//# sourceMappingURL=horizontal-parsons.js.map


/***/ }),

/***/ 97664:
/*!***********************************************!*\
  !*** ./runestone/hparsons/js/hparsons-sql.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hpList": () => (/* binding */ hpList),
/* harmony export */   "default": () => (/* binding */ SQLHParons)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);
/* harmony import */ var _css_hparsons_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/hparsons.css */ 32571);
/* harmony import */ var _css_hljs_xcode_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/hljs-xcode.css */ 28528);
/* harmony import */ var _BlockFeedback_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BlockFeedback.js */ 87036);
/* harmony import */ var _SQLFeedback_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SQLFeedback.js */ 3291);
/* harmony import */ var _horizontal_parsons_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./horizontal-parsons.js */ 10331);
// import 'handsontable/dist/handsontable.full.css';







var hpList;
// Dictionary that contains all instances of horizontal Parsons problem objects
if (hpList === undefined) hpList = {}; 




class SQLHParons extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opts) {
        super(opts);
        // copied from activecode
        var suffStart;
        // getting settings
        var orig = $(opts.orig).find("textarea")[0];
        this.reuse = $(orig).data('reuse') ? true : false;
        this.randomize = $(orig).data('randomize') ? true : false;
        this.isBlockGrading = $(orig).data('blockanswer') ? true : false;
        this.language = $(orig).data('language');
        if (this.isBlockGrading) {
            this.blockAnswer = $(orig).data('blockanswer').split(' ');
        }
        this.divid = opts.orig.id;
        this.containerDiv = opts.orig;
        this.useRunestoneServices = opts.useRunestoneServices;
        this.origElem = orig;
        this.origText = this.origElem.textContent;
        this.code = $(orig).text() || "\n\n\n\n\n";
        this.dburl = $(orig).data("dburl");
        this.runButton = null;
        this.saveButton = null;
        this.loadButton = null;
        this.outerDiv = null;
        this.controlDiv = null;
        console.log(this.code)

        this.originalBlocks = this.getSettings('--blocks--');
        this.unittest = this.getSettings('--unittest--');
        this.context = this.getSettings('--context--');

        // Change to factory when more execution based feedback is included
        if (this.isBlockGrading) {
            this.feedbackController = new _BlockFeedback_js__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        } else {
            this.feedbackController = new _SQLFeedback_js__WEBPACK_IMPORTED_MODULE_4__["default"](this);
        }

        // creating UI components
        this.createEditor();
        this.createOutput();
        this.createControls();
        this.feedbackController.customizeUI();

        if ($(orig).data("caption")) {
            this.caption = $(orig).data("caption");
        } else {
            this.caption = "HorizontalParsons";
        }
        this.addCaption("runestone");
        this.indicate_component_ready();

        // initializing functionalities for different feedback
        this.feedbackController.init();
    }

    getSettings(delimitier) {
        let content = null;
        let st = this.code.indexOf(delimitier);
        if (st > -1) {
            let subString = this.code.substring(st);
            let ed = subString.indexOf('\n--');
            subString = ed > -1 ? subString.substring(0, ed + 1) : subString;
            content = subString.split('\n').slice(1,-1);
        }
        return content;
    }


    // copied from activecode, already modified to add parsons
    createEditor() {
        this.outerDiv = document.createElement("div");
        $(this.origElem).replaceWith(this.outerDiv);
        let parsonsHTML = `<horizontal-parsons id='${this.divid}-hparsons'`
        parsonsHTML += ` input-type='parsons' `;
        if (this.reuse) {
            parsonsHTML += ` reuse-blocks="true"`;
        }
        if (this.randomize) {
            parsonsHTML += ` randomize="true"`;
        }
        if (this.language) {
            parsonsHTML += ` language="` + this.language + `"`;
        }
        parsonsHTML += `>`
        this.outerDiv.innerHTML = parsonsHTML;
        this.outerDiv.addEventListener('horizontal-parsons', (ev) => {
            this.logHorizontalParsonsEvent(ev.detail)
            this.feedbackController.clearFeedback();
        })
        this.hparsonsInput = $(this.outerDiv).find("horizontal-parsons")[0];
        this.hparsonsInput.parsonsData = JSON.parse(JSON.stringify(this.originalBlocks));
        if (this.context) {
            console.log('set context hparsons')
            this.hparsonsInput.setContext(this.context);
        }
    }

    createOutput() {
        this.feedbackController.createOutput();
    }

    // copied from activecode
    createControls() {
        var ctrlDiv = document.createElement("div");
        $(ctrlDiv).addClass("hp_actions");
        $(ctrlDiv).addClass("col-md-12");

        // Run Button
        this.runButton = document.createElement("button");
        $(this.runButton).addClass("btn btn-success run-button");
        ctrlDiv.appendChild(this.runButton);
        $(this.runButton).attr("type", "button");
        $(this.runButton).text("Run");
        this.runButton.onclick = () => {
            this.feedbackController.runButtonHandler();
        }

        // Reset button
        var resetBtn;
        resetBtn = document.createElement("button");
        $(resetBtn).text("Reset");
        $(resetBtn).addClass("btn btn-warning run-button");
        ctrlDiv.appendChild(resetBtn);
        this.resetButton = resetBtn;
        this.resetButton.onclick = () => {
            this.hparsonsInput.resetInput();
            this.feedbackController.reset();
        }
        $(resetBtn).attr("type", "button");

        $(this.outerDiv).prepend(ctrlDiv);
        this.controlDiv = ctrlDiv;
    }

    logHorizontalParsonsEvent(hparsonsEvent) {
        // TODO: might need to find another way to change "act". 
        // The event string is probably too long.
        let ev = {
            event: "hparsons",
            div_id: this.divid,
            act: JSON.stringify(hparsonsEvent),
        };
        this.logBookEvent(ev);
    }
}


/*=================================
== Find the custom HTML tags and ==
==   execute our code on them    ==
=================================*/
$(document).bind("runestone:login-complete", function () {
    $("[data-component=hparsons]").each(function () {
        if ($(this).closest("[data-component=timedAssessment]").length == 0) {
            // If this element exists within a timed component, don't render it here
            // try {
                hpList[this.id] = new SQLHParons({
                    orig: this,
                    useRunestoneServices: eBookConfig.useRunestoneServices,
                });
            // } catch (err) {
            //     console.log(`Error rendering ShortAnswer Problem ${this.id}
            //     Details: ${err}`);
            // }
        }
    });
});


/***/ }),

/***/ 33965:
/*!***************************************************!*\
  !*** ./runestone/hparsons/js/hparsonsFeedback.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HParsonsFeedback)
/* harmony export */ });
class HParsonsFeedback {
    constructor(hparsons) {
        this.hparsons = hparsons;
    }
    createOutput() {
        console.log('createOutput method not implemented in feedback!');
    }
    async runButtonHandler() {
        console.log('runButtonClicked method not implemented in feedback!');
    }
    customizeUI() {
        // used to change some minor UI, e.g. the text on Run button
    }
    init() {
        // initlizations functionalities such as preparing SQL,
        // or checking related options
    }

    clearFeedback() {
        // called when input is changed
        console.log('clearFeedback method not implemented in feedback!');
    }
    
    reset() {
        // called when reset is clicked
        console.log('reset method not implemented in feedback!');
    }
}


/***/ }),

/***/ 59164:
/*!*************************************************!*\
  !*** ./runestone/parsons/js/parsons-i18n.en.js ***!
  \*************************************************/
/***/ (() => {

$.i18n().load({
    en: {
        msg_parson_check_me: "Check",
        msg_parson_reset: "Reset",
        msg_parson_help: "Help me",
        msg_parson_too_short: "Your program is too short. Add more blocks.",
        msg_parson_drag_from_here: "Drag from here",
        msg_parson_drag_to_here: "Drop blocks here",
        msg_parson_correct_first_try:
            "Perfect!  It took you only one try to solve this.  Great job!",
        msg_parson_correct:
            "Perfect!  It took you $1 tries to solve this.  Click Reset to try to solve it in one attempt.",
        msg_parson_wrong_indent:
            "This block is not indented correctly. Either indent it more by dragging it right or reduce the indention by dragging it left.",
        msg_parson_wrong_indents:
            "These blocks are not indented correctly. To indent a block more, drag it to the right. To reduce the indention, drag it to the left.",
        msg_parson_wrong_order:
            "Highlighted blocks in your program are wrong or are in the wrong order. This can be fixed by moving, removing, or replacing highlighted blocks.",
        msg_parson_arrow_navigate:
            "Arrow keys to navigate. Space to select / deselect block to move.",
        msg_parson_help_info:
            "Click on the Help Me button if you want to make the problem easier",
        msg_parson_not_solution:
            "Disabled an unneeded code block (one that is not part of the solution).",
        msg_parson_provided_indent: "Provided the indentation.",
        msg_parson_combined_blocks: "Combined two code blocks into one.",
        msg_parson_remove_incorrect:
            "Will remove an incorrect code block from answer area",
        msg_parson_will_combine: "Will combine two blocks",
        msg_parson_atleast_three_attempts:
            "You must make at least three distinct full attempts at a solution before you can get help",
        msg_parson_three_blocks_left:
            "There are only 3 correct blocks left.  You should be able to put them in order",
        msg_parson_will_provide_indent: "Will provide indentation",
    },
});


/***/ }),

/***/ 16432:
/*!****************************************************!*\
  !*** ./runestone/parsons/js/parsons-i18n.pt-br.js ***!
  \****************************************************/
/***/ (() => {

$.i18n().load({
    "pt-br": {
        msg_parson_check_me: "Verificar",
        msg_parson_reset: "Resetar",
        msg_parson_help:"Ajuda",
        msg_parson_too_short: "Seu programa  muito curto. Adicione mais blocos.",
        msg_parson_drag_from_here: "Arraste daqui",
        msg_parson_drag_to_here: "Largue os blocos aqui",
        msg_parson_correct_first_try:
            "Perfeito! Voc levou apenas uma tentativa para resolver. Bom trabalho!",
        msg_parson_correct:
            "Perfeito! Voc levou $1 tentativas para resolver. Clique em Resetar para tentar resolver em uma tentativa." ,
        msg_parson_wrong_indent:
            "Este bloco no est indentado corretamente. Indente mais arrastando-o para a direita ou reduza a indentao arrastando para a esquerda.",
        msg_parson_wrong_indents:
            "Estes blocos no esto indentados corretamente. Para indentar mais, arraste o bloco para a direita. Para reduzir a indentao, arraste para a esquerda.",
        msg_parson_wrong_order:
            "Blocos destacados no seu programa esto errados ou esto na ordem errada. Isso pode ser resolvido movendo, excluindo ou substituindo os blocos destacados.",
        msg_parson_arrow_navigate:
            "Use as teclas de setas para navegar. Espao para selecionar/ desmarcar blocos para mover.",
        msg_parson_help_info:
            "Clique no boto Ajuda se voc quiser facilitar o problema",
        msg_parson_not_solution:
            "Foi desabilitado um bloco de cdigo desnecessrio (que no faz parte da soluo).",
        msg_parson_provided_indent:"Foi fornecida a indentao.",
        msg_parson_combined_blocks:"Dois blocos de cdigos foram combinados em um.",
        msg_parson_remove_incorrect:
            "Ser removido um bloco de cdigo incorreto da rea de resposta",
        msg_parson_will_combine:"Sero combinados dois blocos",
        msg_parson_atleast_three_attempts:
            "Voc deve tentar pelo menos trs vezes antes de pedir ajuda",
        msg_parson_three_blocks_left:
            "Restam apenas 3 blocos corretos. Voc deve coloc-los em ordem",
        msg_parson_will_provide_indent: "Ser fornecida a indentao"
    },
});


/***/ }),

/***/ 37607:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 70803:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 59547:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX21vbWVudF9sb2NhbGVfc3luY19yZWN1cnNpdmVfLXJ1bmVzdG9uZV9ocGFyc29uc19qc19ocGFyc29ucy1zcWxfanMuMWU3OTZjZWRjMDMwNDE2My5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25Ra0Q7QUFDRjtBQUNIO0FBQ0c7O0FBRWpDLDRCQUE0Qix5REFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBZ0I7QUFDMUM7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsNkNBQTZDOzs7QUFHN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7OztBQUdaO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU1BQWlNOztBQUVqTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsaUVBQWlFOzs7QUFHakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FB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LEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksMEJBQTBCO0FBQ3RDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSw0QkFBNEI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEOzs7QUFHQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSixrQ0FBa0M7QUFDbEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFELGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdEQUFnRDtBQUMxRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVUsS0FBSyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FB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QztBQUNBLE1BQU0sd0NBQXdDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixLQUFLO0FBQ3ZCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNFQUFzRSxxQkFBcUI7QUFDM0Ysd0VBQXdFLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixtREFBbUQ7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpREFBaUQ7O0FBRTdFO0FBQ0EsT0FBTztBQUNQLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7OztBQUdwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsc0RBQXNELGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsb0JBQW9CLE9BQU8sNENBQTRDLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFemMsY0FBYyxpQ0FBbUI7O0FBRWpDOztBQUVBLGtCQUFrQixpQ0FBbUI7O0FBRXJDOztBQUVBLGlCQUFpQixpQ0FBbUI7O0FBRXBDOztBQUVBLGFBQWEsaUNBQW1COztBQUVoQzs7QUFFQSxjQUFjLGlDQUFtQjs7QUFFakM7O0FBRUEsWUFBWSxpQ0FBbUI7O0FBRS9COztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLGtEQUFrRCxhQUFhLHlGQUF5Rjs7QUFFeEosMkNBQTJDLCtEQUErRCx1R0FBdUcseUVBQXlFLGVBQWUsMEVBQTBFLEdBQUc7O0FBRXRYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtB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QTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJILHdCQUF3QjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztB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O0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFD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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLDRCQUE0Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFF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anMteGNvZGUuY3NzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvaHBhcnNvbnMvY3NzL2hwYXJzb25zLmNzcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy9ob21lL2FteTIxMjA2L1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGV8c3luY3wvXlxcLlxcLy4qJC8iLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9ocGFyc29ucy9qcy9CbG9ja0ZlZWRiYWNrLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvaHBhcnNvbnMvanMvU1FMRmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9ocGFyc29ucy9qcy9ibG9ja0dyYWRlci5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2hwYXJzb25zL2pzL2hvcml6b250YWwtcGFyc29ucy5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2hwYXJzb25zL2pzL2hwYXJzb25zLXNxbC5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2hwYXJzb25zL2pzL2hwYXJzb25zRmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9wYXJzb25zL2pzL3BhcnNvbnMtaTE4bi5lbi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL3BhcnNvbnMvanMvcGFyc29ucy1pMThuLnB0LWJyLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvaG9tZS9hbXkyMTIwNi9SdW5lc3RvbmVDb21wb25lbnRzL25vZGVfbW9kdWxlcy9zcWwuanMvZGlzdHxjcnlwdG8iLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy9pZ25vcmVkfC9ob21lL2FteTIxMjA2L1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3NxbC5qcy9kaXN0fGZzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvaG9tZS9hbXkyMTIwNi9SdW5lc3RvbmVDb21wb25lbnRzL25vZGVfbW9kdWxlcy9zcWwuanMvZGlzdHxwYXRoIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsInZhciBtYXAgPSB7XG5cdFwiLi9hZlwiOiA0Mjc4Nixcblx0XCIuL2FmLmpzXCI6IDQyNzg2LFxuXHRcIi4vYXJcIjogMzA4NjcsXG5cdFwiLi9hci1kelwiOiAxNDEzMCxcblx0XCIuL2FyLWR6LmpzXCI6IDE0MTMwLFxuXHRcIi4vYXIta3dcIjogOTYxMzUsXG5cdFwiLi9hci1rdy5qc1wiOiA5NjEzNSxcblx0XCIuL2FyLWx5XCI6IDU2NDQwLFxuXHRcIi4vYXItbHkuanNcIjogNTY0NDAsXG5cdFwiLi9hci1tYVwiOiA0NzcwMixcblx0XCIuL2FyLW1hLmpzXCI6IDQ3NzAyLFxuXHRcIi4vYXItc2FcIjogMTYwNDAsXG5cdFwiLi9hci1zYS5qc1wiOiAxNjA0MCxcblx0XCIuL2FyLXRuXCI6IDM3MTAwLFxuXHRcIi4vYXItdG4uanNcIjogMzcxMDAsXG5cdFwiLi9hci5qc1wiOiAzMDg2Nyxcblx0XCIuL2F6XCI6IDMxMDgzLFxuXHRcIi4vYXouanNcIjogMzEwODMsXG5cdFwiLi9iZVwiOiA5ODA4LFxuXHRcIi4vYmUuanNcIjogOTgwOCxcblx0XCIuL2JnXCI6IDY4MzM4LFxuXHRcIi4vYmcuanNcIjogNjgzMzgsXG5cdFwiLi9ibVwiOiA2NzQzOCxcblx0XCIuL2JtLmpzXCI6IDY3NDM4LFxuXHRcIi4vYm5cIjogODkwNSxcblx0XCIuL2JuLmpzXCI6IDg5MDUsXG5cdFwiLi9ib1wiOiAxMTU2MCxcblx0XCIuL2JvLmpzXCI6IDExNTYwLFxuXHRcIi4vYnJcIjogMTI3OCxcblx0XCIuL2JyLmpzXCI6IDEyNzgsXG5cdFwiLi9ic1wiOiA4MDYyMixcblx0XCIuL2JzLmpzXCI6IDgwNjIyLFxuXHRcIi4vY2FcIjogMjQ2OCxcblx0XCIuL2NhLmpzXCI6IDI0NjgsXG5cdFwiLi9jc1wiOiA1ODIyLFxuXHRcIi4vY3MuanNcIjogNTgyMixcblx0XCIuL2N2XCI6IDUwODc3LFxuXHRcIi4vY3YuanNcIjogNTA4NzcsXG5cdFwiLi9jeVwiOiA0NzM3Myxcblx0XCIuL2N5LmpzXCI6IDQ3MzczLFxuXHRcIi4vZGFcIjogMjQ3ODAsXG5cdFwiLi9kYS5qc1wiOiAyNDc4MCxcblx0XCIuL2RlXCI6IDU5NzQwLFxuXHRcIi4vZGUtYXRcIjogNjAyMTcsXG5cdFwiLi9kZS1hdC5qc1wiOiA2MDIxNyxcblx0XCIuL2RlLWNoXCI6IDYwODk0LFxuXHRcIi4vZGUtY2guanNcIjogNjA4OTQsXG5cdFwiLi9kZS5qc1wiOiA1OTc0MCxcblx0XCIuL2R2XCI6IDUzMDAsXG5cdFwiLi9kdi5qc1wiOiA1MzAwLFxuXHRcIi4vZWxcIjogNTA4MzcsXG5cdFwiLi9lbC5qc1wiOiA1MDgzNyxcblx0XCIuL2VuLWF1XCI6IDc4MzQ4LFxuXHRcIi4vZW4tYXUuanNcIjogNzgzNDgsXG5cdFwiLi9lbi1jYVwiOiA3NzkyNSxcblx0XCIuL2VuLWNhLmpzXCI6IDc3OTI1LFxuXHRcIi4vZW4tZ2JcIjogMjIyNDMsXG5cdFwiLi9lbi1nYi5qc1wiOiAyMjI0Myxcblx0XCIuL2VuLWllXCI6IDQ2NDM2LFxuXHRcIi4vZW4taWUuanNcIjogNDY0MzYsXG5cdFwiLi9lbi1uelwiOiA3NjMxOSxcblx0XCIuL2VuLW56LmpzXCI6IDc2MzE5LFxuXHRcIi4vZW9cIjogOTI5MTUsXG5cdFwiLi9lby5qc1wiOiA5MjkxNSxcblx0XCIuL2VzXCI6IDU1NjU1LFxuXHRcIi4vZXMtZG9cIjogNTUyNTEsXG5cdFwiLi9lcy1kby5qc1wiOiA1NTI1MSxcblx0XCIuL2VzLXVzXCI6IDcxMTQ2LFxuXHRcIi4vZXMtdXMuanNcIjogNzExNDYsXG5cdFwiLi9lcy5qc1wiOiA1NTY1NSxcblx0XCIuL2V0XCI6IDU2MDMsXG5cdFwiLi9ldC5qc1wiOiA1NjAzLFxuXHRcIi4vZXVcIjogNzc3NjMsXG5cdFwiLi9ldS5qc1wiOiA3Nzc2Myxcblx0XCIuL2ZhXCI6IDc2OTU5LFxuXHRcIi4vZmEuanNcIjogNzY5NTksXG5cdFwiLi9maVwiOiAxMTg5Nyxcblx0XCIuL2ZpLmpzXCI6IDExODk3LFxuXHRcIi4vZm9cIjogOTQ2OTQsXG5cdFwiLi9mby5qc1wiOiA5NDY5NCxcblx0XCIuL2ZyXCI6IDk0NDcwLFxuXHRcIi4vZnItY2FcIjogNjMwNDksXG5cdFwiLi9mci1jYS5qc1wiOiA2MzA0OSxcblx0XCIuL2ZyLWNoXCI6IDUyMzMwLFxuXHRcIi4vZnItY2guanNcIjogNTIzMzAsXG5cdFwiLi9mci5qc1wiOiA5NDQ3MCxcblx0XCIuL2Z5XCI6IDUwNDQsXG5cdFwiLi9meS5qc1wiOiA1MDQ0LFxuXHRcIi4vZ2RcIjogMjEwMSxcblx0XCIuL2dkLmpzXCI6IDIxMDEsXG5cdFwiLi9nbFwiOiAzODc5NCxcblx0XCIuL2dsLmpzXCI6IDM4Nzk0LFxuXHRcIi4vZ29tLWxhdG5cIjogMjMxNjgsXG5cdFwiLi9nb20tbGF0bi5qc1wiOiAyMzE2OCxcblx0XCIuL2d1XCI6IDk1MzQ5LFxuXHRcIi4vZ3UuanNcIjogOTUzNDksXG5cdFwiLi9oZVwiOiAyNDIwNixcblx0XCIuL2hlLmpzXCI6IDI0MjA2LFxuXHRcIi4vaGlcIjogMzAwOTQsXG5cdFwiLi9oaS5qc1wiOiAzMDA5NCxcblx0XCIuL2hyXCI6IDMwMzE2LFxuXHRcIi4vaHIuanNcIjogMzAzMTYsXG5cdFwiLi9odVwiOiAyMjEzOCxcblx0XCIuL2h1LmpzXCI6IDIyMTM4LFxuXHRcIi4vaHktYW1cIjogMTE0MjMsXG5cdFwiLi9oeS1hbS5qc1wiOiAxMTQyMyxcblx0XCIuL2lkXCI6IDI5MjE4LFxuXHRcIi4vaWQuanNcIjogMjkyMTgsXG5cdFwiLi9pc1wiOiA5MDEzNSxcblx0XCIuL2lzLmpzXCI6IDkwMTM1LFxuXHRcIi4vaXRcIjogOTA2MjYsXG5cdFwiLi9pdC5qc1wiOiA5MDYyNixcblx0XCIuL2phXCI6IDM5MTgzLFxuXHRcIi4vamEuanNcIjogMzkxODMsXG5cdFwiLi9qdlwiOiAyNDI4Nixcblx0XCIuL2p2LmpzXCI6IDI0Mjg2LFxuXHRcIi4va2FcIjogNDA0MTUsXG5cdFwiLi9rYS5qc1wiOiA0MDQxNSxcblx0XCIuL2trXCI6IDQ3NzcyLFxuXHRcIi4va2suanNcIjogNDc3NzIsXG5cdFwiLi9rbVwiOiAxODc1OCxcblx0XCIuL2ttLmpzXCI6IDE4NzU4LFxuXHRcIi4va25cIjogNzkyODIsXG5cdFwiLi9rbi5qc1wiOiA3OTI4Mixcblx0XCIuL2tvXCI6IDMzNzMwLFxuXHRcIi4va28uanNcIjogMzM3MzAsXG5cdFwiLi9reVwiOiAzMzI5MSxcblx0XCIuL2t5LmpzXCI6IDMzMjkxLFxuXHRcIi4vbGJcIjogMzY4NDEsXG5cdFwiLi9sYi5qc1wiOiAzNjg0MSxcblx0XCIuL2xvXCI6IDU1NDY2LFxuXHRcIi4vbG8uanNcIjogNTU0NjYsXG5cdFwiLi9sdFwiOiA1NzAxMCxcblx0XCIuL2x0LmpzXCI6IDU3MDEwLFxuXHRcIi4vbHZcIjogMzc1OTUsXG5cdFwiLi9sdi5qc1wiOiAzNzU5NSxcblx0XCIuL21lXCI6IDM5ODYxLFxuXHRcIi4vbWUuanNcIjogMzk4NjEsXG5cdFwiLi9taVwiOiAzNTQ5Myxcblx0XCIuL21pLmpzXCI6IDM1NDkzLFxuXHRcIi4vbWtcIjogOTU5NjYsXG5cdFwiLi9tay5qc1wiOiA5NTk2Nixcblx0XCIuL21sXCI6IDg3MzQxLFxuXHRcIi4vbWwuanNcIjogODczNDEsXG5cdFwiLi9tclwiOiAxMDM3MCxcblx0XCIuL21yLmpzXCI6IDEwMzcwLFxuXHRcIi4vbXNcIjogOTg0Nyxcblx0XCIuL21zLW15XCI6IDQxMjM3LFxuXHRcIi4vbXMtbXkuanNcIjogNDEyMzcsXG5cdFwiLi9tcy5qc1wiOiA5ODQ3LFxuXHRcIi4vbXRcIjogNzIxMjYsXG5cdFwiLi9tdC5qc1wiOiA3MjEyNixcblx0XCIuL215XCI6IDU2MTY1LFxuXHRcIi4vbXkuanNcIjogNTYxNjUsXG5cdFwiLi9uYlwiOiA2NDkyNCxcblx0XCIuL25iLmpzXCI6IDY0OTI0LFxuXHRcIi4vbmVcIjogMTY3NDQsXG5cdFwiLi9uZS5qc1wiOiAxNjc0NCxcblx0XCIuL25sXCI6IDkzOTAxLFxuXHRcIi4vbmwtYmVcIjogNTk4MTQsXG5cdFwiLi9ubC1iZS5qc1wiOiA1OTgxNCxcblx0XCIuL25sLmpzXCI6IDkzOTAxLFxuXHRcIi4vbm5cIjogODM4NzcsXG5cdFwiLi9ubi5qc1wiOiA4Mzg3Nyxcblx0XCIuL3BhLWluXCI6IDE1ODU4LFxuXHRcIi4vcGEtaW4uanNcIjogMTU4NTgsXG5cdFwiLi9wbFwiOiA2NDQ5NSxcblx0XCIuL3BsLmpzXCI6IDY0NDk1LFxuXHRcIi4vcHRcIjogODk1MjAsXG5cdFwiLi9wdC1iclwiOiA1Nzk3MSxcblx0XCIuL3B0LWJyLmpzXCI6IDU3OTcxLFxuXHRcIi4vcHQuanNcIjogODk1MjAsXG5cdFwiLi9yb1wiOiA5NjQ1OSxcblx0XCIuL3JvLmpzXCI6IDk2NDU5LFxuXHRcIi4vcnVcIjogMjE3OTMsXG5cdFwiLi9ydS5qc1wiOiAyMTc5Myxcblx0XCIuL3NkXCI6IDQwOTUwLFxuXHRcIi4vc2QuanNcIjogNDA5NTAsXG5cdFwiLi9zZVwiOiAxMDQ5MCxcblx0XCIuL3NlLmpzXCI6IDEwNDkwLFxuXHRcIi4vc2lcIjogOTAxMjQsXG5cdFwiLi9zaS5qc1wiOiA5MDEyNCxcblx0XCIuL3NrXCI6IDY0MjQ5LFxuXHRcIi4vc2suanNcIjogNjQyNDksXG5cdFwiLi9zbFwiOiAxNDk4NSxcblx0XCIuL3NsLmpzXCI6IDE0OTg1LFxuXHRcIi4vc3FcIjogNTExMDQsXG5cdFwiLi9zcS5qc1wiOiA1MTEwNCxcblx0XCIuL3NyXCI6IDQ5MTMxLFxuXHRcIi4vc3ItY3lybFwiOiAxMzcwOSxcblx0XCIuL3NyLWN5cmwuanNcIjogMTM3MDksXG5cdFwiLi9zci5qc1wiOiA0OTEzMSxcblx0XCIuL3NzXCI6IDg1ODkzLFxuXHRcIi4vc3MuanNcIjogODU4OTMsXG5cdFwiLi9zdlwiOiA5ODc2MCxcblx0XCIuL3N2LmpzXCI6IDk4NzYwLFxuXHRcIi4vc3dcIjogOTExNzIsXG5cdFwiLi9zdy5qc1wiOiA5MTE3Mixcblx0XCIuL3RhXCI6IDI3MzMzLFxuXHRcIi4vdGEuanNcIjogMjczMzMsXG5cdFwiLi90ZVwiOiAyMzExMCxcblx0XCIuL3RlLmpzXCI6IDIzMTEwLFxuXHRcIi4vdGV0XCI6IDUyMDk1LFxuXHRcIi4vdGV0LmpzXCI6IDUyMDk1LFxuXHRcIi4vdGhcIjogOTA0MSxcblx0XCIuL3RoLmpzXCI6IDkwNDEsXG5cdFwiLi90bC1waFwiOiA3NTc2OCxcblx0XCIuL3RsLXBoLmpzXCI6IDc1NzY4LFxuXHRcIi4vdGxoXCI6IDg5NDQ0LFxuXHRcIi4vdGxoLmpzXCI6IDg5NDQ0LFxuXHRcIi4vdHJcIjogNzIzOTcsXG5cdFwiLi90ci5qc1wiOiA3MjM5Nyxcblx0XCIuL3R6bFwiOiAyODI1NCxcblx0XCIuL3R6bC5qc1wiOiAyODI1NCxcblx0XCIuL3R6bVwiOiA1MTEwNixcblx0XCIuL3R6bS1sYXRuXCI6IDMwNjk5LFxuXHRcIi4vdHptLWxhdG4uanNcIjogMzA2OTksXG5cdFwiLi90em0uanNcIjogNTExMDYsXG5cdFwiLi91a1wiOiA2NzY5MSxcblx0XCIuL3VrLmpzXCI6IDY3NjkxLFxuXHRcIi4vdXJcIjogMTM3OTUsXG5cdFwiLi91ci5qc1wiOiAxMzc5NSxcblx0XCIuL3V6XCI6IDY3OTEsXG5cdFwiLi91ei1sYXRuXCI6IDYwNTg4LFxuXHRcIi4vdXotbGF0bi5qc1wiOiA2MDU4OCxcblx0XCIuL3V6LmpzXCI6IDY3OTEsXG5cdFwiLi92aVwiOiA2NTY2Nixcblx0XCIuL3ZpLmpzXCI6IDY1NjY2LFxuXHRcIi4veC1wc2V1ZG9cIjogMTQzNzgsXG5cdFwiLi94LXBzZXVkby5qc1wiOiAxNDM3OCxcblx0XCIuL3lvXCI6IDc1ODA1LFxuXHRcIi4veW8uanNcIjogNzU4MDUsXG5cdFwiLi96aC1jblwiOiA4MzgzOSxcblx0XCIuL3poLWNuLmpzXCI6IDgzODM5LFxuXHRcIi4vemgtaGtcIjogNTU3MjYsXG5cdFwiLi96aC1oay5qc1wiOiA1NTcyNixcblx0XCIuL3poLXR3XCI6IDc0MTUyLFxuXHRcIi4vemgtdHcuanNcIjogNzQxNTJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA0NjcwMDsiLCJpbXBvcnQgSFBhcnNvbnNGZWVkYmFjayBmcm9tIFwiLi9ocGFyc29uc0ZlZWRiYWNrXCI7XG5pbXBvcnQgQmxvY2tCYXNlZEdyYWRlciBmcm9tIFwiLi9ibG9ja0dyYWRlci5qc1wiO1xuaW1wb3J0IFwiLi4vLi4vcGFyc29ucy9qcy9wYXJzb25zLWkxOG4uZW4uanNcIjtcbmltcG9ydCBcIi4uLy4uL3BhcnNvbnMvanMvcGFyc29ucy1pMThuLnB0LWJyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NrRmVlZGJhY2sgZXh0ZW5kcyBIUGFyc29uc0ZlZWRiYWNrIHtcbiAgICBjcmVhdGVPdXRwdXQoKSB7XG4gICAgICAgIC8vIEJsb2NrIGJhc2VkIGdyYWRpbmcgb3V0cHV0XG4gICAgICAgIHRoaXMubWVzc2FnZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuaHBhcnNvbnMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5tZXNzYWdlRGl2KTtcbiAgICB9XG4gICAgY3VzdG9taXplVUkoKSB7XG4gICAgICAgICQodGhpcy5ocGFyc29ucy5ydW5CdXR0b24pLnRleHQoJ0NoZWNrIE1lJyk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogbm90IHN1cmUgd2hhdCBpcyB0aGUgYmVzdCB3YXkgdG8gZG8gdGhpc1xuICAgICAgICB0aGlzLmdyYWRlciA9IG5ldyBCbG9ja0Jhc2VkR3JhZGVyKCk7XG4gICAgICAgIGxldCBzb2x1dGlvbkJsb2NrcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaHBhcnNvbnMuYmxvY2tBbnN3ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNvbHV0aW9uQmxvY2tzLnB1c2godGhpcy5ocGFyc29ucy5vcmlnaW5hbEJsb2Nrc1t0aGlzLmhwYXJzb25zLmJsb2NrQW5zd2VyW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2x1dGlvbiA9IHNvbHV0aW9uQmxvY2tzO1xuICAgICAgICB0aGlzLmdyYWRlci5zb2x1dGlvbiA9IHNvbHV0aW9uQmxvY2tzO1xuICAgICAgICB0aGlzLmFuc3dlckFyZWEgPSB0aGlzLmhwYXJzb25zLmhwYXJzb25zSW5wdXQucXVlcnlTZWxlY3RvcignLmRyb3AtYXJlYScpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCB3aGVuIGNoZWNrIGJ1dHRvbiBjbGlja2VkIChibG9jay1iYXNlZCBGZWVkYmFjaylcbiAgICBhc3luYyBydW5CdXR0b25IYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmNoZWNrQ3VycmVudEFuc3dlcigpO1xuICAgICAgICB0aGlzLnJlbmRlckZlZWRiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gVXNlZCBmb3IgYmxvY2stYmFzZWQgZmVlZGJhY2tcbiAgICBjaGVja0N1cnJlbnRBbnN3ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5zb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZlZWRiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLmdyYWRlci5hbnN3ZXIgPSB0aGlzLmhwYXJzb25zLmhwYXJzb25zSW5wdXQuZ2V0UGFyc29uc1RleHRBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5ncmFkZSA9IHRoaXMuZ3JhZGVyLmdyYWRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmFkZSA9PSBcImNvcnJlY3RcIikge1xuICAgICAgICAgICAgICAgICQodGhpcy5ocGFyc29ucy5ydW5CdXR0b24pLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJGZWVkYmFjaygpIHtcbiAgICAgICAgdGhpcy5ncmFkZSA9IHRoaXMuZ3JhZGVyLmdyYWRlclN0YXRlO1xuICAgICAgICB2YXIgZmVlZGJhY2tBcmVhO1xuICAgICAgICB2YXIgYW5zd2VyQXJlYSA9ICQodGhpcy5hbnN3ZXJBcmVhKTtcbiAgICAgICAgZmVlZGJhY2tBcmVhID0gJCh0aGlzLm1lc3NhZ2VEaXYpO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYWRlID09PSBcImNvcnJlY3RcIikge1xuICAgICAgICAgICAgYW5zd2VyQXJlYS5hZGRDbGFzcyhcImNvcnJlY3RcIik7XG4gICAgICAgICAgICBmZWVkYmFja0FyZWEuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICBmZWVkYmFja0FyZWEuYXR0cihcImNsYXNzXCIsIFwiYWxlcnQgYWxlcnQtaW5mb1wiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgZmVlZGJhY2tBcmVhLmh0bWwoXG4gICAgICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19wYXJzb25fY29ycmVjdFwiLCB0aGlzLmNoZWNrQ291bnQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmVlZGJhY2tBcmVhLmh0bWwoJC5pMThuKFwibXNnX3BhcnNvbl9jb3JyZWN0X2ZpcnN0X3RyeVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhZGUgPT09IFwiaW5jb3JyZWN0VG9vU2hvcnRcIikge1xuICAgICAgICAgICAgLy8gdG9vIGxpdHRsZSBjb2RlXG4gICAgICAgICAgICBhbnN3ZXJBcmVhLmFkZENsYXNzKFwiaW5jb3JyZWN0XCIpO1xuICAgICAgICAgICAgZmVlZGJhY2tBcmVhLmZhZGVJbig1MDApO1xuICAgICAgICAgICAgZmVlZGJhY2tBcmVhLmF0dHIoXCJjbGFzc1wiLCBcImFsZXJ0IGFsZXJ0LWRhbmdlclwiKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQXJlYS5odG1sKCQuaTE4bihcIm1zZ19wYXJzb25fdG9vX3Nob3J0XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYWRlID09PSBcImluY29ycmVjdE1vdmVCbG9ja3NcIikge1xuICAgICAgICAgICAgdmFyIGFuc3dlckJsb2NrcyA9IHRoaXMuYW5zd2VyQXJlYS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBpblNvbHV0aW9uID0gW107XG4gICAgICAgICAgICB2YXIgaW5Tb2x1dGlvbkluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBub3RJblNvbHV0aW9uID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuc3dlckJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGFuc3dlckJsb2Nrc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNvbHV0aW9uLmluZGV4T2YoYmxvY2sudGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBub3RJblNvbHV0aW9uLnB1c2goYmxvY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluU29sdXRpb24ucHVzaChibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGluU29sdXRpb25JbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaXNJbmRleGVzID0gdGhpcy5ncmFkZXIuaW52ZXJzZUxJU0luZGljZXMoaW5Tb2x1dGlvbkluZGV4ZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXNJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm90SW5Tb2x1dGlvbi5wdXNoKGluU29sdXRpb25bbGlzSW5kZXhlc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5zd2VyQXJlYS5hZGRDbGFzcyhcImluY29ycmVjdFwiKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQXJlYS5mYWRlSW4oNTAwKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQXJlYS5hdHRyKFwiY2xhc3NcIiwgXCJhbGVydCBhbGVydC1kYW5nZXJcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vdEluU29sdXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkKG5vdEluU29sdXRpb25baV0pLmFkZENsYXNzKFwiaW5jb3JyZWN0UG9zaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZWVkYmFja0FyZWEuaHRtbCgkLmkxOG4oXCJtc2dfcGFyc29uX3dyb25nX29yZGVyXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZlZWRiYWNrIFVJIGZvciBCbG9jay1iYXNlZCBGZWVkYmFja1xuICAgIGNsZWFyRmVlZGJhY2soKSB7XG4gICAgICAgICQodGhpcy5hbnN3ZXJBcmVhKS5yZW1vdmVDbGFzcyhcImluY29ycmVjdCBjb3JyZWN0XCIpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmFuc3dlckFyZWEuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgJChjaGlsZHJlbltpXSkucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgICAgXCJjb3JyZWN0UG9zaXRpb24gaW5jb3JyZWN0UG9zaXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMubWVzc2FnZURpdikuaGlkZSgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAkKHRoaXMuaHBhcnNvbnMucnVuQnV0dG9uKS5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyRmVlZGJhY2soKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgSFBhcnNvbnNGZWVkYmFjayBmcm9tIFwiLi9ocGFyc29uc0ZlZWRiYWNrXCI7XG5pbXBvcnQgaW5pdFNxbEpzIGZyb20gXCJzcWwuanMvZGlzdC9zcWwtd2FzbS5qc1wiO1xuaW1wb3J0IEhhbmRzb250YWJsZSBmcm9tIFwiaGFuZHNvbnRhYmxlXCI7XG5pbXBvcnQgJ2hhbmRzb250YWJsZS9kaXN0L2hhbmRzb250YWJsZS5mdWxsLmNzcyc7XG5cbnZhciBhbGxEYnVybHMgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1FMRmVlZGJhY2sgZXh0ZW5kcyBIUGFyc29uc0ZlZWRiYWNrIHtcblxuICAgIGNyZWF0ZU91dHB1dCgpIHtcbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImhwX291dHB1dCBjb2wtbWQtMTJcIik7XG4gICAgICAgIHRoaXMub3V0RGl2ID0gb3V0RGl2O1xuICAgICAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgIHRoaXMub3V0cHV0LmlkID0gdGhpcy5ocGFyc29ucy5kaXZpZCArIFwiX3N0ZG91dFwiO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICB2YXIgY2xlYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKGNsZWFyRGl2KS5jc3MoXCJjbGVhclwiLCBcImJvdGhcIik7IC8vIG5lZWRlZCB0byBtYWtlIHBhcmVudCBkaXYgcmVzaXplIHByb3Blcmx5XG4gICAgICAgIHRoaXMuaHBhcnNvbnMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY2xlYXJEaXYpO1xuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5vdXRwdXQpO1xuICAgICAgICB0aGlzLmhwYXJzb25zLm91dGVyRGl2LmFwcGVuZENoaWxkKG91dERpdik7XG4gICAgICAgIGNsZWFyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgJChjbGVhckRpdikuY3NzKFwiY2xlYXJcIiwgXCJib3RoXCIpOyAvLyBuZWVkZWQgdG8gbWFrZSBwYXJlbnQgZGl2IHJlc2l6ZSBwcm9wZXJseVxuICAgICAgICB0aGlzLmhwYXJzb25zLm91dGVyRGl2LmFwcGVuZENoaWxkKGNsZWFyRGl2KTtcbiAgICB9XG5cbiAgICByZW5kZXJGZWVkYmFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dCh0aGlzLnRlc3RSZXN1bHQpO1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdygpO1xuICAgIH1cblxuICAgIGNsZWFyRmVlZGJhY2soKSB7XG4gICAgICAgICQodGhpcy5vdXREaXYpLmhpZGUoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jbGVhckZlZWRiYWNrKCk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgLy8gYWRhcHRlZCBmcm9tIGFjdGl2ZWNvZGUtc3FsXG4gICAgICAgIC8vIGZucHJlZml4IHNldHMgdGhlIHBhdGggdG8gbG9hZCB0aGUgc3FsLXdhc20ud2FzbSBmaWxlXG4gICAgICAgIHZhciBib29rcHJlZml4O1xuICAgICAgICB2YXIgZm5wcmVmaXg7XG4gICAgICAgIGlmIChlQm9va0NvbmZpZy51c2VSdW5lc3RvbmVTZXJ2aWNlcykge1xuICAgICAgICAgICAgYm9va3ByZWZpeCA9IGAke2VCb29rQ29uZmlnLmFwcH0vYm9va3MvcHVibGlzaGVkLyR7ZUJvb2tDb25maWcuYmFzZWNvdXJzZX1gO1xuICAgICAgICAgICAgZm5wcmVmaXggPSBib29rcHJlZml4ICsgXCIvX3N0YXRpY1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9va3ByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICBmbnByZWZpeCA9IFwiL19zdGF0aWNcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgU1FMY29uZmlnID0ge1xuICAgICAgICAgICAgbG9jYXRlRmlsZTogKGZpbGVuYW1lKSA9PiBgJHtmbnByZWZpeH0vJHtmaWxlbmFtZX1gLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMuaHBhcnNvbnM7XG4gICAgICAgIGluaXRTcWxKcyhTUUxjb25maWcpLnRoZW4oZnVuY3Rpb24gKFNRTCkge1xuICAgICAgICAgICAgLy8gc2V0IHVwIGNhbGwgdG8gbG9hZCBkYXRhYmFzZSBhc3luY2hyb25vdXNseSBpZiBnaXZlblxuICAgICAgICAgICAgaWYgKHNlbGYuZGJ1cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYnVybC5zdGFydHNXaXRoKFwiL19zdGF0aWNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYnVybCA9IGAke2Jvb2twcmVmaXh9JHtzZWxmLmRidXJsfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25UZXh0ID0gJChzZWxmLnJ1bkJ1dHRvbikudGV4dCgpO1xuICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbG9hZF9kYlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5kYnVybCBpbiBhbGxEYnVybHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4V2FpdEZvcjogalF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERidXJsc1tzZWxmLmRidXJsXS5zdGF0dXMgPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS54V2FpdEZvci5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRiID0gYWxsRGJ1cmxzW3NlbGYuZGJ1cmxdLmRiT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYiA9IGFsbERidXJsc1tzZWxmLmRidXJsXS5kYk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2xlcm9jaGEvY2hpbm9vay1kYXRhYmFzZS9yYXcvbWFzdGVyL0NoaW5vb2tEYXRhYmFzZS9EYXRhU291cmNlcy9DaGlub29rX1NxbGl0ZS5zcWxpdGVcbiAgICAgICAgICAgICAgICB4aHIub3BlbihcIkdFVFwiLCBzZWxmLmRidXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdUludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBuZXcgU1FMLkRhdGFiYXNlKHVJbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0uZGJPYmplY3QgPSBzZWxmLmRiO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS5kYiA9IHVJbnQ4QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS5zdGF0dXMgPSBcInJlYWR5XCI7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS54V2FpdEZvci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRlbnRzIGlzIG5vdyBbe2NvbHVtbnM6Wydjb2wxJywnY29sMicsLi4uXSwgdmFsdWVzOltbZmlyc3Qgcm93XSwgW3NlY29uZCByb3ddLCAuLi5dfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBuZXcgU1FMLkRhdGFiYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkYXB0ZWQgZnJvbSBhY3RpdmVjb2RlIC0gU1FMXG4gICAgYXN5bmMgcnVuQnV0dG9uSGFuZGxlcigpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgcnVuIGJ1dHRvbiB1bnRpbCB0aGUgcnVuIGlzIGZpbmlzaGVkLlxuICAgICAgICB0aGlzLmhwYXJzb25zLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1blByb2coKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHRoZXJlIHdhcyBhbiBlcnJvciAke2V9IHJ1bm5pbmcgdGhlIGNvZGVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ0N1cnJlbnRBbnN3ZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGZWVkYmFjaygpO1xuICAgICAgICAvLyBUaGUgcnVuIGlzIGZpbmlzaGVkOyByZS1lbmFibGUgdGhlIGJ1dHRvbi5cbiAgICAgICAgdGhpcy5ocGFyc29ucy5ydW5CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhZGFwdGVkIGZyb20gYWN0aXZlY29kZS1zcWxcbiAgICBhc3luYyBydW5Qcm9nKCkge1xuICAgICAgICAvLyBDbGVhciBhbnkgb2xkIHJlc3VsdHNcbiAgICAgICAgbGV0IGRpdmlkID0gdGhpcy5ocGFyc29ucy5kaXZpZCArIFwiX3NxbF9vdXRcIjtcbiAgICAgICAgbGV0IHJlc3BEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXZpZCk7XG4gICAgICAgIGlmIChyZXNwRGl2KSB7XG4gICAgICAgICAgICByZXNwRGl2LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocmVzcERpdik7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcIlwiKTtcbiAgICAgICAgLy8gUnVuIHRoaXMgcXVlcnlcbiAgICAgICAgbGV0IHF1ZXJ5ID0gYXdhaXQgdGhpcy5idWlsZFByb2coKTtcbiAgICAgICAgaWYgKCF0aGlzLmhwYXJzb25zLmRiKSB7XG4gICAgICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFxuICAgICAgICAgICAgICAgIGBFcnJvcjogRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkISBEQlVSTDogJHt0aGlzLmRidXJsfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXQgPSB0aGlzLmhwYXJzb25zLmRiLml0ZXJhdGVTdGF0ZW1lbnRzKHF1ZXJ5KTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZW1lbnQgb2YgaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9IHN0YXRlbWVudC5nZXRDb2x1bW5OYW1lcygpO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSEgcHJvYmFibHkgYSBTRUxFQ1RcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlbWVudC5zdGVwKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChzdGF0ZW1lbnQuZ2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Y291bnQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbnNxbCA9IHN0YXRlbWVudC5nZXROb3JtYWxpemVkU1FMKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVmaXggPSBuc3FsLnN1YnN0cigwLCA2KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQuc3RlcCgpOyAvLyBleGVjdXRlIHRoZSBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IElOU0VSVC9VUERBVEUvREVMRVRFIHRvIGdpdmUgZnJpZW5kbHkgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gcm93cyBtb2RpZmllZCAtIHVuZm9ydHVuYXRlbHksIHRoaXMgd29uJ3QgY2F0Y2ggc3VjaCBxdWVyaWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkgdXNlIENURXMuICBUaGVyZSBzZWVtcyB0byBiZSBubyByZWxpYWJsZSB3YXkgb2Yga25vd2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGEgU1FMaXRlIHF1ZXJ5IGFjdHVhbGx5IG1vZGlmaWVkIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9PT0gXCJpbnNlcnRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID09PSBcInVwZGF0ZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3djb3VudDogdGhpcy5kYi5nZXRSb3dzTW9kaWZpZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goeyBzdGF0dXM6IFwic3VjY2Vzc1wiIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImZhaWx1cmVcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3FsOiBpdC5nZXRSZW1haW5pbmdTUUwoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZmFpbHVyZVwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gcXVlcmllcyBzdWJtaXR0ZWQuXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXNwRGl2LmlkID0gZGl2aWQ7XG4gICAgICAgIHRoaXMub3V0RGl2LmFwcGVuZENoaWxkKHJlc3BEaXYpO1xuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KCk7XG4gICAgICAgIC8vIFNvbWV0aW1lcyB3ZSBkb24ndCB3YW50IHRvIHNob3cgYSBidW5jaCBvZiBpbnRlcm1lZGlhdGUgcmVzdWx0c1xuICAgICAgICAvLyBsaWtlIHdoZW4gd2UgYXJlIGluY2x1ZGluZyBhIGJ1bmNoIG9mIHByZXZpb3VzIHN0YXRlbWVudHMgZnJvbVxuICAgICAgICAvLyBvdGhlciBhY3RpdmVjb2RlcyBJbiB0aGF0IGNhc2UgdGhlIHNob3dsYXN0c3FsIGZsYWcgY2FuIGJlIHNldFxuICAgICAgICAvLyBzbyB3ZSBvbmx5IHNob3cgdGhlIGxhc3QgcmVzdWx0XG4gICAgICAgIGxldCByZXN1bHRBcnJheSA9IHRoaXMucmVzdWx0cztcbiAgICAgICAgZm9yIChsZXQgciBvZiByZXN1bHRBcnJheSkge1xuICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImhwX3NxbF9yZXN1bHRcIik7XG4gICAgICAgICAgICByZXNwRGl2LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHIuc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgICAgICAgIGlmIChyLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhYmxlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZCh0YWJsZURpdik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhIZWlnaHQgPSAzNTA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRBcnJheS5sZW5ndGggPiAxKSBtYXhIZWlnaHQgPSAyMDA7IC8vIG1heCBoZWlnaHQgc21hbGxlciBpZiBsb3RzIG9mIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUociwgdGFibGVEaXYsIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJtc2cgPSByLnJvd2NvdW50ICE9PSAxID8gXCIgcm93cyBcIiA6IFwiIHJvdyBcIjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1zZyA9IFwiXCIgKyByLnJvd2NvdW50ICsgcm1zZyArIFwicmV0dXJuZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIucm93Y291bnQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1zZyArIFwiIChvbmx5IGZpcnN0IDEwMCByb3dzIGRpc3BsYXllZClcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBtc2cgKyBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IG1zZztcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImhwX3NxbF9yZXN1bHRfc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChtZXNzYWdlQm94KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHIucm93Y291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3AgPSByLm9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBvcCArIChvcC5jaGFyQXQob3AubGVuZ3RoIC0gMSkgPT09IFwiZVwiID8gXCJkLlwiIDogXCJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBybXNnID0gci5yb3djb3VudCAhPT0gMSA/IFwiIHJvd3MgXCIgOiBcIiByb3cgXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSBcIlwiICsgci5yb3djb3VudCArIHJtc2cgKyBvcDtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImhwX3NxbF9yZXN1bHRfc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChtZXNzYWdlQm94KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSBcIk9wZXJhdGlvbiBzdWNjZWVkZWQuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJocF9zcWxfcmVzdWx0X3N1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQobWVzc2FnZUJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IHIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiaHBfc3FsX3Jlc3VsdF9mYWlsdXJlXCIpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQobWVzc2FnZUJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgaGFuZGxlIGF1dG9ncmFkaW5nXG4gICAgICAgIGlmICh0aGlzLmhwYXJzb25zLnVuaXR0ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHQgPSB0aGlzLmF1dG9ncmFkZShcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHNbdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXCJkb25lXCIpO1xuICAgIH1cblxuICAgIC8vIGFkYXB0ZWQgZnJvbSBhY3RpdmVjb2RlXG4gICAgYXN5bmMgYnVpbGRQcm9nKCkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdGV4dCBlbnRyeVxuICAgICAgICB2YXIgcHJvZztcbiAgICAgICAgaWYgKHRoaXMuaHBhcnNvbnMudGV4dGVudHJ5KSB7XG4gICAgICAgICAgICBwcm9nID0gdGhpcy5ocGFyc29ucy5ocGFyc29uc0lucHV0LmdldEN1cnJlbnRJbnB1dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvZyA9IHRoaXMuaHBhcnNvbnMuaHBhcnNvbnNJbnB1dC5nZXRQYXJzb25zVGV4dEFycmF5KCkuam9pbignICcpICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2cpO1xuICAgIH1cblxuICAgIC8vIGNvcGllZCBmcm9tIGFjdGl2ZWNvZGUtc3FsXG4gICAgYXN5bmMgbG9nQ3VycmVudEFuc3dlcihzaWQpIHtcbiAgICAgICAgLy8gY29tbWVudGluZyB0aGVzZSBvdXQgZm9yIG5vd1xuICAgICAgICAvLyBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGxvZyBydW4gZXZlbnQgaW4gaG9yaXpvbnRhbCBwYXJzb25zXG4gICAgICAgIC8vIGxldCBkYXRhID0ge1xuICAgICAgICAvLyAgICAgZGl2X2lkOiB0aGlzLmhwYXJzb25zLmRpdmlkLFxuICAgICAgICAvLyAgICAgY29kZTogdGhpcy5ocGFyc29ucy5ocGFyc29uc0lucHV0LmdldFBhcnNvbnNUZXh0QXJyYXkoKSxcbiAgICAgICAgLy8gICAgIGxhbmd1YWdlOiBcInNxbFwiLFxuICAgICAgICAvLyAgICAgLy8gZXJyaW5mbzogdGhpcy5yZXN1bHRzW3RoaXMucmVzdWx0cy5sZW5ndGggLSAxXS5zdGF0dXMsXG4gICAgICAgIC8vICAgICB0b19zYXZlOiB0aGlzLmhwYXJzb25zLnNhdmVDb2RlLFxuICAgICAgICAvLyAgICAgcHJlZml4OiB0aGlzLmhwYXJzb25zLnByZXRleHQsXG4gICAgICAgIC8vICAgICBzdWZmaXg6IHRoaXMuaHBhcnNvbnMuc3VmZml4LFxuICAgICAgICAvLyB9OyAvLyBMb2cgdGhlIHJ1biBldmVudFxuICAgICAgICAvLyBpZiAodHlwZW9mIHNpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyAgICAgZGF0YS5zaWQgPSBzaWQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gYXdhaXQgdGhpcy5ocGFyc29ucy5sb2dSdW5FdmVudChkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHMpIHtcbiAgICAgICAgICAgIGxldCB1bml0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJ1bml0dGVzdFwiLFxuICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5ocGFyc29ucy5kaXZpZCxcbiAgICAgICAgICAgICAgICBjb3Vyc2U6IGVCb29rQ29uZmlnLmNvdXJzZSxcbiAgICAgICAgICAgICAgICBhY3Q6IHRoaXMudW5pdF9yZXN1bHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2lkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdW5pdERhdGEuc2lkID0gc2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5ocGFyc29ucy5sb2dCb29rRXZlbnQodW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWlnaHQgbW92ZSB0byBiYXNlIGNsYXNzIGlmIHVzZWQgYnkgbXVsdGlwbGUgZXhlY3V0aW9uIGJhc2VkIGZlZWRiYWNrXG4gICAgYXV0b2dyYWRlKHJlc3VsdF90YWJsZSkge1xuICAgICAgICB2YXIgdGVzdHMgPSB0aGlzLmhwYXJzb25zLnVuaXR0ZXN0O1xuICAgICAgICB0aGlzLnBhc3NlZCA9IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gMDtcbiAgICAgICAgLy8gVGVzdHMgc2hvdWxkIGJlIG9mIHRoZSBmb3JtXG4gICAgICAgIC8vIGFzc2VydCByb3csY29sIG9wZXIgdmFsdWUgZm9yIGV4YW1wbGVcbiAgICAgICAgLy8gYXNzZXJ0IDQsNCA9PSAzXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB0ZXN0cyA9IHRlc3RzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHMuaW5kZXhPZihcImFzc2VydFwiKSA+IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgdGVzdCBvZiB0ZXN0cykge1xuICAgICAgICAgICAgbGV0IHdsaXN0ID0gdGVzdC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgd2xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIGxldCBsb2MgPSB3bGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgbGV0IG9wZXIgPSB3bGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgbGV0IGV4cGVjdGVkID0gd2xpc3Quam9pbihcIiBcIik7XG4gICAgICAgICAgICBsZXQgW3JvdywgY29sXSA9IGxvYy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50ZXN0T25lQXNzZXJ0KFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgb3BlcixcbiAgICAgICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICByZXN1bHRfdGFibGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGN0ID0gKDEwMCAqIHRoaXMucGFzc2VkKSAvICh0aGlzLnBhc3NlZCArIHRoaXMuZmFpbGVkKTtcbiAgICAgICAgcGN0ID0gcGN0LnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSk7XG4gICAgICAgIHJlc3VsdCArPSBgWW91IHBhc3NlZCAke3RoaXMucGFzc2VkfSBvdXQgb2YgJHt0aGlzLnBhc3NlZCArIHRoaXMuZmFpbGVkXG4gICAgICAgICAgICB9IHRlc3RzIGZvciAke3BjdH0lYDtcbiAgICAgICAgdGhpcy51bml0X3Jlc3VsdHMgPSBgcGVyY2VudDoke3BjdH06cGFzc2VkOiR7dGhpcy5wYXNzZWR9OmZhaWxlZDoke3RoaXMuZmFpbGVkfWA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gbWlnaHQgbW92ZSB0byBiYXNlIGNsYXNzIGlmIHVzZWQgYnkgbXVsdGlwbGUgZXhlY3V0aW9uIGJhc2VkIGZlZWRiYWNrXG4gICAgdGVzdE9uZUFzc2VydChyb3csIGNvbCwgb3BlciwgZXhwZWN0ZWQsIHJlc3VsdF90YWJsZSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcm93IGFuZCBjb2wgYXJlIGluIGJvdW5kc1xuICAgICAgICBsZXQgYWN0dWFsO1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFjdHVhbCA9IHJlc3VsdF90YWJsZS52YWx1ZXNbcm93XVtjb2xdO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT0gJ05PX0RBVEEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXNzZWQrKztcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBgUGFzc2VkOiBObyBkYXRhIGluIHJvdyAke3Jvd30sIGNvbHVtbiAke2NvbH1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGBGYWlsZWQ6IE5vdCBlbm91Z2ggZGF0YSB0byBjaGVjayByb3cgJHtyb3d9IG9yIGNvbHVtbiAke2NvbH1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgXCI9PVwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxID09IG9wZXJhbmQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiIT1cIjogZnVuY3Rpb24gKG9wZXJhbmQxLCBvcGVyYW5kMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSAhPSBvcGVyYW5kMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIj5cIjogZnVuY3Rpb24gKG9wZXJhbmQxLCBvcGVyYW5kMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSA+IG9wZXJhbmQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiPFwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxID4gb3BlcmFuZDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzID0gb3BlcmF0b3JzW29wZXJdKGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBgUGFzczogJHthY3R1YWx9ICR7b3Blcn0gJHtleHBlY3RlZH0gaW4gcm93ICR7cm93fSBjb2x1bW4gJHtyZXN1bHRfdGFibGUuY29sdW1uc1tjb2xdfWA7XG4gICAgICAgICAgICB0aGlzLnBhc3NlZCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gYEZhaWxlZCAke2FjdHVhbH0gJHtvcGVyfSAke2V4cGVjdGVkfSBpbiByb3cgJHtyb3d9IGNvbHVtbiAke3Jlc3VsdF90YWJsZS5jb2x1bW5zW2NvbF19YDtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKHRhYmxlRGF0YSwgY29udGFpbmVyLCBtYXhIZWlnaHQpIHtcbiAgICBsZXQgZGF0YSA9IHRhYmxlRGF0YS52YWx1ZXM7XG4gICAgbGV0IHRyaW1Sb3dzID0gdW5kZWZpbmVkO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBrbHVkZ2U6IG5vIGNvbHVtbiBoZWFkZXJzIHdpbGwgc2hvdyB1cCB1bmxlc3Mgd2UgZG8gdGhpc1xuICAgICAgICBkYXRhID0gW3RhYmxlRGF0YS5jb2x1bW5zLm1hcCgoZSkgPT4gbnVsbCldO1xuICAgICAgICB0cmltUm93cyA9IFswXTtcbiAgICB9XG5cbiAgICB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShjb250YWluZXIsIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHJpbVJvd3M6IHRyaW1Sb3dzLFxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICBhdXRvUm93U2l6ZTogdHJ1ZSxcbiAgICAgICAgYXV0b0NvbHVtblNpemU6IHsgdXNlSGVhZGVyczogdHJ1ZSB9LFxuICAgICAgICByb3dIZWFkZXJzOiBmYWxzZSxcbiAgICAgICAgY29sSGVhZGVyczogdGFibGVEYXRhLmNvbHVtbnMsXG4gICAgICAgIGVkaXRvcjogZmFsc2UsXG4gICAgICAgIG1heFJvd3M6IDEwMCxcbiAgICAgICAgZmlsdGVyczogZmFsc2UsXG4gICAgICAgIGRyb3Bkb3duTWVudTogZmFsc2UsXG4gICAgICAgIGxpY2Vuc2VLZXk6IFwibm9uLWNvbW1lcmNpYWwtYW5kLWV2YWx1YXRpb25cIixcbiAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgaGVpZ2h0IGFuZCByZXNpemVcbiAgICBsZXQgYWN0dWFsSGVpZ2h0ID0gNDA7IC8vIGhlYWRlciBoZWlnaHQgKyBzbWFsbCBtYXJnaW5cbiAgICBpZiAodGFibGVEYXRhLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gYWN0dWFsSGVpZ2h0ICsgaG90LmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgICAgIGlmIChhY3R1YWxIZWlnaHQgPiBtYXhIZWlnaHQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG90LnVwZGF0ZVNldHRpbmdzKHsgaGVpZ2h0OiBhY3R1YWxIZWlnaHQgfSk7XG5cbiAgICByZXR1cm4gaG90O1xufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGFkYXB0ZWQgZnJvbSBsaW5lR3JhZGVyIGluIHBhcnNvbnMgZGlyZWN0aXZlLlxuLy8gV2UgY291bGQgaGF2ZSBmaXQgb3VyIGRhdGEgc3RydWN0dXJlIHRvIHVzZSB0aGUgb3JpZ2luYWwgTGluZUJhc2VkR3JhZGVyIGRpcmVjdGx5LFxuLy8gYnV0IHRoYXQgd291bGQgcmVzdWx0IGluIGNoYW5nZXMgaW4gcGFyc29ucyBkaXJlY3RpdmUgYWZmZWN0aW5nIHRoaXMsIHNvIHdlIGNyZWF0ZWQgYSBjb3B5XG4vLyBpbnN0ZWFkLlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9ja0Jhc2VkR3JhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9ibGVtKSB7XG4gICAgICAgIHRoaXMucHJvYmxlbSA9IHByb2JsZW07XG4gICAgfVxuICAgIC8vIFVzZSBhIExJUyAoTG9uZ2VzdCBJbmNyZWFzaW5nIFN1YnNlcXVlbmNlKSBhbGdvcml0aG0gdG8gcmV0dXJuIHRoZSBpbmRleGVzXG4gICAgLy8gdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhhdCBzdWJzZXF1ZW5jZS5cbiAgICBpbnZlcnNlTElTSW5kaWNlcyhhcnIpIHtcbiAgICAgICAgLy8gR2V0IGFsbCBzdWJzZXF1ZW5jZXNcbiAgICAgICAgdmFyIGFsbFN1YnNlcXVlbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnNlcXVlbmNlRm9yQ3VycmVudCA9IFthcnJbaV1dLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhcnJbaV0sXG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnRBZGRlZCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2VxdWVudCA9IGFycltqXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2VxdWVudCA+IGN1cnJlbnQgJiYgbGFzdEVsZW1lbnRBZGRlZCA8IHN1YnNlcXVlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2VxdWVuY2VGb3JDdXJyZW50LnB1c2goc3Vic2VxdWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50QWRkZWQgPSBzdWJzZXF1ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbFN1YnNlcXVlbmNlcy5wdXNoKHN1YnNlcXVlbmNlRm9yQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgbG9uZ2VzdCBvbmVcbiAgICAgICAgdmFyIGxvbmdlc3RTdWJzZXF1ZW5jZUxlbmd0aCA9IC0xO1xuICAgICAgICB2YXIgbG9uZ2VzdFN1YnNlcXVlbmNlO1xuICAgICAgICBmb3IgKGxldCBpIGluIGFsbFN1YnNlcXVlbmNlcykge1xuICAgICAgICAgICAgdmFyIHN1YnMgPSBhbGxTdWJzZXF1ZW5jZXNbaV07XG4gICAgICAgICAgICBpZiAoc3Vicy5sZW5ndGggPiBsb25nZXN0U3Vic2VxdWVuY2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb25nZXN0U3Vic2VxdWVuY2VMZW5ndGggPSBzdWJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsb25nZXN0U3Vic2VxdWVuY2UgPSBzdWJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW52ZXJzZSBpbmRleGVzXG4gICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgIHZhciBsSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxJbmRleCA+IGxvbmdlc3RTdWJzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT0gbG9uZ2VzdFN1YnNlcXVlbmNlW2xJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbEluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICB9XG4gICAgLy8gZ3JhZGUgdGhhdCBlbGVtZW50LCByZXR1cm5pbmcgdGhlIHN0YXRlXG4gICAgZ3JhZGUoKSB7XG4gICAgICAgIHRoaXMuY29ycmVjdExpbmVzID0gMDtcbiAgICAgICAgdGhpcy5wZXJjZW50TGluZXMgPSAwO1xuICAgICAgICB2YXIgc29sdXRpb25MaW5lcyA9IHRoaXMuc29sdXRpb247XG4gICAgICAgIHZhciBhbnN3ZXJMaW5lcyA9IHRoaXMuYW5zd2VyO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHN0YXRlO1xuICAgICAgICB0aGlzLnBlcmNlbnRMaW5lcyA9XG4gICAgICAgICAgICBNYXRoLm1pbihhbnN3ZXJMaW5lcy5sZW5ndGgsIHNvbHV0aW9uTGluZXMubGVuZ3RoKSAvXG4gICAgICAgICAgICBNYXRoLm1heChhbnN3ZXJMaW5lcy5sZW5ndGgsIHNvbHV0aW9uTGluZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGFuc3dlckxpbmVzLmxlbmd0aCA8IHNvbHV0aW9uTGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiaW5jb3JyZWN0VG9vU2hvcnRcIjtcbiAgICAgICAgICAgIHRoaXMuY29ycmVjdExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGFuc3dlckxpbmVzLmxlbmd0aCA9PSBzb2x1dGlvbkxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jb3JyZWN0TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ycmVjdExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNvZGUgKip0aGF0IGlzIHRoZXJlKiogaXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgdG9vIG11Y2ggb3IgdG9vIGxpdHRsZSBjb2RlIHRoaXMgb25seSBtYXR0ZXJzIGZvclxuICAgICAgICAvLyBjYWxjdWxhdGluZyBhIHBlcmNlbnRhZ2Ugc2NvcmUuXG4gICAgICAgIGxldCBpc0NvcnJlY3RPcmRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuY29ycmVjdExpbmVzID0gMDtcbiAgICAgICAgdGhpcy5zb2x1dGlvbkxlbmd0aCA9IHNvbHV0aW9uTGluZXMubGVuZ3RoO1xuICAgICAgICBsZXQgbG9vcExpbWl0ID0gTWF0aC5taW4oc29sdXRpb25MaW5lcy5sZW5ndGgsIGFuc3dlckxpbmVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsb29wTGltaXQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFuc3dlckxpbmVzW2ldICE9PSBzb2x1dGlvbkxpbmVzW2ldKSB7XG4gICAgICAgICAgICAgICAgaXNDb3JyZWN0T3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWN0TGluZXMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzQ29ycmVjdE9yZGVyICYmXG4gICAgICAgICAgICB0aGlzLmNvcnJlY3RMZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBQZXJmZWN0XG4gICAgICAgICAgICBzdGF0ZSA9IFwiY29ycmVjdFwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NvcnJlY3RPcmRlciAmJiBzdGF0ZSAhPSBcImluY29ycmVjdFRvb1Nob3J0XCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJpbmNvcnJlY3RNb3ZlQmxvY2tzXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVQZXJjZW50KCk7XG4gICAgICAgIHRoaXMuZ3JhZGVyU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVBlcmNlbnQoKSB7XG4gICAgICAgIGxldCBudW1MaW5lcyA9IHRoaXMucGVyY2VudExpbmVzICogMC4yO1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmFuc3dlci5sZW5ndGg7XG4gICAgICAgIGxldCBudW1Db3JyZWN0QmxvY2tzID0gKHRoaXMuY29ycmVjdExpbmVzIC8gbGluZXMpICogMC44O1xuXG4gICAgICAgIHRoaXMucGVyY2VudCA9IG51bUxpbmVzICsgbnVtQ29ycmVjdEJsb2NrcztcbiAgICB9XG59XG4iLCIvKiohXG4gKiBTb3J0YWJsZSAxLjE0LjBcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIHZlcnNpb24kMSA9IFwiMS4xNC4wXCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhIC8qQF9fUFVSRV9fKi9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICB9XG59XG5cbnZhciBJRTExT3JMZXNzID0gdXNlckFnZW50KC8oPzpUcmlkZW50LipydlsgOl0/MTFcXC58bXNpZXxpZW1vYmlsZXxXaW5kb3dzIFBob25lKS9pKTtcbnZhciBFZGdlID0gdXNlckFnZW50KC9FZGdlL2kpO1xudmFyIEZpcmVGb3ggPSB1c2VyQWdlbnQoL2ZpcmVmb3gvaSk7XG52YXIgU2FmYXJpID0gdXNlckFnZW50KC9zYWZhcmkvaSkgJiYgIXVzZXJBZ2VudCgvY2hyb21lL2kpICYmICF1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG52YXIgSU9TID0gdXNlckFnZW50KC9pUChhZHxvZHxob25lKS9pKTtcbnZhciBDaHJvbWVGb3JBbmRyb2lkID0gdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuXG52YXIgY2FwdHVyZU1vZGUgPSB7XG4gIGNhcHR1cmU6IGZhbHNlLFxuICBwYXNzaXZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICBzZWxlY3RvclswXSA9PT0gJz4nICYmIChzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG5cbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE9ySG9zdChlbCkge1xuICByZXR1cm4gZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSA/IGVsLmhvc3QgOiBlbC5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0KFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IsXG4vKipIVE1MRWxlbWVudCovXG5jdHgsIGluY2x1ZGVDVFgpIHtcbiAgaWYgKGVsKSB7XG4gICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwgPT09IGN0eCkgYnJlYWs7XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgfSB3aGlsZSAoZWwgPSBnZXRQYXJlbnRPckhvc3QoZWwpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xuICBpZiAoZWwgJiYgbmFtZSkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGVsLmNsYXNzTGlzdFtzdGF0ZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShSX1NQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IChjbGFzc05hbWUgKyAoc3RhdGUgPyAnICcgKyBuYW1lIDogJycpKS5yZXBsYWNlKFJfU1BBQ0UsICcgJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xuICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcblxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gZWw7XG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNzcyhlbCwgJ3RyYW5zZm9ybScpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgdmFyIG1hdHJpeEZuID0gd2luZG93LkRPTU1hdHJpeCB8fCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4IHx8IHdpbmRvdy5DU1NNYXRyaXggfHwgd2luZG93Lk1TQ1NTTWF0cml4O1xuICAvKmpzaGludCAtVzA1NiAqL1xuXG4gIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgaWYgKGN0eCkge1xuICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gIGlmIChzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcImJvdW5kaW5nIGNsaWVudCByZWN0XCIgb2YgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIHJlbGF0aXZlIHBhcmVudCBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpZW5yXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHVuZG9TY2FsZSAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGNvbnRhaW5lcidzIHNjYWxlKCkgc2hvdWxkIGJlIHVuZG9uZVxuICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWwsIHdpdGggc3BlY2lmaWVkIGFkanVzdG1lbnRzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcblxuICBpZiAoZWwgIT09IHdpbmRvdyAmJiBlbC5wYXJlbnROb2RlICYmIGVsICE9PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0b3AgPSBlbFJlY3QudG9wO1xuICAgIGxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICBib3R0b20gPSBlbFJlY3QuYm90dG9tO1xuICAgIHJpZ2h0ID0gZWxSZWN0LnJpZ2h0O1xuICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgd2lkdGggPSBlbFJlY3Qud2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gMDtcbiAgICBsZWZ0ID0gMDtcbiAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgcmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIGlmICgocmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50KSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlOyAvLyBzb2x2ZXMgIzExMjMgKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3OTUzODA2LzYwODgzMTIpXG4gICAgLy8gTm90IG5lZWRlZCBvbiA8PSBJRTExXG5cbiAgICBpZiAoIUlFMTFPckxlc3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChjc3MoY29udGFpbmVyLCAndHJhbnNmb3JtJykgIT09ICdub25lJyB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICYmIGNzcyhjb250YWluZXIsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gU2V0IHJlbGF0aXZlIHRvIGVkZ2VzIG9mIHBhZGRpbmcgYm94IG9mIGNvbnRhaW5lclxuXG4gICAgICAgICAgdG9wIC09IGNvbnRhaW5lclJlY3QudG9wICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XG4gICAgICAgICAgbGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XG4gICAgICAgICAgYm90dG9tID0gdG9wICsgZWxSZWN0LmhlaWdodDtcbiAgICAgICAgICByaWdodCA9IGxlZnQgKyBlbFJlY3Qud2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgICB9IHdoaWxlIChjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuZG9TY2FsZSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciBzY2FsZSgpXG4gICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGNvbnRhaW5lciB8fCBlbCksXG4gICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQ7XG5cbiAgICBpZiAoZWxNYXRyaXgpIHtcbiAgICAgIHRvcCAvPSBzY2FsZVk7XG4gICAgICBsZWZ0IC89IHNjYWxlWDtcbiAgICAgIHdpZHRoIC89IHNjYWxlWDtcbiAgICAgIGhlaWdodCAvPSBzY2FsZVk7XG4gICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzaWRlIG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgcGFzdCBhIHNpZGUgb2YgaXRzIHBhcmVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgZWxTaWRlICAgICAgIFNpZGUgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBwYXJlbnRTaWRlICAgU2lkZSBvZiB0aGUgcGFyZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBpc1Njcm9sbGVkUGFzdChlbCwgZWxTaWRlLCBwYXJlbnRTaWRlKSB7XG4gIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgdHJ1ZSksXG4gICAgICBlbFNpZGVWYWwgPSBnZXRSZWN0KGVsKVtlbFNpZGVdO1xuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHZhciBwYXJlbnRTaWRlVmFsID0gZ2V0UmVjdChwYXJlbnQpW3BhcmVudFNpZGVdLFxuICAgICAgICB2aXNpYmxlID0gdm9pZCAwO1xuXG4gICAgaWYgKHBhcmVudFNpZGUgPT09ICd0b3AnIHx8IHBhcmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA+PSBwYXJlbnRTaWRlVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsIDw9IHBhcmVudFNpZGVWYWw7XG4gICAgfVxuXG4gICAgaWYgKCF2aXNpYmxlKSByZXR1cm4gcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkgYnJlYWs7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdldHMgbnRoIGNoaWxkIG9mIGVsLCBpZ25vcmluZyBoaWRkZW4gY2hpbGRyZW4sIHNvcnRhYmxlJ3MgZWxlbWVudHMgKGRvZXMgbm90IGlnbm9yZSBjbG9uZSBpZiBpdCdzIHZpc2libGUpXG4gKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFRoZSBwYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7TnVtYmVyfSBjaGlsZE51bSAgICAgIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGNoaWxkIGF0IGluZGV4IGNoaWxkTnVtLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zLCBpbmNsdWRlRHJhZ0VsKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgICAgaSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgKGluY2x1ZGVEcmFnRWwgfHwgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQpICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRDaGlsZCsrO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBlbCwgaWdub3JpbmcgZ2hvc3RFbCBvciBpbnZpc2libGUgZWxlbWVudHMgKGNsb25lcylcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGxhc3QgY2hpbGQsIGlnbm9yaW5nIGdob3N0RWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuXG4gIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3QgfHwgbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcbiAqIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cblxuICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdURU1QTEFURScgJiYgZWwgIT09IFNvcnRhYmxlLmNsb25lICYmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXG4gKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGVsKSB7XG4gIHZhciBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcblxuICBpZiAoZWwpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoZWwpLFxuICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXguZDtcbiAgICAgIG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcbiAgICAgIG9mZnNldFRvcCArPSBlbC5zY3JvbGxUb3AgKiBzY2FsZVk7XG4gICAgfSB3aGlsZSAoZWwgIT09IHdpblNjcm9sbGVyICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyICAgQXJyYXkgdGhhdCBtYXkgb3IgbWF5IG5vdCBob2xkIHRoZSBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICBBbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpciB1bmlxdWUgdG8gYW5kIGlkZW50aWNhbCB0byBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gZmluZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gPT09IGFycltpXVtrZXldKSByZXR1cm4gTnVtYmVyKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gIC8vIHNraXAgdG8gd2luZG93XG4gIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIGVsZW0gPSBlbDtcbiAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBnZXQgZWxlbSBjc3MgaWYgaXQgaXNuJ3QgZXZlbiBvdmVyZmxvd2luZyBpbiB0aGUgZmlyc3QgcGxhY2UgKHBlcmZvcm1hbmNlKVxuICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbUNTUyA9IGNzcyhlbGVtKTtcblxuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuZnVuY3Rpb24gaXNSZWN0RXF1YWwocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlY3QxLnRvcCkgPT09IE1hdGgucm91bmQocmVjdDIudG9wKSAmJiBNYXRoLnJvdW5kKHJlY3QxLmxlZnQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmxlZnQpICYmIE1hdGgucm91bmQocmVjdDEuaGVpZ2h0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5oZWlnaHQpICYmIE1hdGgucm91bmQocmVjdDEud2lkdGgpID09PSBNYXRoLnJvdW5kKHJlY3QyLndpZHRoKTtcbn1cblxudmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFRocm90dGxlKCkge1xuICBjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XG4gIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgZWwuc2Nyb2xsVG9wICs9IHk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG5cbiAgaWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcbiAgICByZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcbiAgfSBlbHNlIGlmICgkKSB7XG4gICAgcmV0dXJuICQoZWwpLmNsb25lKHRydWUpWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gIH1cbn1cblxudmFyIGV4cGFuZG8gPSAnU29ydGFibGUnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpIHtcbiAgdmFyIGFuaW1hdGlvblN0YXRlcyA9IFtdLFxuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZDtcbiAgcmV0dXJuIHtcbiAgICBjYXB0dXJlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGNhcHR1cmVBbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSByZXR1cm47XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4pO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNzcyhjaGlsZCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IGNoaWxkID09PSBTb3J0YWJsZS5naG9zdCkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZCxcbiAgICAgICAgICByZWN0OiBnZXRSZWN0KGNoaWxkKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZnJvbVJlY3QgPSBfb2JqZWN0U3ByZWFkMih7fSwgYW5pbWF0aW9uU3RhdGVzW2FuaW1hdGlvblN0YXRlcy5sZW5ndGggLSAxXS5yZWN0KTsgLy8gSWYgYW5pbWF0aW5nOiBjb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuXG5cbiAgICAgICAgaWYgKGNoaWxkLnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIHZhciBjaGlsZE1hdHJpeCA9IG1hdHJpeChjaGlsZCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGRNYXRyaXgpIHtcbiAgICAgICAgICAgIGZyb21SZWN0LnRvcCAtPSBjaGlsZE1hdHJpeC5mO1xuICAgICAgICAgICAgZnJvbVJlY3QubGVmdCAtPSBjaGlsZE1hdHJpeC5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLmZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFkZEFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBhZGRBbmltYXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH0sXG4gICAgcmVtb3ZlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIHJlbW92ZUFuaW1hdGlvblN0YXRlKHRhcmdldCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnNwbGljZShpbmRleE9mT2JqZWN0KGFuaW1hdGlvblN0YXRlcywge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSksIDEpO1xuICAgIH0sXG4gICAgYW5pbWF0ZUFsbDogZnVuY3Rpb24gYW5pbWF0ZUFsbChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5pbWF0aW5nID0gZmFsc2UsXG4gICAgICAgICAgYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgZnJvbVJlY3QgPSB0YXJnZXQuZnJvbVJlY3QsXG4gICAgICAgICAgICB0b1JlY3QgPSBnZXRSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBwcmV2RnJvbVJlY3QgPSB0YXJnZXQucHJldkZyb21SZWN0LFxuICAgICAgICAgICAgcHJldlRvUmVjdCA9IHRhcmdldC5wcmV2VG9SZWN0LFxuICAgICAgICAgICAgYW5pbWF0aW5nUmVjdCA9IHN0YXRlLnJlY3QsXG4gICAgICAgICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXgodGFyZ2V0LCB0cnVlKTtcblxuICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgICAgLy8gQ29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgICB0b1JlY3QudG9wIC09IHRhcmdldE1hdHJpeC5mO1xuICAgICAgICAgIHRvUmVjdC5sZWZ0IC09IHRhcmdldE1hdHJpeC5lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICBpZiAodGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIENvdWxkIGFsc28gY2hlY2sgaWYgYW5pbWF0aW5nUmVjdCBpcyBiZXR3ZWVuIGZyb21SZWN0IGFuZCB0b1JlY3RcbiAgICAgICAgICBpZiAoaXNSZWN0RXF1YWwocHJldkZyb21SZWN0LCB0b1JlY3QpICYmICFpc1JlY3RFcXVhbChmcm9tUmVjdCwgdG9SZWN0KSAmJiAvLyBNYWtlIHN1cmUgYW5pbWF0aW5nUmVjdCBpcyBvbiBsaW5lIGJldHdlZW4gdG9SZWN0ICYgZnJvbVJlY3RcbiAgICAgICAgICAoYW5pbWF0aW5nUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChhbmltYXRpbmdSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgPT09IChmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpKSB7XG4gICAgICAgICAgICAvLyBJZiByZXR1cm5pbmcgdG8gc2FtZSBwbGFjZSBhcyBzdGFydGVkIGZyb20gYW5pbWF0aW9uIGFuZCBvbiBzYW1lIGF4aXNcbiAgICAgICAgICAgIHRpbWUgPSBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBwcmV2RnJvbVJlY3QsIHByZXZUb1JlY3QsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBmcm9tUmVjdCAhPSB0b1JlY3Q6IGFuaW1hdGVcblxuXG4gICAgICAgIGlmICghaXNSZWN0RXF1YWwodG9SZWN0LCBmcm9tUmVjdCkpIHtcbiAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5hbmltYXRlKHRhcmdldCwgYW5pbWF0aW5nUmVjdCwgdG9SZWN0LCB0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gTWF0aC5tYXgoYW5pbWF0aW9uVGltZSwgdGltZSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuXG4gICAgICBpZiAoIWFuaW1hdGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGFuaW1hdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUodGFyZ2V0LCBjdXJyZW50UmVjdCwgdG9SZWN0LCBkdXJhdGlvbikge1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgodGhpcy5lbCksXG4gICAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAoY3VycmVudFJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gKGN1cnJlbnRSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKHNjYWxlWSB8fCAxKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSAhIXRyYW5zbGF0ZVg7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gISF0cmFuc2xhdGVZO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCcgKyB0cmFuc2xhdGVZICsgJ3B4LDApJyk7XG4gICAgICAgIHRoaXMuZm9yUmVwYWludER1bW15ID0gcmVwYWludCh0YXJnZXQpOyAvLyByZXBhaW50XG5cbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAndHJhbnNmb3JtICcgKyBkdXJhdGlvbiArICdtcycgKyAodGhpcy5vcHRpb25zLmVhc2luZyA/ICcgJyArIHRoaXMub3B0aW9ucy5lYXNpbmcgOiAnJykpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuICAgICAgICB0eXBlb2YgdGFyZ2V0LmFuaW1hdGVkID09PSAnbnVtYmVyJyAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gZmFsc2U7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcGFpbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQub2Zmc2V0V2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIGZyb21SZWN0LCB0b1JlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSBhbmltYXRpbmdSZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gYW5pbWF0aW5nUmVjdC5sZWZ0LCAyKSkgLyBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQsIDIpKSAqIG9wdGlvbnMuYW5pbWF0aW9uO1xufVxuXG52YXIgcGx1Z2lucyA9IFtdO1xudmFyIGRlZmF1bHRzID0ge1xuICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG59O1xudmFyIFBsdWdpbk1hbmFnZXIgPSB7XG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChwbHVnaW4pIHtcbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0aWMgcHJvcGVydGllc1xuICAgIGZvciAodmFyIG9wdGlvbiBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgIShvcHRpb24gaW4gcGx1Z2luKSkge1xuICAgICAgICBwbHVnaW5bb3B0aW9uXSA9IGRlZmF1bHRzW29wdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocC5wbHVnaW5OYW1lID09PSBwbHVnaW4ucGx1Z2luTmFtZSkge1xuICAgICAgICB0aHJvdyBcIlNvcnRhYmxlOiBDYW5ub3QgbW91bnQgcGx1Z2luIFwiLmNvbmNhdChwbHVnaW4ucGx1Z2luTmFtZSwgXCIgbW9yZSB0aGFuIG9uY2VcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH0sXG4gIHBsdWdpbkV2ZW50OiBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlLCBldnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5ldmVudENhbmNlbGVkID0gZmFsc2U7XG5cbiAgICBldnQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZXZlbnRDYW5jZWxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBldmVudE5hbWVHbG9iYWwgPSBldmVudE5hbWUgKyAnR2xvYmFsJztcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gRmlyZSBnbG9iYWwgZXZlbnRzIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXShfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgIH0sIGV2dCkpO1xuICAgICAgfSAvLyBPbmx5IGZpcmUgcGx1Z2luIGV2ZW50IGlmIHBsdWdpbiBpcyBlbmFibGVkIGluIHRoaXMgc29ydGFibGUsXG4gICAgICAvLyBhbmQgcGx1Z2luIGhhcyBldmVudCBkZWZpbmVkXG5cblxuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luLnBsdWdpbk5hbWVdICYmIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkOyAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG5cbiAgICAgIF9leHRlbmRzKGRlZmF1bHRzLCBpbml0aWFsaXplZC5kZWZhdWx0cyk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIF9leHRlbmRzKGV2ZW50UHJvcGVydGllcywgcGx1Z2luLmV2ZW50UHJvcGVydGllcy5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgbmFtZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBldmVudFByb3BlcnRpZXM7XG4gIH0sXG4gIG1vZGlmeU9wdGlvbjogZnVuY3Rpb24gbW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtb2RpZmllZFZhbHVlO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAvLyBQbHVnaW4gbXVzdCBleGlzdCBvbiB0aGUgU29ydGFibGVcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIElmIHN0YXRpYyBvcHRpb24gbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIG9wdGlvbiwgY2FsbCBpbiB0aGUgY29udGV4dCBvZiB0aGUgU29ydGFibGUncyBpbnN0YW5jZSBvZiB0aGlzIHBsdWdpblxuXG4gICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgICB0b0VsID0gX3JlZi50b0VsLFxuICAgICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCA9IF9yZWYubmV3SW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgdmFyIGV2dCxcbiAgICAgIG9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zLFxuICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xuICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gIGV2dC5pdGVtID0gdGFyZ2V0RWwgfHwgcm9vdEVsO1xuICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuICBldnQub2xkSW5kZXggPSBvbGRJbmRleDtcbiAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gIGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICBldnQubmV3RHJhZ2dhYmxlSW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xuXG4gIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFFdmVudFByb3BlcnRpZXMpLCBQbHVnaW5NYW5hZ2VyLmdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkpO1xuXG4gIGZvciAodmFyIG9wdGlvbiBpbiBhbGxFdmVudFByb3BlcnRpZXMpIHtcbiAgICBldnRbb3B0aW9uXSA9IGFsbEV2ZW50UHJvcGVydGllc1tvcHRpb25dO1xuICB9XG5cbiAgaWYgKHJvb3RFbCkge1xuICAgIHJvb3RFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cblxuICBpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG4gICAgb3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XG4gIH1cbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImV2dFwiXTtcblxudmFyIHBsdWdpbkV2ZW50ID0gZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5ldnQsXG4gICAgICBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgUGx1Z2luTWFuYWdlci5wbHVnaW5FdmVudC5iaW5kKFNvcnRhYmxlKShldmVudE5hbWUsIHNvcnRhYmxlLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBkYXRhKSk7XG59O1xuXG5mdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChpbmZvKSB7XG4gIGRpc3BhdGNoRXZlbnQoX29iamVjdFNwcmVhZDIoe1xuICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIHRhcmdldEVsOiBkcmFnRWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4XG4gIH0sIGluZm8pKTtcbn1cblxudmFyIGRyYWdFbCxcbiAgICBwYXJlbnRFbCxcbiAgICBnaG9zdEVsLFxuICAgIHJvb3RFbCxcbiAgICBuZXh0RWwsXG4gICAgbGFzdERvd25FbCxcbiAgICBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuLFxuICAgIG9sZEluZGV4LFxuICAgIG5ld0luZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4LFxuICAgIGFjdGl2ZUdyb3VwLFxuICAgIHB1dFNvcnRhYmxlLFxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZSxcbiAgICBzb3J0YWJsZXMgPSBbXSxcbiAgICB0YXBFdnQsXG4gICAgdG91Y2hFdnQsXG4gICAgbGFzdER4LFxuICAgIGxhc3REeSxcbiAgICB0YXBEaXN0YW5jZUxlZnQsXG4gICAgdGFwRGlzdGFuY2VUb3AsXG4gICAgbW92ZWQsXG4gICAgbGFzdFRhcmdldCxcbiAgICBsYXN0RGlyZWN0aW9uLFxuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlLFxuICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZSxcbiAgICB0YXJnZXRNb3ZlRGlzdGFuY2UsXG4gICAgLy8gRm9yIHBvc2l0aW9uaW5nIGdob3N0IGFic29sdXRlbHlcbmdob3N0UmVsYXRpdmVQYXJlbnQsXG4gICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBbXSxcbiAgICAvLyAobGVmdCwgdG9wKVxuX3NpbGVudCA9IGZhbHNlLFxuICAgIHNhdmVkSW5wdXRDaGVja2VkID0gW107XG4vKiogQGNvbnN0ICovXG5cbnZhciBkb2N1bWVudEV4aXN0cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPSBJT1MsXG4gICAgQ1NTRmxvYXRQcm9wZXJ0eSA9IEVkZ2UgfHwgSUUxMU9yTGVzcyA/ICdjc3NGbG9hdCcgOiAnZmxvYXQnLFxuICAgIC8vIFRoaXMgd2lsbCBub3QgcGFzcyBmb3IgSUU5LCBiZWNhdXNlIElFOSBEbkQgb25seSB3b3JrcyBvbiBhbmNob3JzXG5zdXBwb3J0RHJhZ2dhYmxlID0gZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQgJiYgIUlPUyAmJiAnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFkb2N1bWVudEV4aXN0cykgcmV0dXJuOyAvLyBmYWxzZSB3aGVuIDw9IElFMTFcblxuICBpZiAoSUUxMU9yTGVzcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcbiAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcbiAgcmV0dXJuIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPT09ICdhdXRvJztcbn0oKSxcbiAgICBfZGV0ZWN0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2RldGVjdERpcmVjdGlvbihlbCwgb3B0aW9ucykge1xuICB2YXIgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgZWxXaWR0aCA9IHBhcnNlSW50KGVsQ1NTLndpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdSaWdodCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJMZWZ0V2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyUmlnaHRXaWR0aCksXG4gICAgICBjaGlsZDEgPSBnZXRDaGlsZChlbCwgMCwgb3B0aW9ucyksXG4gICAgICBjaGlsZDIgPSBnZXRDaGlsZChlbCwgMSwgb3B0aW9ucyksXG4gICAgICBmaXJzdENoaWxkQ1NTID0gY2hpbGQxICYmIGNzcyhjaGlsZDEpLFxuICAgICAgc2Vjb25kQ2hpbGRDU1MgPSBjaGlsZDIgJiYgY3NzKGNoaWxkMiksXG4gICAgICBmaXJzdENoaWxkV2lkdGggPSBmaXJzdENoaWxkQ1NTICYmIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQxKS53aWR0aCxcbiAgICAgIHNlY29uZENoaWxkV2lkdGggPSBzZWNvbmRDaGlsZENTUyAmJiBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQyKS53aWR0aDtcblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4nIHx8IGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdncmlkJykge1xuICAgIHJldHVybiBlbENTUy5ncmlkVGVtcGxhdGVDb2x1bW5zLnNwbGl0KCcgJykubGVuZ3RoIDw9IDEgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgaWYgKGNoaWxkMSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICE9PSAnbm9uZScpIHtcbiAgICB2YXIgdG91Y2hpbmdTaWRlQ2hpbGQyID0gZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdID09PSAnbGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIHJldHVybiBjaGlsZDIgJiYgKHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSAnYm90aCcgfHwgc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09IHRvdWNoaW5nU2lkZUNoaWxkMikgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkMSAmJiAoZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnYmxvY2snIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ3RhYmxlJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdncmlkJyB8fCBmaXJzdENoaWxkV2lkdGggPj0gZWxXaWR0aCAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnIHx8IGNoaWxkMiAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnICYmIGZpcnN0Q2hpbGRXaWR0aCArIHNlY29uZENoaWxkV2lkdGggPiBlbFdpZHRoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG59LFxuICAgIF9kcmFnRWxJblJvd0NvbHVtbiA9IGZ1bmN0aW9uIF9kcmFnRWxJblJvd0NvbHVtbihkcmFnUmVjdCwgdGFyZ2V0UmVjdCwgdmVydGljYWwpIHtcbiAgdmFyIGRyYWdFbFMxT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5sZWZ0IDogZHJhZ1JlY3QudG9wLFxuICAgICAgZHJhZ0VsUzJPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LnJpZ2h0IDogZHJhZ1JlY3QuYm90dG9tLFxuICAgICAgZHJhZ0VsT3BwTGVuZ3RoID0gdmVydGljYWwgPyBkcmFnUmVjdC53aWR0aCA6IGRyYWdSZWN0LmhlaWdodCxcbiAgICAgIHRhcmdldFMxT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmxlZnQgOiB0YXJnZXRSZWN0LnRvcCxcbiAgICAgIHRhcmdldFMyT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnJpZ2h0IDogdGFyZ2V0UmVjdC5ib3R0b20sXG4gICAgICB0YXJnZXRPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3Qud2lkdGggOiB0YXJnZXRSZWN0LmhlaWdodDtcbiAgcmV0dXJuIGRyYWdFbFMxT3BwID09PSB0YXJnZXRTMU9wcCB8fCBkcmFnRWxTMk9wcCA9PT0gdGFyZ2V0UzJPcHAgfHwgZHJhZ0VsUzFPcHAgKyBkcmFnRWxPcHBMZW5ndGggLyAyID09PSB0YXJnZXRTMU9wcCArIHRhcmdldE9wcExlbmd0aCAvIDI7XG59LFxuXG4vKipcbiAqIERldGVjdHMgZmlyc3QgbmVhcmVzdCBlbXB0eSBzb3J0YWJsZSB0byBYIGFuZCBZIHBvc2l0aW9uIHVzaW5nIGVtcHR5SW5zZXJ0VGhyZXNob2xkLlxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgWCBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgWSBwb3NpdGlvblxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgRWxlbWVudCBvZiB0aGUgZmlyc3QgZm91bmQgbmVhcmVzdCBTb3J0YWJsZVxuICovXG5fZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbiBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoeCwgeSkge1xuICB2YXIgcmV0O1xuICBzb3J0YWJsZXMuc29tZShmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZDtcbiAgICBpZiAoIXRocmVzaG9sZCB8fCBsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgaWYgKGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XG4gICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn0sXG4gICAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgZHJhZ0VsLCBldnQpIHtcbiAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIGFuZCBwdXQgdmFsdWUgaWYgc2FtZSBncm91cFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZ3JvdXAgPSB7fTtcbiAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG4gIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgb3JpZ2luYWxHcm91cCA9IHtcbiAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICB9O1xuICB9XG5cbiAgZ3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcbiAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICBncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XG4gIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbn0sXG4gICAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG4gIH1cbn0sXG4gICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIH1cbn07IC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuXG5cbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoaWdub3JlTmV4dENsaWNrKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG52YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG5cbiAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgaWYgKG5lYXJlc3QpIHtcbiAgICAgIC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcbiAgICAgIHZhciBldmVudCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuXG4gICAgICBuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICB9XG59O1xuLyoqXG4gKiBAY2xhc3MgIFNvcnRhYmxlXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxuICovXG5cblxuZnVuY3Rpb24gU29ydGFibGUoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG4gICAgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50LCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwoZWwpKTtcbiAgfVxuXG4gIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTsgLy8gRXhwb3J0IGluc3RhbmNlXG5cbiAgZWxbZXhwYW5kb10gPSB0aGlzO1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZ3JvdXA6IG51bGwsXG4gICAgc29ydDogdHJ1ZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3RvcmU6IG51bGwsXG4gICAgaGFuZGxlOiBudWxsLFxuICAgIGRyYWdnYWJsZTogL15bdW9dbCQvaS50ZXN0KGVsLm5vZGVOYW1lKSA/ICc+bGknIDogJz4qJyxcbiAgICBzd2FwVGhyZXNob2xkOiAxLFxuICAgIC8vIHBlcmNlbnRhZ2U7IDAgPD0geCA8PSAxXG4gICAgaW52ZXJ0U3dhcDogZmFsc2UsXG4gICAgLy8gaW52ZXJ0IGFsd2F5c1xuICAgIGludmVydGVkU3dhcFRocmVzaG9sZDogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCB0byBzYW1lIGFzIHN3YXBUaHJlc2hvbGQgaWYgZGVmYXVsdFxuICAgIHJlbW92ZUNsb25lT25IaWRlOiB0cnVlLFxuICAgIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9kZXRlY3REaXJlY3Rpb24oZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgICBnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuICAgIGNob3NlbkNsYXNzOiAnc29ydGFibGUtY2hvc2VuJyxcbiAgICBkcmFnQ2xhc3M6ICdzb3J0YWJsZS1kcmFnJyxcbiAgICBpZ25vcmU6ICdhLCBpbWcnLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBwcmV2ZW50T25GaWx0ZXI6IHRydWUsXG4gICAgYW5pbWF0aW9uOiAwLFxuICAgIGVhc2luZzogbnVsbCxcbiAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XG4gICAgfSxcbiAgICBkcm9wQnViYmxlOiBmYWxzZSxcbiAgICBkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXG4gICAgZGF0YUlkQXR0cjogJ2RhdGEtaWQnLFxuICAgIGRlbGF5OiAwLFxuICAgIGRlbGF5T25Ub3VjaE9ubHk6IGZhbHNlLFxuICAgIHRvdWNoU3RhcnRUaHJlc2hvbGQ6IChOdW1iZXIucGFyc2VJbnQgPyBOdW1iZXIgOiB3aW5kb3cpLnBhcnNlSW50KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxMCkgfHwgMSxcbiAgICBmb3JjZUZhbGxiYWNrOiBmYWxzZSxcbiAgICBmYWxsYmFja0NsYXNzOiAnc29ydGFibGUtZmFsbGJhY2snLFxuICAgIGZhbGxiYWNrT25Cb2R5OiBmYWxzZSxcbiAgICBmYWxsYmFja1RvbGVyYW5jZTogMCxcbiAgICBmYWxsYmFja09mZnNldDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIHN1cHBvcnRQb2ludGVyOiBTb3J0YWJsZS5zdXBwb3J0UG9pbnRlciAhPT0gZmFsc2UgJiYgJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93ICYmICFTYWZhcmksXG4gICAgZW1wdHlJbnNlcnRUaHJlc2hvbGQ6IDVcbiAgfTtcbiAgUGx1Z2luTWFuYWdlci5pbml0aWFsaXplUGx1Z2lucyh0aGlzLCBlbCwgZGVmYXVsdHMpOyAvLyBTZXQgZGVmYXVsdCBvcHRpb25zXG5cbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICEobmFtZSBpbiBvcHRpb25zKSAmJiAob3B0aW9uc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdKTtcbiAgfVxuXG4gIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG5cbiAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICB9XG4gIH0gLy8gU2V0dXAgZHJhZyBtb2RlXG5cblxuICB0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcblxuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAvLyBUb3VjaCBzdGFydCB0aHJlc2hvbGQgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbmF0aXZlIGRyYWdzdGFydCB0aHJlc2hvbGRcbiAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDE7XG4gIH0gLy8gQmluZCBldmVudHNcblxuXG4gIGlmIChvcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgb24oZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9IGVsc2Uge1xuICAgIG9uKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb24oZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH1cblxuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICBvbihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgb24oZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgfVxuXG4gIHNvcnRhYmxlcy5wdXNoKHRoaXMuZWwpOyAvLyBSZXN0b3JlIHNvcnRpbmdcblxuICBvcHRpb25zLnN0b3JlICYmIG9wdGlvbnMuc3RvcmUuZ2V0ICYmIHRoaXMuc29ydChvcHRpb25zLnN0b3JlLmdldCh0aGlzKSB8fCBbXSk7IC8vIEFkZCBhbmltYXRpb24gc3RhdGUgbWFuYWdlclxuXG4gIF9leHRlbmRzKHRoaXMsIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpKTtcbn1cblxuU29ydGFibGUucHJvdG90eXBlID1cbi8qKiBAbGVuZHMgU29ydGFibGUucHJvdG90eXBlICovXG57XG4gIGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcbiAgX2lzT3V0c2lkZVRoaXNFbDogZnVuY3Rpb24gX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpIHtcbiAgICBpZiAoIXRoaXMuZWwuY29udGFpbnModGFyZ2V0KSAmJiB0YXJnZXQgIT09IHRoaXMuZWwpIHtcbiAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgX2dldERpcmVjdGlvbjogZnVuY3Rpb24gX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24uY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgZHJhZ0VsKSA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gIH0sXG4gIF9vblRhcFN0YXJ0OiBmdW5jdGlvbiBfb25UYXBTdGFydChcbiAgLyoqIEV2ZW50fFRvdWNoRXZlbnQgKi9cbiAgZXZ0KSB7XG4gICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgZWwgPSB0aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgPSBvcHRpb25zLnByZXZlbnRPbkZpbHRlcixcbiAgICAgICAgdHlwZSA9IGV2dC50eXBlLFxuICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdIHx8IGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZ0LFxuICAgICAgICB0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXG4gICAgICAgIG9yaWdpbmFsVGFyZ2V0ID0gZXZ0LnRhcmdldC5zaGFkb3dSb290ICYmIChldnQucGF0aCAmJiBldnQucGF0aFswXSB8fCBldnQuY29tcG9zZWRQYXRoICYmIGV2dC5jb21wb3NlZFBhdGgoKVswXSkgfHwgdGFyZ2V0LFxuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblxuICAgIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUoZWwpOyAvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXG5cblxuICAgIGlmIChkcmFnRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoL21vdXNlZG93bnxwb2ludGVyZG93bi8udGVzdCh0eXBlKSAmJiBldnQuYnV0dG9uICE9PSAwIHx8IG9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBhbmQgZW5hYmxlZFxuICAgIH0gLy8gY2FuY2VsIGRuZCBpZiBvcmlnaW5hbCB0YXJnZXQgaXMgY29udGVudCBlZGl0YWJsZVxuXG5cbiAgICBpZiAob3JpZ2luYWxUYXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNhZmFyaSBpZ25vcmVzIGZ1cnRoZXIgZXZlbnQgaGFuZGxpbmcgYWZ0ZXIgbW91c2Vkb3duXG5cblxuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgU2FmYXJpICYmIHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0VMRUNUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xuICAgICAgLy8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cblxuICAgIG9sZEluZGV4ID0gaW5kZXgodGFyZ2V0KTtcbiAgICBvbGREcmFnZ2FibGVJbmRleCA9IGluZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpOyAvLyBDaGVjayBmaWx0ZXJcblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZmlsdGVyLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIHRoaXMpKSB7XG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgcm9vdEVsOiBvcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgIHRvRWw6IGVsLFxuICAgICAgICAgIGZyb21FbDogZWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGNyaXRlcmlhID0gY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChjcml0ZXJpYSkge1xuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIHJvb3RFbDogY3JpdGVyaWEsXG4gICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgdG9FbDogZWxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGUgJiYgIWNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQcmVwYXJlIGBkcmFnc3RhcnRgXG5cblxuICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgfSxcbiAgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9wcmVwYXJlRHJhZ1N0YXJ0KFxuICAvKiogRXZlbnQgKi9cbiAgZXZ0LFxuICAvKiogVG91Y2ggKi9cbiAgdG91Y2gsXG4gIC8qKiBIVE1MRWxlbWVudCAqL1xuICB0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IF90aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGRyYWdTdGFydEZuO1xuXG4gICAgaWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgcm9vdEVsID0gZWw7XG4gICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgbGFzdERvd25FbCA9IHRhcmdldDtcbiAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcbiAgICAgIFNvcnRhYmxlLmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgICB0YXBFdnQgPSB7XG4gICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICBjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGFwRGlzdGFuY2VMZWZ0ID0gdGFwRXZ0LmNsaWVudFggLSBkcmFnUmVjdC5sZWZ0O1xuICAgICAgdGFwRGlzdGFuY2VUb3AgPSB0YXBFdnQuY2xpZW50WSAtIGRyYWdSZWN0LnRvcDtcbiAgICAgIHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WTtcbiAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICdhbGwnO1xuXG4gICAgICBkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uIGRyYWdTdGFydEZuKCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlFbmRlZCcsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBfdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcblxuXG4gICAgICAgIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgICAgICBpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH0gLy8gQmluZCB0aGUgZXZlbnRzOiBkcmFnc3RhcnQvZHJhZ2VuZFxuXG5cbiAgICAgICAgX3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgbmFtZTogJ2Nob29zZScsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pOyAvLyBDaG9zZW4gaXRlbVxuXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcbiAgICAgIH07IC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuXG5cbiAgICAgIG9wdGlvbnMuaWdub3JlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgZmluZChkcmFnRWwsIGNyaXRlcmlhLnRyaW0oKSwgX2Rpc2FibGVEcmFnZ2FibGUpO1xuICAgICAgfSk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApOyAvLyBNYWtlIGRyYWdFbCBkcmFnZ2FibGUgKG11c3QgYmUgYmVmb3JlIGRlbGF5IGZvciBGaXJlRm94KVxuXG4gICAgICBpZiAoRmlyZUZveCAmJiB0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDQ7XG4gICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5FdmVudCgnZGVsYXlTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pOyAvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgKCFvcHRpb25zLmRlbGF5T25Ub3VjaE9ubHkgfHwgdG91Y2gpICYmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgIShFZGdlIHx8IElFMTFPckxlc3MpKSkge1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZSBwb2ludGVyIG9yIGxldCBnbyB0aGUgY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcblxuXG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ1N0YXJ0Rm4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXI6IGZ1bmN0aW9uIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIoXG4gIC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9cbiAgZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cbiAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPj0gTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCAvICh0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuICAgIH1cbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZygpIHtcbiAgICBkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHM6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICB9LFxuICBfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gX3RyaWdnZXJEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCkge1xuICAgIHRvdWNoID0gdG91Y2ggfHwgZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiYgZXZ0O1xuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIGlmICh0b3VjaCkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICBvbihyb290RWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgLy8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcbiAgICAgICAgX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9LFxuICBfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIF9kcmFnU3RhcnRlZChmYWxsYmFjaywgZXZ0KSB7XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICBpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydGVkJywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgX2NoZWNrT3V0c2lkZVRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEFwcGx5IGVmZmVjdFxuXG4gICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcbiAgICAgIGZhbGxiYWNrICYmIHRoaXMuX2FwcGVuZEdob3N0KCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgIH1cbiAgfSxcbiAgX2VtdWxhdGVEcmFnT3ZlcjogZnVuY3Rpb24gX2VtdWxhdGVEcmFnT3ZlcigpIHtcbiAgICBpZiAodG91Y2hFdnQpIHtcbiAgICAgIHRoaXMuX2xhc3RYID0gdG91Y2hFdnQuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gdG91Y2hFdnQuY2xpZW50WTtcblxuICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gcGFyZW50KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKHRhcmdldCk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChwYXJlbnRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGluc2VydGVkID0gcGFyZW50W2V4cGFuZG9dLl9vbkRyYWdPdmVyKHtcbiAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGluc2VydGVkICYmICF0aGlzLm9wdGlvbnMuZHJhZ292ZXJCdWJibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgIH1cbiAgfSxcbiAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiBfb25Ub3VjaE1vdmUoXG4gIC8qKlRvdWNoRXZlbnQqL1xuICBldnQpIHtcbiAgICBpZiAodGFwRXZ0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXG4gICAgICAgICAgZmFsbGJhY2tPZmZzZXQgPSBvcHRpb25zLmZhbGxiYWNrT2Zmc2V0LFxuICAgICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IGdob3N0RWwgJiYgbWF0cml4KGdob3N0RWwsIHRydWUpLFxuICAgICAgICAgIHNjYWxlWCA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmQsXG4gICAgICAgICAgcmVsYXRpdmVTY3JvbGxPZmZzZXQgPSBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICYmIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpLFxuICAgICAgICAgIGR4ID0gKHRvdWNoLmNsaWVudFggLSB0YXBFdnQuY2xpZW50WCArIGZhbGxiYWNrT2Zmc2V0LngpIC8gKHNjYWxlWCB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzBdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMF0gOiAwKSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgZHkgPSAodG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZICsgZmFsbGJhY2tPZmZzZXQueSkgLyAoc2NhbGVZIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMV0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFsxXSA6IDApIC8gKHNjYWxlWSB8fCAxKTsgLy8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcblxuICAgICAgaWYgKCFTb3J0YWJsZS5hY3RpdmUgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrVG9sZXJhbmNlICYmIE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkRyYWdTdGFydChldnQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2hvc3RFbCkge1xuICAgICAgICBpZiAoZ2hvc3RNYXRyaXgpIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5lICs9IGR4IC0gKGxhc3REeCB8fCAwKTtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5mICs9IGR5IC0gKGxhc3REeSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICBlOiBkeCxcbiAgICAgICAgICAgIGY6IGR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjc3NNYXRyaXggPSBcIm1hdHJpeChcIi5jb25jYXQoZ2hvc3RNYXRyaXguYSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5iLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmMsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZCwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5lLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmYsIFwiKVwiKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGxhc3REeCA9IGR4O1xuICAgICAgICBsYXN0RHkgPSBkeTtcbiAgICAgICAgdG91Y2hFdnQgPSB0b3VjaDtcbiAgICAgIH1cblxuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBfYXBwZW5kR2hvc3Q6IGZ1bmN0aW9uIF9hcHBlbmRHaG9zdCgpIHtcbiAgICAvLyBCdWcgaWYgdXNpbmcgc2NhbGUoKTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzNzA1OFxuICAgIC8vIE5vdCBiZWluZyBhZGp1c3RlZCBmb3JcbiAgICBpZiAoIWdob3N0RWwpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZmFsbGJhY2tPbkJvZHkgPyBkb2N1bWVudC5ib2R5IDogcm9vdEVsLFxuICAgICAgICAgIHJlY3QgPSBnZXRSZWN0KGRyYWdFbCwgdHJ1ZSwgUG9zaXRpb25HaG9zdEFic29sdXRlbHksIHRydWUsIGNvbnRhaW5lciksXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gUG9zaXRpb24gYWJzb2x1dGVseVxuXG4gICAgICBpZiAoUG9zaXRpb25HaG9zdEFic29sdXRlbHkpIHtcbiAgICAgICAgLy8gR2V0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGNvbnRhaW5lcjtcblxuICAgICAgICB3aGlsZSAoY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJiBjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIHJlY3QudG9wICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJlY3QubGVmdCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmZhbGxiYWNrQ2xhc3MsIHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2JveC1zaXppbmcnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgICAgY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICAgICAgY3NzKGdob3N0RWwsICdvcGFjaXR5JywgJzAuOCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID8gJ2Fic29sdXRlJyA6ICdmaXhlZCcpO1xuICAgICAgY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgICAgU29ydGFibGUuZ2hvc3QgPSBnaG9zdEVsO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdob3N0RWwpOyAvLyBTZXQgdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0YXBEaXN0YW5jZUxlZnQgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLndpZHRoKSAqIDEwMCArICclICcgKyB0YXBEaXN0YW5jZVRvcCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUuaGVpZ2h0KSAqIDEwMCArICclJyk7XG4gICAgfVxuICB9LFxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChcbiAgLyoqRXZlbnQqL1xuICBldnQsXG4gIC8qKmJvb2xlYW4qL1xuICBmYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcbiAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG5cbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5FdmVudCgnc2V0dXBDbG9uZScsIHRoaXMpO1xuXG4gICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICBjbG9uZUVsID0gY2xvbmUoZHJhZ0VsKTtcbiAgICAgIGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbG9uZUVsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICB9IC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXG5cblxuICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpOyAvLyBTZXQgcHJvcGVyIGRyb3AgZXZlbnRzXG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIG9uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTsgLy8gIzEyNzYgZml4OlxuXG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlcihcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgcmV2ZXJ0LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgdmVydGljYWwsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcblxuICAgIGlmIChfc2lsZW50KSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBkcmFnT3ZlckV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgICBwbHVnaW5FdmVudChuYW1lLCBfdGhpcywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgaXNPd25lcjogaXNPd25lcixcbiAgICAgICAgYXhpczogdmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgZHJhZ1JlY3Q6IGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgICBjYW5Tb3J0OiBjYW5Tb3J0LFxuICAgICAgICBmcm9tU29ydGFibGU6IGZyb21Tb3J0YWJsZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZSh0YXJnZXQsIGFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCBnZXRSZWN0KHRhcmdldCksIGV2dCwgYWZ0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gICAgICB9LCBleHRyYSkpO1xuICAgIH0gLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcblxuXG4gICAgZnVuY3Rpb24gY2FwdHVyZSgpIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZScpO1xuXG4gICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIGludm9jYXRpb24gd2hlbiBkcmFnRWwgaXMgaW5zZXJ0ZWQgKG9yIGNvbXBsZXRlZClcblxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgfSAvLyBBbmltYXRpb25cblxuXG4gICAgICAgIGlmIChmcm9tU29ydGFibGUgPT09IF90aGlzKSB7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG5cblxuICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfSAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG5cblxuICAgICAgaWYgKCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmICFldnQucm9vdEVsICYmIHRhcmdldCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTsgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcblxuXG4gICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgIH1cblxuICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgIH0gLy8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxuXG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICBpZiAoZHJhZ0VsLmNvbnRhaW5zKGV2dC50YXJnZXQpIHx8IHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQuYW5pbWF0aW5nWCAmJiB0YXJnZXQuYW5pbWF0aW5nWSB8fCBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSBwYXJlbnRFbCAhPT0gcm9vdEVsKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgIHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ3JldmVydCcpO1xuXG4gICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxMYXN0Q2hpbGQgPSBsYXN0Q2hpbGQoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBlbmQgb2YgbGlzdFxuICAgICAgICAvLyBJZiBhbHJlYWR5IGF0IGVuZCBvZiBsaXN0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgIGlmIChlbExhc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH0gLy8gaWYgdGhlcmUgaXMgYSBsYXN0IGVsZW1lbnQsIGl0IGlzIHRoZSB0YXJnZXRcblxuXG4gICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNhcHR1cmUoKTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsTGFzdENoaWxkICYmIF9naG9zdElzRmlyc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykpIHtcbiAgICAgICAgLy8gSW5zZXJ0IHRvIHN0YXJ0IG9mIGxpc3RcbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBnZXRDaGlsZChlbCwgMCwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gZmlyc3RDaGlsZDtcbiAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcblxuICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgZmFsc2UpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNhcHR1cmUoKTtcbiAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBmaXJzdENoaWxkKTtcbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IDAsXG4gICAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAsXG4gICAgICAgICAgICBkaWZmZXJlbnRMZXZlbCA9IGRyYWdFbC5wYXJlbnROb2RlICE9PSBlbCxcbiAgICAgICAgICAgIGRpZmZlcmVudFJvd0NvbCA9ICFfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ0VsLmFuaW1hdGVkICYmIGRyYWdFbC50b1JlY3QgfHwgZHJhZ1JlY3QsIHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQudG9SZWN0IHx8IHRhcmdldFJlY3QsIHZlcnRpY2FsKSxcbiAgICAgICAgICAgIHNpZGUxID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIHNjcm9sbGVkUGFzdFRvcCA9IGlzU2Nyb2xsZWRQYXN0KHRhcmdldCwgJ3RvcCcsICd0b3AnKSB8fCBpc1Njcm9sbGVkUGFzdChkcmFnRWwsICd0b3AnLCAndG9wJyksXG4gICAgICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxlZFBhc3RUb3AgPyBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChsYXN0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAgPSB0YXJnZXRSZWN0W3NpZGUxXTtcbiAgICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICAgICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gIWRpZmZlcmVudFJvd0NvbCAmJiBvcHRpb25zLmludmVydFN3YXAgfHwgZGlmZmVyZW50TGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJlY3Rpb24gPSBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIGRpZmZlcmVudFJvd0NvbCA/IDEgOiBvcHRpb25zLnN3YXBUaHJlc2hvbGQsIG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkID09IG51bGwgPyBvcHRpb25zLnN3YXBUaHJlc2hvbGQgOiBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCwgaXNDaXJjdW1zdGFudGlhbEludmVydCwgbGFzdFRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgdmFyIHNpYmxpbmc7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gMCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBiZXNpZGUgZHJhZ0VsIGluIHJlc3BlY3RpdmUgZGlyZWN0aW9uIChpZ25vcmluZyBoaWRkZW4gZWxlbWVudHMpXG4gICAgICAgICAgdmFyIGRyYWdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkcmFnSW5kZXggLT0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudEVsLmNoaWxkcmVuW2RyYWdJbmRleF07XG4gICAgICAgICAgfSB3aGlsZSAoc2libGluZyAmJiAoY3NzKHNpYmxpbmcsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzaWJsaW5nID09PSBnaG9zdEVsKSk7XG4gICAgICAgIH0gLy8gSWYgZHJhZ0VsIGlzIGFscmVhZHkgYmVzaWRlIHRhcmdldDogRG8gbm90IGluc2VydFxuXG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCB8fCBzaWJsaW5nID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGxhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICBhZnRlciA9IGZhbHNlO1xuICAgICAgICBhZnRlciA9IGRpcmVjdGlvbiA9PT0gMTtcblxuICAgICAgICB2YXIgbW92ZVZlY3RvciA9IF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGFmdGVyKTtcblxuICAgICAgICBpZiAobW92ZVZlY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobW92ZVZlY3RvciA9PT0gMSB8fCBtb3ZlVmVjdG9yID09PSAtMSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSBtb3ZlVmVjdG9yID09PSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgICAgaWYgKGFmdGVyICYmICFuZXh0U2libGluZykge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgYWZ0ZXIgPyBuZXh0U2libGluZyA6IHRhcmdldCk7XG4gICAgICAgICAgfSAvLyBVbmRvIGNocm9tZSdzIHNjcm9sbCBhZGp1c3RtZW50IChoYXMgbm8gZWZmZWN0IG9uIG90aGVyIGJyb3dzZXJzKVxuXG5cbiAgICAgICAgICBpZiAoc2Nyb2xsZWRQYXN0VG9wKSB7XG4gICAgICAgICAgICBzY3JvbGxCeShzY3JvbGxlZFBhc3RUb3AsIDAsIHNjcm9sbEJlZm9yZSAtIHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7IC8vIGFjdHVhbGl6YXRpb25cbiAgICAgICAgICAvLyBtdXN0IGJlIGRvbmUgYmVmb3JlIGFuaW1hdGlvblxuXG4gICAgICAgICAgaWYgKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAhPT0gdW5kZWZpbmVkICYmICFpc0NpcmN1bXN0YW50aWFsSW52ZXJ0KSB7XG4gICAgICAgICAgICB0YXJnZXRNb3ZlRGlzdGFuY2UgPSBNYXRoLmFicyh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgLSBnZXRSZWN0KHRhcmdldClbc2lkZTFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZWwuY29udGFpbnMoZHJhZ0VsKSkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIF9pZ25vcmVXaGlsZUFuaW1hdGluZzogbnVsbCxcbiAgX29mZk1vdmVFdmVudHM6IGZ1bmN0aW9uIF9vZmZNb3ZlRXZlbnRzKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgfSxcbiAgX29mZlVwRXZlbnRzOiBmdW5jdGlvbiBfb2ZmVXBFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCB0aGlzKTtcbiAgfSxcbiAgX29uRHJvcDogZnVuY3Rpb24gX29uRHJvcChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHBsdWdpbkV2ZW50KCdkcm9wJywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcbiAgICBwYXJlbnRFbCA9IGRyYWdFbCAmJiBkcmFnRWwucGFyZW50Tm9kZTsgLy8gR2V0IGFnYWluIGFmdGVyIHBsdWdpbiBldmVudFxuXG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZTtcbiAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2xvb3BJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLmNsb25lSWQpO1xuXG4gICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuX2RyYWdTdGFydElkKTsgLy8gVW5iaW5kIGV2ZW50c1xuXG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2Ryb3AnLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9vZmZNb3ZlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl9vZmZVcEV2ZW50cygpO1xuXG4gICAgaWYgKFNhZmFyaSkge1xuICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICcnKTtcbiAgICB9XG5cbiAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJycpO1xuXG4gICAgaWYgKGV2dCkge1xuICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAhb3B0aW9ucy5kcm9wQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCAmJiBnaG9zdEVsLnBhcmVudE5vZGUgJiYgZ2hvc3RFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGdob3N0RWwpO1xuXG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICAvLyBSZW1vdmUgY2xvbmUocylcbiAgICAgICAgY2xvbmVFbCAmJiBjbG9uZUVsLnBhcmVudE5vZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9mZihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuXG4gICAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnOyAvLyBSZW1vdmUgY2xhc3Nlc1xuICAgICAgICAvLyBnaG9zdENsYXNzIGlzIGFkZGVkIGluIGRyYWdTdGFydGVkXG5cbiAgICAgICAgaWYgKG1vdmVkICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IHRoaXMub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpOyAvLyBEcmFnIHN0b3AgZXZlbnRcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgbmFtZTogJ3VuY2hvb3NlJyxcbiAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICBuZXdJbmRleDogbnVsbCxcbiAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbnVsbCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gQWRkIGV2ZW50XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdhZGQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIFJlbW92ZSBldmVudFxuXG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gZHJhZyBmcm9tIG9uZSBsaXN0IGFuZCBkcm9wIGludG8gYW5vdGhlclxuXG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUuc2F2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdJbmRleCAhPT0gb2xkSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGRyYWcgJiBkcm9wIHdpdGhpbiB0aGUgc2FtZSBsaXN0XG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIC8qIGpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgIGlmIChuZXdJbmRleCA9PSBudWxsIHx8IG5ld0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBvbGRJbmRleDtcbiAgICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICBuYW1lOiAnZW5kJyxcbiAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7IC8vIFNhdmUgc29ydGluZ1xuXG5cbiAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX251bGxpbmcoKTtcbiAgfSxcbiAgX251bGxpbmc6IGZ1bmN0aW9uIF9udWxsaW5nKCkge1xuICAgIHBsdWdpbkV2ZW50KCdudWxsaW5nJywgdGhpcyk7XG4gICAgcm9vdEVsID0gZHJhZ0VsID0gcGFyZW50RWwgPSBnaG9zdEVsID0gbmV4dEVsID0gY2xvbmVFbCA9IGxhc3REb3duRWwgPSBjbG9uZUhpZGRlbiA9IHRhcEV2dCA9IHRvdWNoRXZ0ID0gbW92ZWQgPSBuZXdJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleCA9IGxhc3RUYXJnZXQgPSBsYXN0RGlyZWN0aW9uID0gcHV0U29ydGFibGUgPSBhY3RpdmVHcm91cCA9IFNvcnRhYmxlLmRyYWdnZWQgPSBTb3J0YWJsZS5naG9zdCA9IFNvcnRhYmxlLmNsb25lID0gU29ydGFibGUuYWN0aXZlID0gbnVsbDtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuY2hlY2tlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gbGFzdER4ID0gbGFzdER5ID0gMDtcbiAgfSxcbiAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICAgIHRoaXMuX29uRHJvcChldnQpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgdGhpcy5fb25EcmFnT3ZlcihldnQpO1xuXG4gICAgICAgICAgX2dsb2JhbERyYWdPdmVyKGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHZhciBvcmRlciA9IFtdLFxuICAgICAgICBlbCxcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmVsLmNoaWxkcmVuLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBlbCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSkge1xuICAgICAgICBvcmRlci5wdXNoKGVsLmdldEF0dHJpYnV0ZShvcHRpb25zLmRhdGFJZEF0dHIpIHx8IF9nZW5lcmF0ZUlkKGVsKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cbiAgICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXG4gICAqL1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KG9yZGVyLCB1c2VBbmltYXRpb24pIHtcbiAgICB2YXIgaXRlbXMgPSB7fSxcbiAgICAgICAgcm9vdEVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgdmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsLCBmYWxzZSkpIHtcbiAgICAgICAgaXRlbXNbaWRdID0gZWw7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdXNlQW5pbWF0aW9uICYmIHRoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpdGVtc1tpZF0pIHtcbiAgICAgICAgcm9vdEVsLnJlbW92ZUNoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGVBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXG4gICAqL1xuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcbiAgICBzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yIGJ5IHRlc3RpbmcgdGhlIGVsZW1lbnQgaXRzZWxmIGFuZCB0cmF2ZXJzaW5nIHVwIHRocm91Z2ggaXRzIGFuY2VzdG9ycyBpbiB0aGUgRE9NIHRyZWUuXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgIFtzZWxlY3Rvcl0gIGRlZmF1bHQ6IGBvcHRpb25zLmRyYWdnYWJsZWBcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0JDEoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0L2dldCBvcHRpb25cbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgb3B0aW9uOiBmdW5jdGlvbiBvcHRpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBQbHVnaW5NYW5hZ2VyLm1vZGlmeU9wdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG1vZGlmaWVkVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95XG4gICAqL1xuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHBsdWdpbkV2ZW50KCdkZXN0cm95JywgdGhpcyk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbFtleHBhbmRvXSA9IG51bGw7XG4gICAgb2ZmKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICB9IC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuXG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkcmFnZ2FibGVdJyksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICBzb3J0YWJsZXMuc3BsaWNlKHNvcnRhYmxlcy5pbmRleE9mKHRoaXMuZWwpLCAxKTtcbiAgICB0aGlzLmVsID0gZWwgPSBudWxsO1xuICB9LFxuICBfaGlkZUNsb25lOiBmdW5jdGlvbiBfaGlkZUNsb25lKCkge1xuICAgIGlmICghY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdoaWRlQ2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lRWwucGFyZW50Tm9kZSkge1xuICAgICAgICBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIF9zaG93Q2xvbmU6IGZ1bmN0aW9uIF9zaG93Q2xvbmUocHV0U29ydGFibGUpIHtcbiAgICBpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnc2hvd0Nsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuOyAvLyBzaG93IGNsb25lIGF0IGRyYWdFbCBvciBvcmlnaW5hbCBwb3NpdGlvblxuXG4gICAgICBpZiAoZHJhZ0VsLnBhcmVudE5vZGUgPT0gcm9vdEVsICYmICF0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfSBlbHNlIGlmIChuZXh0RWwpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBuZXh0RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZShkcmFnRWwsIGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyKFxuLyoqRXZlbnQqL1xuZXZ0KSB7XG4gIGlmIChldnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICB9XG5cbiAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIF9vbk1vdmUoZnJvbUVsLCB0b0VsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXRFbCwgdGFyZ2V0UmVjdCwgb3JpZ2luYWxFdmVudCwgd2lsbEluc2VydEFmdGVyKSB7XG4gIHZhciBldnQsXG4gICAgICBzb3J0YWJsZSA9IGZyb21FbFtleHBhbmRvXSxcbiAgICAgIG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXG4gICAgICByZXRWYWw7IC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG5cbiAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudCgnbW92ZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudCgnbW92ZScsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbDtcbiAgZXZ0LmZyb20gPSBmcm9tRWw7XG4gIGV2dC5kcmFnZ2VkID0gZHJhZ0VsO1xuICBldnQuZHJhZ2dlZFJlY3QgPSBkcmFnUmVjdDtcbiAgZXZ0LnJlbGF0ZWQgPSB0YXJnZXRFbCB8fCB0b0VsO1xuICBldnQucmVsYXRlZFJlY3QgPSB0YXJnZXRSZWN0IHx8IGdldFJlY3QodG9FbCk7XG4gIGV2dC53aWxsSW5zZXJ0QWZ0ZXIgPSB3aWxsSW5zZXJ0QWZ0ZXI7XG4gIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgZnJvbUVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICBpZiAob25Nb3ZlRm4pIHtcbiAgICByZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQsIG9yaWdpbmFsRXZlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHJldFZhbDtcbn1cblxuZnVuY3Rpb24gX2Rpc2FibGVEcmFnZ2FibGUoZWwpIHtcbiAgZWwuZHJhZ2dhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF91bnNpbGVudCgpIHtcbiAgX3NpbGVudCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciByZWN0ID0gZ2V0UmVjdChnZXRDaGlsZChzb3J0YWJsZS5lbCwgMCwgc29ydGFibGUub3B0aW9ucywgdHJ1ZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYIDwgcmVjdC5sZWZ0IC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgcmVjdC50b3AgJiYgZXZ0LmNsaWVudFggPCByZWN0LnJpZ2h0IDogZXZ0LmNsaWVudFkgPCByZWN0LnRvcCAtIHNwYWNlciB8fCBldnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYIDwgcmVjdC5sZWZ0O1xufVxuXG5mdW5jdGlvbiBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIHJlY3QgPSBnZXRSZWN0KGxhc3RDaGlsZChzb3J0YWJsZS5lbCwgc29ydGFibGUub3B0aW9ucy5kcmFnZ2FibGUpKTtcbiAgdmFyIHNwYWNlciA9IDEwO1xuICByZXR1cm4gdmVydGljYWwgPyBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgKyBzcGFjZXIgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYID49IHJlY3QubGVmdCA6IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QudG9wIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSArIHNwYWNlcjtcbn1cblxuZnVuY3Rpb24gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBzd2FwVGhyZXNob2xkLCBpbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGludmVydFN3YXAsIGlzTGFzdFRhcmdldCkge1xuICB2YXIgbW91c2VPbkF4aXMgPSB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRZIDogZXZ0LmNsaWVudFgsXG4gICAgICB0YXJnZXRMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCxcbiAgICAgIHRhcmdldFMxID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnRvcCA6IHRhcmdldFJlY3QubGVmdCxcbiAgICAgIHRhcmdldFMyID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmJvdHRvbSA6IHRhcmdldFJlY3QucmlnaHQsXG4gICAgICBpbnZlcnQgPSBmYWxzZTtcblxuICBpZiAoIWludmVydFN3YXApIHtcbiAgICAvLyBOZXZlciBpbnZlcnQgb3IgY3JlYXRlIGRyYWdFbCBzaGFkb3cgd2hlbiB0YXJnZXQgbW92ZW1lbmV0IGNhdXNlcyBtb3VzZSB0byBtb3ZlIHBhc3QgdGhlIGVuZCBvZiByZWd1bGFyIHN3YXBUaHJlc2hvbGRcbiAgICBpZiAoaXNMYXN0VGFyZ2V0ICYmIHRhcmdldE1vdmVEaXN0YW5jZSA8IHRhcmdldExlbmd0aCAqIHN3YXBUaHJlc2hvbGQpIHtcbiAgICAgIC8vIG11bHRpcGxpZWQgb25seSBieSBzd2FwVGhyZXNob2xkIGJlY2F1c2UgbW91c2Ugd2lsbCBhbHJlYWR5IGJlIGluc2lkZSB0YXJnZXQgYnkgKDEgLSB0aHJlc2hvbGQpICogdGFyZ2V0TGVuZ3RoIC8gMlxuICAgICAgLy8gY2hlY2sgaWYgcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkIG9uIHNpZGUgb3Bwb3NpdGUgb2YgbGFzdERpcmVjdGlvblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggJiYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiA6IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSkge1xuICAgICAgICAvLyBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQsIGRvIG5vdCByZXN0cmljdCBpbnZlcnRlZCB0aHJlc2hvbGQgdG8gZHJhZ0VsIHNoYWRvd1xuICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCkge1xuICAgICAgICAvLyBkcmFnRWwgc2hhZG93ICh0YXJnZXQgbW92ZSBkaXN0YW5jZSBzaGFkb3cpXG4gICAgICAgIGlmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldE1vdmVEaXN0YW5jZSAvLyBvdmVyIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgOiBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TW92ZURpc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIC1sYXN0RGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZlcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyXG4gICAgICBpZiAobW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyICYmIG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMikge1xuICAgICAgICByZXR1cm4gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGludmVydCA9IGludmVydCB8fCBpbnZlcnRTd2FwO1xuXG4gIGlmIChpbnZlcnQpIHtcbiAgICAvLyBJbnZlcnQgb2YgcmVndWxhclxuICAgIGlmIChtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiB8fCBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikge1xuICAgICAgcmV0dXJuIG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBkaXJlY3Rpb24gZHJhZ0VsIG11c3QgYmUgc3dhcHBlZCByZWxhdGl2ZSB0byB0YXJnZXQgaW4gb3JkZXIgdG8gbWFrZSBpdFxuICogc2VlbSB0aGF0IGRyYWdFbCBoYXMgYmVlbiBcImluc2VydGVkXCIgaW50byB0aGF0IGVsZW1lbnQncyBwb3NpdGlvblxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgICAgICBUaGUgdGFyZ2V0IHdob3NlIHBvc2l0aW9uIGRyYWdFbCBpcyBiZWluZyBpbnNlcnRlZCBhdFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICBEaXJlY3Rpb24gZHJhZ0VsIG11c3QgYmUgc3dhcHBlZFxuICovXG5cblxuZnVuY3Rpb24gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpIHtcbiAgaWYgKGluZGV4KGRyYWdFbCkgPCBpbmRleCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGlkXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZUlkKGVsKSB7XG4gIHZhciBzdHIgPSBlbC50YWdOYW1lICsgZWwuY2xhc3NOYW1lICsgZWwuc3JjICsgZWwuaHJlZiArIGVsLnRleHRDb250ZW50LFxuICAgICAgaSA9IHN0ci5sZW5ndGgsXG4gICAgICBzdW0gPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBzdW0gKz0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gc3VtLnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShyb290KSB7XG4gIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IDA7XG4gIHZhciBpbnB1dHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICB2YXIgaWR4ID0gaW5wdXRzLmxlbmd0aDtcblxuICB3aGlsZSAoaWR4LS0pIHtcbiAgICB2YXIgZWwgPSBpbnB1dHNbaWR4XTtcbiAgICBlbC5jaGVja2VkICYmIHNhdmVkSW5wdXRDaGVja2VkLnB1c2goZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9uZXh0VGljayhmbikge1xuICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG59XG5cbmZ1bmN0aW9uIF9jYW5jZWxOZXh0VGljayhpZCkge1xuICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbn0gLy8gRml4ZWQgIzk3MzpcblxuXG5pZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKChTb3J0YWJsZS5hY3RpdmUgfHwgYXdhaXRpbmdEcmFnU3RhcnRlZCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59IC8vIEV4cG9ydCB1dGlsc1xuXG5cblNvcnRhYmxlLnV0aWxzID0ge1xuICBvbjogb24sXG4gIG9mZjogb2ZmLFxuICBjc3M6IGNzcyxcbiAgZmluZDogZmluZCxcbiAgaXM6IGZ1bmN0aW9uIGlzKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAhIWNsb3Nlc3QoZWwsIHNlbGVjdG9yLCBlbCwgZmFsc2UpO1xuICB9LFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdGhyb3R0bGU6IHRocm90dGxlLFxuICBjbG9zZXN0OiBjbG9zZXN0LFxuICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gIGNsb25lOiBjbG9uZSxcbiAgaW5kZXg6IGluZGV4LFxuICBuZXh0VGljazogX25leHRUaWNrLFxuICBjYW5jZWxOZXh0VGljazogX2NhbmNlbE5leHRUaWNrLFxuICBkZXRlY3REaXJlY3Rpb246IF9kZXRlY3REaXJlY3Rpb24sXG4gIGdldENoaWxkOiBnZXRDaGlsZFxufTtcbi8qKlxuICogR2V0IHRoZSBTb3J0YWJsZSBpbnN0YW5jZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudFxuICogQHJldHVybiB7U29ydGFibGV8dW5kZWZpbmVkfSAgICAgICAgIFRoZSBpbnN0YW5jZSBvZiBTb3J0YWJsZVxuICovXG5cblNvcnRhYmxlLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50W2V4cGFuZG9dO1xufTtcbi8qKlxuICogTW91bnQgYSBwbHVnaW4gdG8gU29ydGFibGVcbiAqIEBwYXJhbSAgey4uLlNvcnRhYmxlUGx1Z2lufFNvcnRhYmxlUGx1Z2luW119IHBsdWdpbnMgICAgICAgUGx1Z2lucyBiZWluZyBtb3VudGVkXG4gKi9cblxuXG5Tb3J0YWJsZS5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwbHVnaW5zWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgaWYgKCFwbHVnaW4ucHJvdG90eXBlIHx8ICFwbHVnaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBcIlNvcnRhYmxlOiBNb3VudGVkIHBsdWdpbiBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChwbHVnaW4pKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luLnV0aWxzKSBTb3J0YWJsZS51dGlscyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBTb3J0YWJsZS51dGlscyksIHBsdWdpbi51dGlscyk7XG4gICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZSBzb3J0YWJsZSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gIGVsXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cbiAqL1xuXG5cblNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFNvcnRhYmxlKGVsLCBvcHRpb25zKTtcbn07IC8vIEV4cG9ydFxuXG5cblNvcnRhYmxlLnZlcnNpb24gPSB2ZXJzaW9uJDE7XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCB0aGlzLm9wdGlvbnMuZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cblxudmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxheWVyc091dCsrO1xuICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZW1vdmUsIHtcbiAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG59KTtcblxuU29ydGFibGUubW91bnQobmV3IEF1dG9TY3JvbGxQbHVnaW4oKSk7XG5Tb3J0YWJsZS5tb3VudChSZW1vdmUsIFJldmVydCk7XG5cbnZhciBSZWdleEV2ZW50O1xuKGZ1bmN0aW9uIChSZWdleEV2ZW50KSB7XG4gICAgKGZ1bmN0aW9uIChQYXJzb25zSW5wdXRBY3Rpb24pIHtcbiAgICAgICAgUGFyc29uc0lucHV0QWN0aW9uW1wiQUREXCJdID0gXCJhZGRcIjtcbiAgICAgICAgUGFyc29uc0lucHV0QWN0aW9uW1wiTU9WRVwiXSA9IFwibW92ZVwiO1xuICAgICAgICBQYXJzb25zSW5wdXRBY3Rpb25bXCJSRU1PVkVcIl0gPSBcInJlbW92ZVwiO1xuICAgIH0pKFJlZ2V4RXZlbnQuUGFyc29uc0lucHV0QWN0aW9uIHx8IChSZWdleEV2ZW50LlBhcnNvbnNJbnB1dEFjdGlvbiA9IHt9KSk7XG4gICAgKGZ1bmN0aW9uIChSZWdleENvbXBpbGF0aW9uU3RhdHVzKSB7XG4gICAgICAgIFJlZ2V4Q29tcGlsYXRpb25TdGF0dXNbXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcbiAgICAgICAgUmVnZXhDb21waWxhdGlvblN0YXR1c1tcIlNVQ0NFU1NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICB9KShSZWdleEV2ZW50LlJlZ2V4Q29tcGlsYXRpb25TdGF0dXMgfHwgKFJlZ2V4RXZlbnQuUmVnZXhDb21waWxhdGlvblN0YXR1cyA9IHt9KSk7XG4gICAgKGZ1bmN0aW9uIChNYXRjaFRyaWdnZXJUeXBlKSB7XG4gICAgICAgIE1hdGNoVHJpZ2dlclR5cGVbXCJNQU5VQUxcIl0gPSBcIm1hbnVhbFwiO1xuICAgICAgICBNYXRjaFRyaWdnZXJUeXBlW1wiQVVUT1wiXSA9IFwiYXV0b1wiO1xuICAgIH0pKFJlZ2V4RXZlbnQuTWF0Y2hUcmlnZ2VyVHlwZSB8fCAoUmVnZXhFdmVudC5NYXRjaFRyaWdnZXJUeXBlID0ge30pKTtcbiAgICAoZnVuY3Rpb24gKFBhZ2VTdGF0dXMpIHtcbiAgICAgICAgUGFnZVN0YXR1c1tcIkZPQ1VTXCJdID0gXCJmb2N1c1wiO1xuICAgICAgICBQYWdlU3RhdHVzW1wiVklTSUJJTElUWVwiXSA9IFwidmlzaWJpbGl0eVwiO1xuICAgIH0pKFJlZ2V4RXZlbnQuUGFnZVN0YXR1cyB8fCAoUmVnZXhFdmVudC5QYWdlU3RhdHVzID0ge30pKTtcbn0pKFJlZ2V4RXZlbnQgfHwgKFJlZ2V4RXZlbnQgPSB7fSkpO1xuXG52YXIgZGVlcEZyZWV6ZUVzNiA9IHtleHBvcnRzOiB7fX07XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gb2JqLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwIGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIHNlbGZcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICBkZWVwRnJlZXplKHByb3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5kZWVwRnJlZXplRXM2LmV4cG9ydHMgPSBkZWVwRnJlZXplO1xuZGVlcEZyZWV6ZUVzNi5leHBvcnRzLmRlZmF1bHQgPSBkZWVwRnJlZXplO1xuXG52YXIgZGVlcEZyZWV6ZSQxID0gZGVlcEZyZWV6ZUVzNi5leHBvcnRzO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ2FsbGJhY2tSZXNwb25zZX0gQ2FsbGJhY2tSZXNwb25zZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlICovXG4vKiogQGltcGxlbWVudHMgQ2FsbGJhY2tSZXNwb25zZSAqL1xuXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICBpZiAobW9kZS5kYXRhID09PSB1bmRlZmluZWQpIG1vZGUuZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5kYXRhID0gbW9kZS5kYXRhO1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlnbm9yZU1hdGNoKCkge1xuICAgIHRoaXMuaXNNYXRjaElnbm9yZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjeDI3OycpO1xufVxuXG4vKipcbiAqIHBlcmZvcm1zIGEgc2hhbGxvdyBtZXJnZSBvZiBtdWx0aXBsZSBvYmplY3RzIGludG8gb25lXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyxhbnk+W119IG9iamVjdHNcbiAqIEByZXR1cm5zIHtUfSBhIHNpbmdsZSBuZXcgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQkMShvcmlnaW5hbCwgLi4ub2JqZWN0cykge1xuICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxhbnk+ICovXG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICByZXN1bHRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gIH1cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW5kZXJlclxuICogQHByb3BlcnR5IHsodGV4dDogc3RyaW5nKSA9PiB2b2lkfSBhZGRUZXh0XG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBvcGVuTm9kZVxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZSkgPT4gdm9pZH0gY2xvc2VOb2RlXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3traW5kPzogc3RyaW5nLCBzdWJsYW5ndWFnZT86IGJvb2xlYW59fSBOb2RlICovXG4vKiogQHR5cGVkZWYge3t3YWxrOiAocjogUmVuZGVyZXIpID0+IHZvaWR9fSBUcmVlICovXG4vKiogKi9cblxuY29uc3QgU1BBTl9DTE9TRSA9ICc8L3NwYW4+JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIDxzcGFuPlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuY29uc3QgZW1pdHNXcmFwcGluZ1RhZ3MgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gISFub2RlLmtpbmQ7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7cHJlZml4OnN0cmluZ319IG9wdGlvbnNcbiAqL1xuY29uc3QgZXhwYW5kU2NvcGVOYW1lID0gKG5hbWUsIHsgcHJlZml4IH0pID0+IHtcbiAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgY29uc3QgcGllY2VzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke3ByZWZpeH0ke3BpZWNlcy5zaGlmdCgpfWAsXG4gICAgICAuLi4ocGllY2VzLm1hcCgoeCwgaSkgPT4gYCR7eH0ke1wiX1wiLnJlcGVhdChpICsgMSl9YCkpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4fSR7bmFtZX1gO1xufTtcblxuLyoqIEB0eXBlIHtSZW5kZXJlcn0gKi9cbmNsYXNzIEhUTUxSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxSZW5kZXJlclxuICAgKlxuICAgKiBAcGFyYW0ge1RyZWV9IHBhcnNlVHJlZSAtIHRoZSBwYXJzZSB0cmVlIChtdXN0IHN1cHBvcnQgYHdhbGtgIEFQSSlcbiAgICogQHBhcmFtIHt7Y2xhc3NQcmVmaXg6IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlVHJlZSwgb3B0aW9ucykge1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gb3B0aW9ucy5jbGFzc1ByZWZpeDtcbiAgICBwYXJzZVRyZWUud2Fsayh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRleHRzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICovXG4gIGFkZFRleHQodGV4dCkge1xuICAgIHRoaXMuYnVmZmVyICs9IGVzY2FwZUhUTUwodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgb3BlbiB0byB0aGUgb3V0cHV0IHN0cmVhbSAoaWYgbmVlZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbiAgb3Blbk5vZGUobm9kZSkge1xuICAgIGlmICghZW1pdHNXcmFwcGluZ1RhZ3Mobm9kZSkpIHJldHVybjtcblxuICAgIGxldCBzY29wZSA9IG5vZGUua2luZDtcbiAgICBpZiAobm9kZS5zdWJsYW5ndWFnZSkge1xuICAgICAgc2NvcGUgPSBgbGFuZ3VhZ2UtJHtzY29wZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZSA9IGV4cGFuZFNjb3BlTmFtZShzY29wZSwgeyBwcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXggfSk7XG4gICAgfVxuICAgIHRoaXMuc3BhbihzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgY2xvc2UgdG8gdGhlIG91dHB1dCBzdHJlYW0gKGlmIG5lZWRlZClcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGNsb3NlTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5idWZmZXIgKz0gU1BBTl9DTE9TRTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCBidWZmZXJcbiAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzcGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBzcGFuKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPmA7XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB8IHN0cmluZ30gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB9IERhdGFOb2RlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuRW1pdHRlcn0gRW1pdHRlciAqL1xuLyoqICAqL1xuXG5jbGFzcyBUb2tlblRyZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgICB0aGlzLnJvb3ROb2RlID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLnN0YWNrID0gW3RoaXMucm9vdE5vZGVdO1xuICB9XG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLnJvb3ROb2RlOyB9XG5cbiAgLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBhZGQobm9kZSkge1xuICAgIHRoaXMudG9wLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGtpbmQgKi9cbiAgb3Blbk5vZGUoa2luZCkge1xuICAgIC8qKiBAdHlwZSBOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IHsga2luZCwgY2hpbGRyZW46IFtdIH07XG4gICAgdGhpcy5hZGQobm9kZSk7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICB9XG5cbiAgY2xvc2VOb2RlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNsb3NlQWxsTm9kZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMuY2xvc2VOb2RlKCkpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJvb3ROb2RlLCBudWxsLCA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vaHRtbF9yZW5kZXJlclwiKS5SZW5kZXJlciB9IFJlbmRlcmVyXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IGJ1aWxkZXJcbiAgICovXG4gIHdhbGsoYnVpbGRlcikge1xuICAgIC8vIHRoaXMgZG9lcyBub3RcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgICAvLyB0aGlzIHdvcmtzXG4gICAgLy8gcmV0dXJuIFRva2VuVHJlZS5fd2FsayhidWlsZGVyLCB0aGlzLnJvb3ROb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSBidWlsZGVyXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgc3RhdGljIF93YWxrKGJ1aWxkZXIsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkVGV4dChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGJ1aWxkZXIub3Blbk5vZGUobm9kZSk7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl93YWxrKGJ1aWxkZXIsIGNoaWxkKSk7XG4gICAgICBidWlsZGVyLmNsb3NlTm9kZShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybjtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHJldHVybjtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmV2ZXJ5KGVsID0+IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIC8vIG5vZGUudGV4dCA9IG5vZGUuY2hpbGRyZW4uam9pbihcIlwiKTtcbiAgICAgIC8vIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IFtub2RlLmNoaWxkcmVuLmpvaW4oXCJcIildO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIFRva2VuVHJlZS5fY29sbGFwc2UoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICBDdXJyZW50bHkgdGhpcyBpcyBhbGwgcHJpdmF0ZSBBUEksIGJ1dCB0aGlzIGlzIHRoZSBtaW5pbWFsIEFQSSBuZWNlc3NhcnlcbiAgdGhhdCBhbiBFbWl0dGVyIG11c3QgaW1wbGVtZW50IHRvIGZ1bGx5IHN1cHBvcnQgdGhlIHBhcnNlci5cblxuICBNaW5pbWFsIGludGVyZmFjZTpcblxuICAtIGFkZEtleXdvcmQodGV4dCwga2luZClcbiAgLSBhZGRUZXh0KHRleHQpXG4gIC0gYWRkU3VibGFuZ3VhZ2UoZW1pdHRlciwgc3ViTGFuZ3VhZ2VOYW1lKVxuICAtIGZpbmFsaXplKClcbiAgLSBvcGVuTm9kZShraW5kKVxuICAtIGNsb3NlTm9kZSgpXG4gIC0gY2xvc2VBbGxOb2RlcygpXG4gIC0gdG9IVE1MKClcblxuKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RW1pdHRlcn1cbiAqL1xuY2xhc3MgVG9rZW5UcmVlRW1pdHRlciBleHRlbmRzIFRva2VuVHJlZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICovXG4gIGFkZEtleXdvcmQodGV4dCwga2luZCkge1xuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5vcGVuTm9kZShraW5kKTtcbiAgICB0aGlzLmFkZFRleHQodGV4dCk7XG4gICAgdGhpcy5jbG9zZU5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLmFkZCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VtaXR0ZXIgJiB7cm9vdDogRGF0YU5vZGV9fSBlbWl0dGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBhZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgLyoqIEB0eXBlIERhdGFOb2RlICovXG4gICAgY29uc3Qgbm9kZSA9IGVtaXR0ZXIucm9vdDtcbiAgICBub2RlLmtpbmQgPSBuYW1lO1xuICAgIG5vZGUuc3VibGFuZ3VhZ2UgPSB0cnVlO1xuICAgIHRoaXMuYWRkKG5vZGUpO1xuICB9XG5cbiAgdG9IVE1MKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IEhUTUxSZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZW5kZXJlci52YWx1ZSgpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFueU51bWJlck9mVGltZXMocmUpIHtcbiAgcmV0dXJuIGNvbmNhdCgnKD86JywgcmUsICcpKicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/OicsIHJlLCAnKT8nKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyBBcnJheTxzdHJpbmcgfCBSZWdFeHAgfCBPYmplY3Q+IH0gYXJnc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncykge1xuICBjb25zdCBvcHRzID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgYXJncy5zcGxpY2UoYXJncy5sZW5ndGggLSAxLCAxKTtcbiAgICByZXR1cm4gb3B0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHsge2NhcHR1cmU/OiBib29sZWFufSB9IFJlZ2V4RWl0aGVyT3B0aW9ucyAqL1xuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfCBbLi4uKFJlZ0V4cCB8IHN0cmluZylbXSwgUmVnZXhFaXRoZXJPcHRpb25zXX0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZWl0aGVyKC4uLmFyZ3MpIHtcbiAgLyoqIEB0eXBlIHsgb2JqZWN0ICYge2NhcHR1cmU/OiBib29sZWFufSB9ICAqL1xuICBjb25zdCBvcHRzID0gc3RyaXBPcHRpb25zRnJvbUFyZ3MoYXJncyk7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJ1xuICAgICsgKG9wdHMuY2FwdHVyZSA/IFwiXCIgOiBcIj86XCIpXG4gICAgKyBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nfSByZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY291bnRNYXRjaEdyb3VwcyhyZSkge1xuICByZXR1cm4gKG5ldyBSZWdFeHAocmUudG9TdHJpbmcoKSArICd8JykpLmV4ZWMoJycpLmxlbmd0aCAtIDE7XG59XG5cbi8qKlxuICogRG9lcyBsZXhlbWUgc3RhcnQgd2l0aCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBhdCB0aGUgYmVnaW5uaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWVcbiAqL1xuZnVuY3Rpb24gc3RhcnRzV2l0aChyZSwgbGV4ZW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG59XG5cbi8vIEJBQ0tSRUZfUkUgbWF0Y2hlcyBhbiBvcGVuIHBhcmVudGhlc2lzIG9yIGJhY2tyZWZlcmVuY2UuIFRvIGF2b2lkXG4vLyBhbiBpbmNvcnJlY3QgcGFyc2UsIGl0IGFkZGl0aW9uYWxseSBtYXRjaGVzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIFsuLi5dIGVsZW1lbnRzLCB3aGVyZSB0aGUgbWVhbmluZyBvZiBwYXJlbnRoZXNlcyBhbmQgZXNjYXBlcyBjaGFuZ2Vcbi8vIC0gb3RoZXIgZXNjYXBlIHNlcXVlbmNlcywgc28gd2UgZG8gbm90IG1pc3BhcnNlIGVzY2FwZSBzZXF1ZW5jZXMgYXNcbi8vICAgaW50ZXJlc3RpbmcgZWxlbWVudHNcbi8vIC0gbm9uLW1hdGNoaW5nIG9yIGxvb2thaGVhZCBwYXJlbnRoZXNlcywgd2hpY2ggZG8gbm90IGNhcHR1cmUuIFRoZXNlXG4vLyAgIGZvbGxvdyB0aGUgJygnIHdpdGggYSAnPycuXG5jb25zdCBCQUNLUkVGX1JFID0gL1xcWyg/OlteXFxcXFxcXV18XFxcXC4pKlxcXXxcXChcXD8/fFxcXFwoWzEtOV1bMC05XSopfFxcXFwuLztcblxuLy8gKipJTlRFUk5BTCoqIE5vdCBpbnRlbmRlZCBmb3Igb3V0c2lkZSB1c2FnZVxuLy8gam9pbiBsb2dpY2FsbHkgY29tcHV0ZXMgcmVnZXhwcy5qb2luKHNlcGFyYXRvciksIGJ1dCBmaXhlcyB0aGVcbi8vIGJhY2tyZWZlcmVuY2VzIHNvIHRoZXkgY29udGludWUgdG8gbWF0Y2guXG4vLyBpdCBhbHNvIHBsYWNlcyBlYWNoIGluZGl2aWR1YWwgcmVndWxhciBleHByZXNzaW9uIGludG8gaXQncyBvd25cbi8vIG1hdGNoIGdyb3VwLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBzZXF1ZW5jaW5nIG9mIHRob3NlIG1hdGNoIGdyb3Vwc1xuLy8gaXMgY3VycmVudGx5IGFuIGV4ZXJjaXNlIGZvciB0aGUgY2FsbGVyLiA6LSlcbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdfSByZWdleHBzXG4gKiBAcGFyYW0ge3tqb2luV2l0aDogc3RyaW5nfX0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhyZWdleHBzLCB7IGpvaW5XaXRoIH0pIHtcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcblxuICByZXR1cm4gcmVnZXhwcy5tYXAoKHJlZ2V4KSA9PiB7XG4gICAgbnVtQ2FwdHVyZXMgKz0gMTtcbiAgICBjb25zdCBvZmZzZXQgPSBudW1DYXB0dXJlcztcbiAgICBsZXQgcmUgPSBzb3VyY2UocmVnZXgpO1xuICAgIGxldCBvdXQgPSAnJztcblxuICAgIHdoaWxlIChyZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IEJBQ0tSRUZfUkUuZXhlYyhyZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIG91dCArPSByZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvdXQgKz0gcmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgIHJlID0gcmUuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChtYXRjaFswXVswXSA9PT0gJ1xcXFwnICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgYmFja3JlZmVyZW5jZS5cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZyhOdW1iZXIobWF0Y2hbMV0pICsgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgICAgICBudW1DYXB0dXJlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pLm1hcChyZSA9PiBgKCR7cmV9KWApLmpvaW4oam9pbldpdGgpO1xufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGVDYWxsYmFja30gTW9kZUNhbGxiYWNrICovXG5cbi8vIENvbW1vbiByZWdleHBzXG5jb25zdCBNQVRDSF9OT1RISU5HX1JFID0gL1xcYlxcQi87XG5jb25zdCBJREVOVF9SRSQxID0gJ1thLXpBLVpdXFxcXHcqJztcbmNvbnN0IFVOREVSU0NPUkVfSURFTlRfUkUgPSAnW2EtekEtWl9dXFxcXHcqJztcbmNvbnN0IE5VTUJFUl9SRSA9ICdcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKyk/JztcbmNvbnN0IENfTlVNQkVSX1JFID0gJygtPykoXFxcXGIwW3hYXVthLWZBLUYwLTldK3woXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCopP3xcXFxcLlxcXFxkKykoW2VFXVstK10/XFxcXGQrKT8pJzsgLy8gMHguLi4sIDAuLi4sIGRlY2ltYWwsIGZsb2F0XG5jb25zdCBCSU5BUllfTlVNQkVSX1JFID0gJ1xcXFxiKDBiWzAxXSspJzsgLy8gMGIuLi5cbmNvbnN0IFJFX1NUQVJURVJTX1JFID0gJyF8IT18IT09fCV8JT18JnwmJnwmPXxcXFxcKnxcXFxcKj18XFxcXCt8XFxcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXFxcP3xcXFxcW3xcXFxce3xcXFxcKHxcXFxcXnxcXFxcXj18XFxcXHx8XFxcXHw9fFxcXFx8XFxcXHx8fic7XG5cbi8qKlxuKiBAcGFyYW0geyBQYXJ0aWFsPE1vZGU+ICYge2JpbmFyeT86IHN0cmluZyB8IFJlZ0V4cH0gfSBvcHRzXG4qL1xuY29uc3QgU0hFQkFORyA9IChvcHRzID0ge30pID0+IHtcbiAgY29uc3QgYmVnaW5TaGViYW5nID0gL14jIVsgXSpcXC8vO1xuICBpZiAob3B0cy5iaW5hcnkpIHtcbiAgICBvcHRzLmJlZ2luID0gY29uY2F0KFxuICAgICAgYmVnaW5TaGViYW5nLFxuICAgICAgLy4qXFxiLyxcbiAgICAgIG9wdHMuYmluYXJ5LFxuICAgICAgL1xcYi4qLyk7XG4gIH1cbiAgcmV0dXJuIGluaGVyaXQkMSh7XG4gICAgc2NvcGU6ICdtZXRhJyxcbiAgICBiZWdpbjogYmVnaW5TaGViYW5nLFxuICAgIGVuZDogLyQvLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICAvKiogQHR5cGUge01vZGVDYWxsYmFja30gKi9cbiAgICBcIm9uOmJlZ2luXCI6IChtLCByZXNwKSA9PiB7XG4gICAgICBpZiAobS5pbmRleCAhPT0gMCkgcmVzcC5pZ25vcmVNYXRjaCgpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG59O1xuXG4vLyBDb21tb24gbW9kZXNcbmNvbnN0IEJBQ0tTTEFTSF9FU0NBUEUgPSB7XG4gIGJlZ2luOiAnXFxcXFxcXFxbXFxcXHNcXFxcU10nLCByZWxldmFuY2U6IDBcbn07XG5jb25zdCBBUE9TX1NUUklOR19NT0RFID0ge1xuICBzY29wZTogJ3N0cmluZycsXG4gIGJlZ2luOiAnXFwnJyxcbiAgZW5kOiAnXFwnJyxcbiAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgY29udGFpbnM6IFtCQUNLU0xBU0hfRVNDQVBFXVxufTtcbmNvbnN0IFFVT1RFX1NUUklOR19NT0RFID0ge1xuICBzY29wZTogJ3N0cmluZycsXG4gIGJlZ2luOiAnXCInLFxuICBlbmQ6ICdcIicsXG4gIGlsbGVnYWw6ICdcXFxcbicsXG4gIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbn07XG5jb25zdCBQSFJBU0FMX1dPUkRTX01PREUgPSB7XG4gIGJlZ2luOiAvXFxiKGF8YW58dGhlfGFyZXxJJ218aXNuJ3R8ZG9uJ3R8ZG9lc24ndHx3b24ndHxidXR8anVzdHxzaG91bGR8cHJldHR5fHNpbXBseXxlbm91Z2h8Z29ubmF8Z29pbmd8d3RmfHNvfHN1Y2h8d2lsbHx5b3V8eW91cnx0aGV5fGxpa2V8bW9yZSlcXGIvXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgY29tbWVudCBtb2RlXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IGJlZ2luXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gZW5kXG4gKiBAcGFyYW0ge01vZGUgfCB7fX0gW21vZGVPcHRpb25zXVxuICogQHJldHVybnMge1BhcnRpYWw8TW9kZT59XG4gKi9cbmNvbnN0IENPTU1FTlQgPSBmdW5jdGlvbihiZWdpbiwgZW5kLCBtb2RlT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG1vZGUgPSBpbmhlcml0JDEoXG4gICAge1xuICAgICAgc2NvcGU6ICdjb21tZW50JyxcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgY29udGFpbnM6IFtdXG4gICAgfSxcbiAgICBtb2RlT3B0aW9uc1xuICApO1xuICBtb2RlLmNvbnRhaW5zLnB1c2goe1xuICAgIHNjb3BlOiAnZG9jdGFnJyxcbiAgICAvLyBoYWNrIHRvIGF2b2lkIHRoZSBzcGFjZSBmcm9tIGJlaW5nIGluY2x1ZGVkLiB0aGUgc3BhY2UgaXMgbmVjZXNzYXJ5IHRvXG4gICAgLy8gbWF0Y2ggaGVyZSB0byBwcmV2ZW50IHRoZSBwbGFpbiB0ZXh0IHJ1bGUgYmVsb3cgZnJvbSBnb2JibGluZyB1cCBkb2N0YWdzXG4gICAgYmVnaW46ICdbIF0qKD89KFRPRE98RklYTUV8Tk9URXxCVUd8T1BUSU1JWkV8SEFDS3xYWFgpOiknLFxuICAgIGVuZDogLyhUT0RPfEZJWE1FfE5PVEV8QlVHfE9QVElNSVpFfEhBQ0t8WFhYKTovLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICByZWxldmFuY2U6IDBcbiAgfSk7XG4gIGNvbnN0IEVOR0xJU0hfV09SRCA9IGVpdGhlcihcbiAgICAvLyBsaXN0IG9mIGNvbW1vbiAxIGFuZCAyIGxldHRlciB3b3JkcyBpbiBFbmdsaXNoXG4gICAgXCJJXCIsXG4gICAgXCJhXCIsXG4gICAgXCJpc1wiLFxuICAgIFwic29cIixcbiAgICBcInVzXCIsXG4gICAgXCJ0b1wiLFxuICAgIFwiYXRcIixcbiAgICBcImlmXCIsXG4gICAgXCJpblwiLFxuICAgIFwiaXRcIixcbiAgICBcIm9uXCIsXG4gICAgLy8gbm90ZTogdGhpcyBpcyBub3QgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIGNvbnRyYWN0aW9ucywganVzdCBwb3B1bGFyIG9uZXNcbiAgICAvW0EtWmEtel0rWyddKGR8dmV8cmV8bGx8dHxzfG4pLywgLy8gY29udHJhY3Rpb25zIC0gY2FuJ3Qgd2UnZCB0aGV5J3JlIGxldCdzLCBldGNcbiAgICAvW0EtWmEtel0rWy1dW2Etel0rLywgLy8gYG5vLXdheWAsIGV0Yy5cbiAgICAvW0EtWmEtel1bYS16XXsyLH0vIC8vIGFsbG93IGNhcGl0YWxpemVkIHdvcmRzIGF0IGJlZ2lubmluZyBvZiBzZW50ZW5jZXNcbiAgKTtcbiAgLy8gbG9va2luZyBsaWtlIHBsYWluIHRleHQsIG1vcmUgbGlrZWx5IHRvIGJlIGEgY29tbWVudFxuICBtb2RlLmNvbnRhaW5zLnB1c2goXG4gICAge1xuICAgICAgLy8gVE9ETzogaG93IHRvIGluY2x1ZGUgXCIsICgsICkgd2l0aG91dCBicmVha2luZyBncmFtbWFycyB0aGF0IHVzZSB0aGVzZSBmb3JcbiAgICAgIC8vIGNvbW1lbnQgZGVsaW1pdGVycz9cbiAgICAgIC8vIGJlZ2luOiAvWyBdKyhbKClcIl0/KFtBLVphLXonLV17Myx9fGlzfGF8SXxzb3x1c3xbdFRdW29PXXxhdHxpZnxpbnxpdHxvbilbLl0/WygpXCI6XT8oWy5dWyBdfFsgXXxcXCkpKXszfS9cbiAgICAgIC8vIC0tLVxuXG4gICAgICAvLyB0aGlzIHRyaWVzIHRvIGZpbmQgc2VxdWVuY2VzIG9mIDMgZW5nbGlzaCB3b3JkcyBpbiBhIHJvdyAod2l0aG91dCBhbnlcbiAgICAgIC8vIFwicHJvZ3JhbW1pbmdcIiB0eXBlIHN5bnRheCkgdGhpcyBnaXZlcyB1cyBhIHN0cm9uZyBzaWduYWwgdGhhdCB3ZSd2ZVxuICAgICAgLy8gVFJVTFkgZm91bmQgYSBjb21tZW50IC0gdnMgcGVyaGFwcyBzY2FubmluZyB3aXRoIHRoZSB3cm9uZyBsYW5ndWFnZS5cbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdG8gZmluZCBzb21ldGhpbmcgdGhhdCBMT09LUyBsaWtlIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgIC8vIGNvbW1lbnQgLSBidXQgdGhlbiBpZiB0aGVyZSBpcyBubyByZWFkYWJsZSB0ZXh0IC0gZ29vZCBjaGFuY2UgaXQgaXMgYVxuICAgICAgLy8gZmFsc2UgbWF0Y2ggYW5kIG5vdCBhIGNvbW1lbnQuXG4gICAgICAvL1xuICAgICAgLy8gZm9yIGEgdmlzdWFsIGV4YW1wbGUgcGxlYXNlIHNlZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4MjdcblxuICAgICAgYmVnaW46IGNvbmNhdChcbiAgICAgICAgL1sgXSsvLCAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCB1cyBnb2JibGluZyB1cCBkb2N0YWdzIGxpa2UgLyogQGF1dGhvciBCb2IgTWNnaWxsICovXG4gICAgICAgICcoJyxcbiAgICAgICAgRU5HTElTSF9XT1JELFxuICAgICAgICAvWy5dP1s6XT8oWy5dWyBdfFsgXSkvLFxuICAgICAgICAnKXszfScpIC8vIGxvb2sgZm9yIDMgd29yZHMgaW4gYSByb3dcbiAgICB9XG4gICk7XG4gIHJldHVybiBtb2RlO1xufTtcbmNvbnN0IENfTElORV9DT01NRU5UX01PREUgPSBDT01NRU5UKCcvLycsICckJyk7XG5jb25zdCBDX0JMT0NLX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJy9cXFxcKicsICdcXFxcKi8nKTtcbmNvbnN0IEhBU0hfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnIycsICckJyk7XG5jb25zdCBOVU1CRVJfTU9ERSA9IHtcbiAgc2NvcGU6ICdudW1iZXInLFxuICBiZWdpbjogTlVNQkVSX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBDX05VTUJFUl9NT0RFID0ge1xuICBzY29wZTogJ251bWJlcicsXG4gIGJlZ2luOiBDX05VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQklOQVJZX05VTUJFUl9NT0RFID0ge1xuICBzY29wZTogJ251bWJlcicsXG4gIGJlZ2luOiBCSU5BUllfTlVNQkVSX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBSRUdFWFBfTU9ERSA9IHtcbiAgLy8gdGhpcyBvdXRlciBydWxlIG1ha2VzIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIFdIT0xFIHJlZ2V4IGFuZCBub3Qgc2ltcGx5XG4gIC8vIGFuIGV4cHJlc3Npb24gc3VjaCBhczpcbiAgLy9cbiAgLy8gICAgIDMgLyBzb21ldGhpbmdcbiAgLy9cbiAgLy8gKHdoaWNoIHdpbGwgdGhlbiBibG93IHVwIHdoZW4gcmVnZXgncyBgaWxsZWdhbGAgc2VlcyB0aGUgbmV3bGluZSlcbiAgYmVnaW46IC8oPz1cXC9bXi9cXG5dKlxcLykvLFxuICBjb250YWluczogW3tcbiAgICBzY29wZTogJ3JlZ2V4cCcsXG4gICAgYmVnaW46IC9cXC8vLFxuICAgIGVuZDogL1xcL1tnaW11eV0qLyxcbiAgICBpbGxlZ2FsOiAvXFxuLyxcbiAgICBjb250YWluczogW1xuICAgICAgQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXFsvLFxuICAgICAgICBlbmQ6IC9cXF0vLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH1dXG59O1xuY29uc3QgVElUTEVfTU9ERSA9IHtcbiAgc2NvcGU6ICd0aXRsZScsXG4gIGJlZ2luOiBJREVOVF9SRSQxLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBVTkRFUlNDT1JFX1RJVExFX01PREUgPSB7XG4gIHNjb3BlOiAndGl0bGUnLFxuICBiZWdpbjogVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgTUVUSE9EX0dVQVJEID0ge1xuICAvLyBleGNsdWRlcyBtZXRob2QgbmFtZXMgZnJvbSBrZXl3b3JkIHByb2Nlc3NpbmdcbiAgYmVnaW46ICdcXFxcLlxcXFxzKicgKyBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5cbi8qKlxuICogQWRkcyBlbmQgc2FtZSBhcyBiZWdpbiBtZWNoYW5pY3MgdG8gYSBtb2RlXG4gKlxuICogWW91ciBtb2RlIG11c3QgaW5jbHVkZSBhdCBsZWFzdCBhIHNpbmdsZSAoKSBtYXRjaCBncm91cCBhcyB0aGF0IGZpcnN0IG1hdGNoXG4gKiBncm91cCBpcyB3aGF0IGlzIHVzZWQgZm9yIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7UGFydGlhbDxNb2RlPn0gbW9kZVxuICovXG5jb25zdCBFTkRfU0FNRV9BU19CRUdJTiA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obW9kZSxcbiAgICB7XG4gICAgICAvKiogQHR5cGUge01vZGVDYWxsYmFja30gKi9cbiAgICAgICdvbjpiZWdpbic6IChtLCByZXNwKSA9PiB7IHJlc3AuZGF0YS5fYmVnaW5NYXRjaCA9IG1bMV07IH0sXG4gICAgICAvKiogQHR5cGUge01vZGVDYWxsYmFja30gKi9cbiAgICAgICdvbjplbmQnOiAobSwgcmVzcCkgPT4geyBpZiAocmVzcC5kYXRhLl9iZWdpbk1hdGNoICE9PSBtWzFdKSByZXNwLmlnbm9yZU1hdGNoKCk7IH1cbiAgICB9KTtcbn07XG5cbnZhciBNT0RFUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgTUFUQ0hfTk9USElOR19SRTogTUFUQ0hfTk9USElOR19SRSxcbiAgICBJREVOVF9SRTogSURFTlRfUkUkMSxcbiAgICBVTkRFUlNDT1JFX0lERU5UX1JFOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIE5VTUJFUl9SRTogTlVNQkVSX1JFLFxuICAgIENfTlVNQkVSX1JFOiBDX05VTUJFUl9SRSxcbiAgICBCSU5BUllfTlVNQkVSX1JFOiBCSU5BUllfTlVNQkVSX1JFLFxuICAgIFJFX1NUQVJURVJTX1JFOiBSRV9TVEFSVEVSU19SRSxcbiAgICBTSEVCQU5HOiBTSEVCQU5HLFxuICAgIEJBQ0tTTEFTSF9FU0NBUEU6IEJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgQVBPU19TVFJJTkdfTU9ERTogQVBPU19TVFJJTkdfTU9ERSxcbiAgICBRVU9URV9TVFJJTkdfTU9ERTogUVVPVEVfU1RSSU5HX01PREUsXG4gICAgUEhSQVNBTF9XT1JEU19NT0RFOiBQSFJBU0FMX1dPUkRTX01PREUsXG4gICAgQ09NTUVOVDogQ09NTUVOVCxcbiAgICBDX0xJTkVfQ09NTUVOVF9NT0RFOiBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgIENfQkxPQ0tfQ09NTUVOVF9NT0RFOiBDX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBIQVNIX0NPTU1FTlRfTU9ERTogSEFTSF9DT01NRU5UX01PREUsXG4gICAgTlVNQkVSX01PREU6IE5VTUJFUl9NT0RFLFxuICAgIENfTlVNQkVSX01PREU6IENfTlVNQkVSX01PREUsXG4gICAgQklOQVJZX05VTUJFUl9NT0RFOiBCSU5BUllfTlVNQkVSX01PREUsXG4gICAgUkVHRVhQX01PREU6IFJFR0VYUF9NT0RFLFxuICAgIFRJVExFX01PREU6IFRJVExFX01PREUsXG4gICAgVU5ERVJTQ09SRV9USVRMRV9NT0RFOiBVTkRFUlNDT1JFX1RJVExFX01PREUsXG4gICAgTUVUSE9EX0dVQVJEOiBNRVRIT0RfR1VBUkQsXG4gICAgRU5EX1NBTUVfQVNfQkVHSU46IEVORF9TQU1FX0FTX0JFR0lOXG59KTtcblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5DYWxsYmFja1Jlc3BvbnNlfSBDYWxsYmFja1Jlc3BvbnNlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlckV4dH0gQ29tcGlsZXJFeHRcbiovXG5cbi8vIEdyYW1tYXIgZXh0ZW5zaW9ucyAvIHBsdWdpbnNcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjgzM1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgYWxsb3cgXCJzeW50YWN0aWMgc3VnYXJcIiB0byBiZSBhZGRlZCB0byB0aGUgZ3JhbW1hciBtb2Rlc1xuLy8gd2l0aG91dCByZXF1aXJpbmcgYW55IHVuZGVybHlpbmcgY2hhbmdlcyB0byB0aGUgY29tcGlsZXIgaW50ZXJuYWxzLlxuXG4vLyBgY29tcGlsZU1hdGNoYCBiZWluZyB0aGUgcGVyZmVjdCBzbWFsbCBleGFtcGxlIG9mIG5vdyBhbGxvd2luZyBhIGdyYW1tYXJcbi8vIGF1dGhvciB0byB3cml0ZSBgbWF0Y2hgIHdoZW4gdGhleSBkZXNpcmUgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiByYXRoZXJcbi8vIHRoYW4gYmVpbmcgZm9yY2VkIHRvIHVzZSBgYmVnaW5gLiAgVGhlIGV4dGVuc2lvbiB0aGVuIGp1c3QgbW92ZXMgYG1hdGNoYCBpbnRvXG4vLyBgYmVnaW5gIHdoZW4gaXQgcnVucy4gIEllLCBubyBmZWF0dXJlcyBoYXZlIGJlZW4gYWRkZWQsIGJ1dCB3ZSd2ZSBqdXN0IG1hZGVcbi8vIHRoZSBleHBlcmllbmNlIG9mIHdyaXRpbmcgKGFuZCByZWFkaW5nIGdyYW1tYXJzKSBhIGxpdHRsZSBiaXQgbmljZXIuXG5cbi8vIC0tLS0tLVxuXG4vLyBUT0RPOiBXZSBuZWVkIG5lZ2F0aXZlIGxvb2stYmVoaW5kIHN1cHBvcnQgdG8gZG8gdGhpcyBwcm9wZXJseVxuLyoqXG4gKiBTa2lwIGEgbWF0Y2ggaWYgaXQgaGFzIGEgcHJlY2VkaW5nIGRvdFxuICpcbiAqIFRoaXMgaXMgdXNlZCBmb3IgYGJlZ2luS2V5d29yZHNgIHRvIHByZXZlbnQgbWF0Y2hpbmcgZXhwcmVzc2lvbnMgc3VjaCBhc1xuICogYGJvYi5rZXl3b3JkLmRvKClgLiBUaGUgbW9kZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHdpcmVzIHRoaXMgdXAgYXMgYVxuICogc3BlY2lhbCBfaW50ZXJuYWxfICdvbjpiZWdpbicgY2FsbGJhY2sgZm9yIG1vZGVzIHdpdGggYGJlZ2luS2V5d29yZHNgXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gKiBAcGFyYW0ge0NhbGxiYWNrUmVzcG9uc2V9IHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIHNraXBJZkhhc1ByZWNlZGluZ0RvdChtYXRjaCwgcmVzcG9uc2UpIHtcbiAgY29uc3QgYmVmb3JlID0gbWF0Y2guaW5wdXRbbWF0Y2guaW5kZXggLSAxXTtcbiAgaWYgKGJlZm9yZSA9PT0gXCIuXCIpIHtcbiAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gc2NvcGVDbGFzc05hbWUobW9kZSwgX3BhcmVudCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChtb2RlLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZS5zY29wZSA9IG1vZGUuY2xhc3NOYW1lO1xuICAgIGRlbGV0ZSBtb2RlLmNsYXNzTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIGBiZWdpbktleXdvcmRzYCBzeW50YWN0aWMgc3VnYXJcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gYmVnaW5LZXl3b3Jkcyhtb2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgaWYgKCFtb2RlLmJlZ2luS2V5d29yZHMpIHJldHVybjtcblxuICAvLyBmb3IgbGFuZ3VhZ2VzIHdpdGgga2V5d29yZHMgdGhhdCBpbmNsdWRlIG5vbi13b3JkIGNoYXJhY3RlcnMgY2hlY2tpbmcgZm9yXG4gIC8vIGEgd29yZCBib3VuZGFyeSBpcyBub3Qgc3VmZmljaWVudCwgc28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgYSB3b3JkIGJvdW5kYXJ5XG4gIC8vIG9yIHdoaXRlc3BhY2UgLSB0aGlzIGRvZXMgbm8gaGFybSBpbiBhbnkgY2FzZSBzaW5jZSBvdXIga2V5d29yZCBlbmdpbmVcbiAgLy8gZG9lc24ndCBhbGxvdyBzcGFjZXMgaW4ga2V5d29yZHMgYW55d2F5cyBhbmQgd2Ugc3RpbGwgY2hlY2sgZm9yIHRoZSBib3VuZGFyeVxuICAvLyBmaXJzdFxuICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKSg/IVxcXFwuKSg/PVxcXFxifFxcXFxzKSc7XG4gIG1vZGUuX19iZWZvcmVCZWdpbiA9IHNraXBJZkhhc1ByZWNlZGluZ0RvdDtcbiAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICBkZWxldGUgbW9kZS5iZWdpbktleXdvcmRzO1xuXG4gIC8vIHByZXZlbnRzIGRvdWJsZSByZWxldmFuY2UsIHRoZSBrZXl3b3JkcyB0aGVtc2VsdmVzIHByb3ZpZGVcbiAgLy8gcmVsZXZhbmNlLCB0aGUgbW9kZSBkb2Vzbid0IG5lZWQgdG8gZG91YmxlIGl0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMDtcbn1cblxuLyoqXG4gKiBBbGxvdyBgaWxsZWdhbGAgdG8gY29udGFpbiBhbiBhcnJheSBvZiBpbGxlZ2FsIHZhbHVlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlSWxsZWdhbChtb2RlLCBfcGFyZW50KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmlsbGVnYWwpKSByZXR1cm47XG5cbiAgbW9kZS5pbGxlZ2FsID0gZWl0aGVyKC4uLm1vZGUuaWxsZWdhbCk7XG59XG5cbi8qKlxuICogYG1hdGNoYCB0byBtYXRjaCBhIHNpbmdsZSBleHByZXNzaW9uIGZvciByZWFkYWJpbGl0eVxuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0Y2gobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIW1vZGUubWF0Y2gpIHJldHVybjtcbiAgaWYgKG1vZGUuYmVnaW4gfHwgbW9kZS5lbmQpIHRocm93IG5ldyBFcnJvcihcImJlZ2luICYgZW5kIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWF0Y2hcIik7XG5cbiAgbW9kZS5iZWdpbiA9IG1vZGUubWF0Y2g7XG4gIGRlbGV0ZSBtb2RlLm1hdGNoO1xufVxuXG4vKipcbiAqIHByb3ZpZGVzIHRoZSBkZWZhdWx0IDEgcmVsZXZhbmNlIHRvIGFsbCBtb2Rlc1xuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBjb21waWxlUmVsZXZhbmNlKG1vZGUsIF9wYXJlbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobW9kZS5yZWxldmFuY2UgPT09IHVuZGVmaW5lZCkgbW9kZS5yZWxldmFuY2UgPSAxO1xufVxuXG4vLyBhbGxvdyBiZWZvcmVNYXRjaCB0byBhY3QgYXMgYSBcInF1YWxpZmllclwiIGZvciB0aGUgbWF0Y2hcbi8vIHRoZSBmdWxsIG1hdGNoIGJlZ2luIG11c3QgYmUgW2JlZm9yZU1hdGNoXVtiZWdpbl1cbmNvbnN0IGJlZm9yZU1hdGNoRXh0ID0gKG1vZGUsIHBhcmVudCkgPT4ge1xuICBpZiAoIW1vZGUuYmVmb3JlTWF0Y2gpIHJldHVybjtcbiAgLy8gc3RhcnRzIGNvbmZsaWN0cyB3aXRoIGVuZHNQYXJlbnQgd2hpY2ggd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNoaWxkXG4gIC8vIHJ1bGUgaXMgbm90IG1hdGNoZWQgbXVsdGlwbGUgdGltZXNcbiAgaWYgKG1vZGUuc3RhcnRzKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWZvcmVNYXRjaCBjYW5ub3QgYmUgdXNlZCB3aXRoIHN0YXJ0c1wiKTtcblxuICBjb25zdCBvcmlnaW5hbE1vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlKTtcbiAgT2JqZWN0LmtleXMobW9kZSkuZm9yRWFjaCgoa2V5KSA9PiB7IGRlbGV0ZSBtb2RlW2tleV07IH0pO1xuXG4gIG1vZGUua2V5d29yZHMgPSBvcmlnaW5hbE1vZGUua2V5d29yZHM7XG4gIG1vZGUuYmVnaW4gPSBjb25jYXQob3JpZ2luYWxNb2RlLmJlZm9yZU1hdGNoLCBsb29rYWhlYWQob3JpZ2luYWxNb2RlLmJlZ2luKSk7XG4gIG1vZGUuc3RhcnRzID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAgT2JqZWN0LmFzc2lnbihvcmlnaW5hbE1vZGUsIHsgZW5kc1BhcmVudDogdHJ1ZSB9KVxuICAgIF1cbiAgfTtcbiAgbW9kZS5yZWxldmFuY2UgPSAwO1xuXG4gIGRlbGV0ZSBvcmlnaW5hbE1vZGUuYmVmb3JlTWF0Y2g7XG59O1xuXG4vLyBrZXl3b3JkcyB0aGF0IHNob3VsZCBoYXZlIG5vIGRlZmF1bHQgcmVsZXZhbmNlIHZhbHVlXG5jb25zdCBDT01NT05fS0VZV09SRFMgPSBbXG4gICdvZicsXG4gICdhbmQnLFxuICAnZm9yJyxcbiAgJ2luJyxcbiAgJ25vdCcsXG4gICdvcicsXG4gICdpZicsXG4gICd0aGVuJyxcbiAgJ3BhcmVudCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICdsaXN0JywgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbiAgJ3ZhbHVlJyAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuXTtcblxuY29uc3QgREVGQVVMVF9LRVlXT1JEX1NDT1BFID0gXCJrZXl3b3JkXCI7XG5cbi8qKlxuICogR2l2ZW4gcmF3IGtleXdvcmRzIGZyb20gYSBsYW5ndWFnZSBkZWZpbml0aW9uLCBjb21waWxlIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLHN0cmluZ3xzdHJpbmdbXT4gfCBBcnJheTxzdHJpbmc+fSByYXdLZXl3b3Jkc1xuICogQHBhcmFtIHtib29sZWFufSBjYXNlSW5zZW5zaXRpdmVcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzLCBjYXNlSW5zZW5zaXRpdmUsIHNjb3BlTmFtZSA9IERFRkFVTFRfS0VZV09SRF9TQ09QRSkge1xuICAvKiogQHR5cGUgS2V5d29yZERpY3QgKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gaW5wdXQgY2FuIGJlIGEgc3RyaW5nIG9mIGtleXdvcmRzLCBhbiBhcnJheSBvZiBrZXl3b3Jkcywgb3IgYSBvYmplY3Qgd2l0aFxuICAvLyBuYW1lZCBrZXlzIHJlcHJlc2VudGluZyBzY29wZU5hbWUgKHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIGEgc3RyaW5nIG9yIGFycmF5KVxuICBpZiAodHlwZW9mIHJhd0tleXdvcmRzID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJhd0tleXdvcmRzKSkge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKHJhd0tleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjb3BlTmFtZSkge1xuICAgICAgLy8gY29sbGFwc2UgYWxsIG91ciBvYmplY3RzIGJhY2sgaW50byB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgY29tcGlsZWRLZXl3b3JkcyxcbiAgICAgICAgY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzW3Njb3BlTmFtZV0sIGNhc2VJbnNlbnNpdGl2ZSwgc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tcGlsZWRLZXl3b3JkcztcblxuICAvLyAtLS1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBsaXN0IG9mIGtleXdvcmRzXG4gICAqXG4gICAqIEV4OiBcImZvciBpZiB3aGVuIHdoaWxlfDVcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVOYW1lXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5d29yZExpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwga2V5d29yZExpc3QpIHtcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBrZXl3b3JkTGlzdCA9IGtleXdvcmRMaXN0Lm1hcCh4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGtleXdvcmRMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgY29uc3QgcGFpciA9IGtleXdvcmQuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBpbGVkS2V5d29yZHNbcGFpclswXV0gPSBbc2NvcGVOYW1lLCBzY29yZUZvcktleXdvcmQocGFpclswXSwgcGFpclsxXSldO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvcGVyIHNjb3JlIGZvciBhIGdpdmVuIGtleXdvcmRcbiAqXG4gKiBBbHNvIHRha2VzIGludG8gYWNjb3VudCBjb21tZW50IGtleXdvcmRzLCB3aGljaCB3aWxsIGJlIHNjb3JlZCAwIFVOTEVTU1xuICogYW5vdGhlciBzY29yZSBoYXMgYmVlbiBtYW51YWxseSBhc3NpZ25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkU2NvcmVdXG4gKi9cbmZ1bmN0aW9uIHNjb3JlRm9yS2V5d29yZChrZXl3b3JkLCBwcm92aWRlZFNjb3JlKSB7XG4gIC8vIG1hbnVhbCBzY29yZXMgYWx3YXlzIHdpbiBvdmVyIGNvbW1vbiBrZXl3b3Jkc1xuICAvLyBzbyB5b3UgY2FuIGZvcmNlIGEgc2NvcmUgb2YgMSBpZiB5b3UgcmVhbGx5IGluc2lzdFxuICBpZiAocHJvdmlkZWRTY29yZSkge1xuICAgIHJldHVybiBOdW1iZXIocHJvdmlkZWRTY29yZSk7XG4gIH1cblxuICByZXR1cm4gY29tbW9uS2V5d29yZChrZXl3b3JkKSA/IDAgOiAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBrZXl3b3JkIGlzIGNvbW1vbiBvciBub3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZCAqL1xuZnVuY3Rpb24gY29tbW9uS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBDT01NT05fS0VZV09SRFMuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLypcblxuRm9yIHRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgcGxlYXNlIHNlZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODAjaXNzdWVjb21tZW50LTc0NzI3NTQxOVxuXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuY29uc3Qgc2VlbkRlcHJlY2F0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7YW55fSBhcmdzXG4gKi9cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyhgV0FSTjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3QgZGVwcmVjYXRlZCA9ICh2ZXJzaW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChzZWVuRGVwcmVjYXRpb25zW2Ake3ZlcnNpb259LyR7bWVzc2FnZX1gXSkgcmV0dXJuO1xuXG4gIGNvbnNvbGUubG9nKGBEZXByZWNhdGVkIGFzIG9mICR7dmVyc2lvbn0uICR7bWVzc2FnZX1gKTtcbiAgc2VlbkRlcHJlY2F0aW9uc1tgJHt2ZXJzaW9ufS8ke21lc3NhZ2V9YF0gPSB0cnVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGhyb3ctbGl0ZXJhbCAqL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG4qL1xuXG5jb25zdCBNdWx0aUNsYXNzRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBSZW51bWJlcnMgbGFiZWxlZCBzY29wZSBuYW1lcyB0byBhY2NvdW50IGZvciBhZGRpdGlvbmFsIGlubmVyIG1hdGNoXG4gKiBncm91cHMgdGhhdCBvdGhlcndpc2Ugd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAqXG4gKiBMZXRzIHNheSB3ZSAzIG1hdGNoIHNjb3BlczpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCAzID0+IC4uLiB9XG4gKlxuICogU28gd2hhdCB3ZSBuZWVkIGlzIGEgY2xlYW4gbWF0Y2ggbGlrZSB0aGlzOlxuICpcbiAqICAgKGEpKGIpKGMpID0+IFsgXCJhXCIsIFwiYlwiLCBcImNcIiBdXG4gKlxuICogQnV0IHRoaXMgZmFsbHMgYXBhcnQgd2l0aCBpbm5lciBtYXRjaCBncm91cHM6XG4gKlxuICogKGEpKCgoYikpKShjKSA9PiBbXCJhXCIsIFwiYlwiLCBcImJcIiwgXCJiXCIsIFwiY1wiIF1cbiAqXG4gKiBPdXIgc2NvcGVzIGFyZSBub3cgXCJvdXQgb2YgYWxpZ25tZW50XCIgYW5kIHdlJ3JlIHJlcGVhdGluZyBgYmAgMyB0aW1lcy5cbiAqIFdoYXQgbmVlZHMgdG8gaGFwcGVuIGlzIHRoZSBudW1iZXJzIGFyZSByZW1hcHBlZDpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCA1ID0+IC4uLiB9XG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIGtub3cgdGhhdCB0aGUgT05MWSBncm91cHMgdGhhdCBzaG91bGQgYmUgb3V0cHV0XG4gKiBhcmUgMSwgMiwgYW5kIDUuICBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICogQHBhcmFtIHtBcnJheTxSZWdFeHAgfCBzdHJpbmc+fSByZWdleGVzXG4gKiBAcGFyYW0ge3trZXk6IFwiYmVnaW5TY29wZVwifFwiZW5kU2NvcGVcIn19IG9wdHNcbiAqL1xuZnVuY3Rpb24gcmVtYXBTY29wZU5hbWVzKG1vZGUsIHJlZ2V4ZXMsIHsga2V5IH0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHNjb3BlTmFtZXMgPSBtb2RlW2tleV07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8bnVtYmVyLGJvb2xlYW4+ICovXG4gIGNvbnN0IGVtaXQgPSB7fTtcbiAgLyoqIEB0eXBlIFJlY29yZDxudW1iZXIsc3RyaW5nPiAqL1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKyBvZmZzZXRdID0gc2NvcGVOYW1lc1tpXTtcbiAgICBlbWl0W2kgKyBvZmZzZXRdID0gdHJ1ZTtcbiAgICBvZmZzZXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZWdleGVzW2kgLSAxXSk7XG4gIH1cbiAgLy8gd2UgdXNlIF9lbWl0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWF0Y2ggZ3JvdXBzIGFyZSBcInRvcC1sZXZlbFwiIHRvIGF2b2lkIGRvdWJsZVxuICAvLyBvdXRwdXQgZnJvbSBpbnNpZGUgbWF0Y2ggZ3JvdXBzXG4gIG1vZGVba2V5XSA9IHBvc2l0aW9ucztcbiAgbW9kZVtrZXldLl9lbWl0ID0gZW1pdDtcbiAgbW9kZVtrZXldLl9tdWx0aSA9IHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gYmVnaW5NdWx0aUNsYXNzKG1vZGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGUuYmVnaW4pKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVCZWdpbiB8fCBtb2RlLnJldHVybkJlZ2luKSB7XG4gICAgZXJyb3IoXCJza2lwLCBleGNsdWRlQmVnaW4sIHJldHVybkJlZ2luIG5vdCBjb21wYXRpYmxlIHdpdGggYmVnaW5TY29wZToge31cIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlLmJlZ2luU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5iZWdpblNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJiZWdpblNjb3BlIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIHJlbWFwU2NvcGVOYW1lcyhtb2RlLCBtb2RlLmJlZ2luLCB7IGtleTogXCJiZWdpblNjb3BlXCIgfSk7XG4gIG1vZGUuYmVnaW4gPSBfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKG1vZGUuYmVnaW4sIHsgam9pbldpdGg6IFwiXCIgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gZW5kTXVsdGlDbGFzcyhtb2RlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmVuZCkpIHJldHVybjtcblxuICBpZiAobW9kZS5za2lwIHx8IG1vZGUuZXhjbHVkZUVuZCB8fCBtb2RlLnJldHVybkVuZCkge1xuICAgIGVycm9yKFwic2tpcCwgZXhjbHVkZUVuZCwgcmV0dXJuRW5kIG5vdCBjb21wYXRpYmxlIHdpdGggZW5kU2NvcGU6IHt9XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZS5lbmRTY29wZSAhPT0gXCJvYmplY3RcIiB8fCBtb2RlLmVuZFNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJlbmRTY29wZSBtdXN0IGJlIG9iamVjdFwiKTtcbiAgICB0aHJvdyBNdWx0aUNsYXNzRXJyb3I7XG4gIH1cblxuICByZW1hcFNjb3BlTmFtZXMobW9kZSwgbW9kZS5lbmQsIHsga2V5OiBcImVuZFNjb3BlXCIgfSk7XG4gIG1vZGUuZW5kID0gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhtb2RlLmVuZCwgeyBqb2luV2l0aDogXCJcIiB9KTtcbn1cblxuLyoqXG4gKiB0aGlzIGV4aXN0cyBvbmx5IHRvIGFsbG93IGBzY29wZToge31gIHRvIGJlIHVzZWQgYmVzaWRlIGBtYXRjaDpgXG4gKiBPdGhlcndpc2UgYGJlZ2luU2NvcGVgIHdvdWxkIG5lY2Vzc2FyeSBhbmQgdGhhdCB3b3VsZCBsb29rIHdlaXJkXG5cbiAge1xuICAgIG1hdGNoOiBbIC9kZWYvLCAvXFx3Ky8gXVxuICAgIHNjb3BlOiB7IDE6IFwia2V5d29yZFwiICwgMjogXCJ0aXRsZVwiIH1cbiAgfVxuXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICovXG5mdW5jdGlvbiBzY29wZVN1Z2FyKG1vZGUpIHtcbiAgaWYgKG1vZGUuc2NvcGUgJiYgdHlwZW9mIG1vZGUuc2NvcGUgPT09IFwib2JqZWN0XCIgJiYgbW9kZS5zY29wZSAhPT0gbnVsbCkge1xuICAgIG1vZGUuYmVnaW5TY29wZSA9IG1vZGUuc2NvcGU7XG4gICAgZGVsZXRlIG1vZGUuc2NvcGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICovXG5mdW5jdGlvbiBNdWx0aUNsYXNzKG1vZGUpIHtcbiAgc2NvcGVTdWdhcihtb2RlKTtcblxuICBpZiAodHlwZW9mIG1vZGUuYmVnaW5TY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1vZGUuYmVnaW5TY29wZSA9IHsgX3dyYXA6IG1vZGUuYmVnaW5TY29wZSB9O1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZS5lbmRTY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1vZGUuZW5kU2NvcGUgPSB7IF93cmFwOiBtb2RlLmVuZFNjb3BlIH07XG4gIH1cblxuICBiZWdpbk11bHRpQ2xhc3MobW9kZSk7XG4gIGVuZE11bHRpQ2xhc3MobW9kZSk7XG59XG5cbi8qKlxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRNb2RlfSBDb21waWxlZE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkxhbmd1YWdlfSBMYW5ndWFnZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU1BsdWdpbn0gSExKU1BsdWdpblxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRMYW5ndWFnZX0gQ29tcGlsZWRMYW5ndWFnZVxuKi9cblxuLy8gY29tcGlsYXRpb25cblxuLyoqXG4gKiBDb21waWxlcyBhIGxhbmd1YWdlIGRlZmluaXRpb24gcmVzdWx0XG4gKlxuICogR2l2ZW4gdGhlIHJhdyByZXN1bHQgb2YgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChMYW5ndWFnZSksIGNvbXBpbGVzIHRoaXMgc29cbiAqIHRoYXQgaXQgaXMgcmVhZHkgZm9yIGhpZ2hsaWdodGluZyBjb2RlLlxuICogQHBhcmFtIHtMYW5ndWFnZX0gbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIHtDb21waWxlZExhbmd1YWdlfVxuICovXG5mdW5jdGlvbiBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHJlZ2V4IHdpdGggdGhlIGNhc2Ugc2Vuc2l0aXZpdHkgb2YgdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbF1cbiAgICovXG4gIGZ1bmN0aW9uIGxhbmdSZSh2YWx1ZSwgZ2xvYmFsKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICBzb3VyY2UodmFsdWUpLFxuICAgICAgJ20nXG4gICAgICArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpXG4gICAgICArIChsYW5ndWFnZS51bmljb2RlUmVnZXggPyAndScgOiAnJylcbiAgICAgICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICBTdG9yZXMgbXVsdGlwbGUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgYWxsb3dzIHlvdSB0byBxdWlja2x5IHNlYXJjaCBmb3JcbiAgICB0aGVtIGFsbCBpbiBhIHN0cmluZyBzaW11bHRhbmVvdXNseSAtIHJldHVybmluZyB0aGUgZmlyc3QgbWF0Y2guICBJdCBkb2VzXG4gICAgdGhpcyBieSBjcmVhdGluZyBhIGh1Z2UgKGF8YnxjKSByZWdleCAtIGVhY2ggaW5kaXZpZHVhbCBpdGVtIHdyYXBwZWQgd2l0aCAoKVxuICAgIGFuZCBqb2luZWQgYnkgYHxgIC0gdXNpbmcgbWF0Y2ggZ3JvdXBzIHRvIHRyYWNrIHBvc2l0aW9uLiAgV2hlbiBhIG1hdGNoIGlzXG4gICAgZm91bmQgY2hlY2tpbmcgd2hpY2ggcG9zaXRpb24gaW4gdGhlIGFycmF5IGhhcyBjb250ZW50IGFsbG93cyB1cyB0byBmaWd1cmVcbiAgICBvdXQgd2hpY2ggb2YgdGhlIG9yaWdpbmFsIHJlZ2V4ZXMgLyBtYXRjaCBncm91cHMgdHJpZ2dlcmVkIHRoZSBtYXRjaC5cblxuICAgIFRoZSBtYXRjaCBvYmplY3QgaXRzZWxmICh0aGUgcmVzdWx0IG9mIGBSZWdleC5leGVjYCkgaXMgcmV0dXJuZWQgYnV0IGFsc29cbiAgICBlbmhhbmNlZCBieSBtZXJnaW5nIGluIGFueSBtZXRhLWRhdGEgdGhhdCB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSByZWdleC5cbiAgICBUaGlzIGlzIGhvdyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG1vZGUgbWF0Y2hlZCwgYW5kIHdoYXQgdHlwZSBvZiBydWxlXG4gICAgKGBpbGxlZ2FsYCwgYGJlZ2luYCwgZW5kLCBldGMpLlxuICAqL1xuICBjbGFzcyBNdWx0aVJlZ2V4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzID0ge307XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMubWF0Y2hBdCA9IDE7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgb3B0cy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24rKztcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzW3RoaXMubWF0Y2hBdF0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWdleGVzLnB1c2goW29wdHMsIHJlXSk7XG4gICAgICB0aGlzLm1hdGNoQXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZSkgKyAxO1xuICAgIH1cblxuICAgIGNvbXBpbGUoKSB7XG4gICAgICBpZiAodGhpcy5yZWdleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBhdm9pZHMgdGhlIG5lZWQgdG8gY2hlY2sgbGVuZ3RoIGV2ZXJ5IHRpbWUgZXhlYyBpcyBjYWxsZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmV4ZWMgPSAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVybWluYXRvcnMgPSB0aGlzLnJlZ2V4ZXMubWFwKGVsID0+IGVsWzFdKTtcbiAgICAgIHRoaXMubWF0Y2hlclJlID0gbGFuZ1JlKF9yZXdyaXRlQmFja3JlZmVyZW5jZXModGVybWluYXRvcnMsIHsgam9pbldpdGg6ICd8JyB9KSwgdHJ1ZSk7XG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzICovXG4gICAgZXhlYyhzKSB7XG4gICAgICB0aGlzLm1hdGNoZXJSZS5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleDtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tYXRjaGVyUmUuZXhlYyhzKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgICAgY29uc3QgaSA9IG1hdGNoLmZpbmRJbmRleCgoZWwsIGkpID0+IGkgPiAwICYmIGVsICE9PSB1bmRlZmluZWQpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgbWF0Y2hEYXRhID0gdGhpcy5tYXRjaEluZGV4ZXNbaV07XG4gICAgICAvLyB0cmltIG9mZiBhbnkgZWFybGllciBub24tcmVsZXZhbnQgbWF0Y2ggZ3JvdXBzIChpZSwgdGhlIG90aGVyIHJlZ2V4XG4gICAgICAvLyBtYXRjaCBncm91cHMgdGhhdCBtYWtlIHVwIHRoZSBtdWx0aS1tYXRjaGVyKVxuICAgICAgbWF0Y2guc3BsaWNlKDAsIGkpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtYXRjaCwgbWF0Y2hEYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgIENyZWF0ZWQgdG8gc29sdmUgdGhlIGtleSBkZWZpY2llbnRseSB3aXRoIE11bHRpUmVnZXggLSB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICB0ZXN0IGZvciBtdWx0aXBsZSBtYXRjaGVzIGF0IGEgc2luZ2xlIGxvY2F0aW9uLiAgV2h5IHdvdWxkIHdlIG5lZWQgdG8gZG9cbiAgICB0aGF0PyAgSW4gdGhlIGZ1dHVyZSBhIG1vcmUgZHluYW1pYyBlbmdpbmUgd2lsbCBhbGxvdyBjZXJ0YWluIG1hdGNoZXMgdG8gYmVcbiAgICBpZ25vcmVkLiAgQW4gZXhhbXBsZTogaWYgd2UgbWF0Y2hlZCBzYXkgdGhlIDNyZCByZWdleCBpbiBhIGxhcmdlIGdyb3VwIGJ1dFxuICAgIGRlY2lkZWQgdG8gaWdub3JlIGl0IC0gd2UnZCBuZWVkIHRvIHN0YXJ0ZWQgdGVzdGluZyBhZ2FpbiBhdCB0aGUgNHRoXG4gICAgcmVnZXguLi4gYnV0IE11bHRpUmVnZXggaXRzZWxmIGdpdmVzIHVzIG5vIHJlYWwgd2F5IHRvIGRvIHRoYXQuXG5cbiAgICBTbyB3aGF0IHRoaXMgY2xhc3MgY3JlYXRlcyBNdWx0aVJlZ2V4cyBvbiB0aGUgZmx5IGZvciB3aGF0ZXZlciBzZWFyY2hcbiAgICBwb3NpdGlvbiB0aGV5IGFyZSBuZWVkZWQuXG5cbiAgICBOT1RFOiBUaGVzZSBhZGRpdGlvbmFsIE11bHRpUmVnZXggb2JqZWN0cyBhcmUgY3JlYXRlZCBkeW5hbWljYWxseS4gIEZvciBtb3N0XG4gICAgZ3JhbW1hcnMgbW9zdCBvZiB0aGUgdGltZSB3ZSB3aWxsIG5ldmVyIGFjdHVhbGx5IG5lZWQgYW55dGhpbmcgbW9yZSB0aGFuIHRoZVxuICAgIGZpcnN0IE11bHRpUmVnZXggLSBzbyB0aGlzIHNob3VsZG4ndCBoYXZlIHRvbyBtdWNoIG92ZXJoZWFkLlxuXG4gICAgU2F5IHRoaXMgaXMgb3VyIHNlYXJjaCBncm91cCwgYW5kIHdlIG1hdGNoIHJlZ2V4MywgYnV0IHdpc2ggdG8gaWdub3JlIGl0LlxuXG4gICAgICByZWdleDEgfCByZWdleDIgfCByZWdleDMgfCByZWdleDQgfCByZWdleDUgICAgJyBpZSwgc3RhcnRBdCA9IDBcblxuICAgIFdoYXQgd2UgbmVlZCBpcyBhIG5ldyBNdWx0aVJlZ2V4IHRoYXQgb25seSBpbmNsdWRlcyB0aGUgcmVtYWluaW5nXG4gICAgcG9zc2liaWxpdGllczpcblxuICAgICAgcmVnZXg0IHwgcmVnZXg1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaWUsIHN0YXJ0QXQgPSAzXG5cbiAgICBUaGlzIGNsYXNzIHdyYXBzIGFsbCB0aGF0IGNvbXBsZXhpdHkgdXAgaW4gYSBzaW1wbGUgQVBJLi4uIGBzdGFydEF0YCBkZWNpZGVzXG4gICAgd2hlcmUgaW4gdGhlIGFycmF5IG9mIGV4cHJlc3Npb25zIHRvIHN0YXJ0IGRvaW5nIHRoZSBtYXRjaGluZy4gSXRcbiAgICBhdXRvLWluY3JlbWVudHMsIHNvIGlmIGEgbWF0Y2ggaXMgZm91bmQgYXQgcG9zaXRpb24gMiwgdGhlbiBzdGFydEF0IHdpbGwgYmVcbiAgICBzZXQgdG8gMy4gIElmIHRoZSBlbmQgaXMgcmVhY2hlZCBzdGFydEF0IHdpbGwgcmV0dXJuIHRvIDAuXG5cbiAgICBNT1NUIG9mIHRoZSB0aW1lIHRoZSBwYXJzZXIgd2lsbCBiZSBzZXR0aW5nIHN0YXJ0QXQgbWFudWFsbHkgdG8gMC5cbiAgKi9cbiAgY2xhc3MgUmVzdW1hYmxlTXVsdGlSZWdleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm11bHRpUmVnZXhlcyA9IFtdO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVnZXhJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdldE1hdGNoZXIoaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpUmVnZXhlc1tpbmRleF0pIHJldHVybiB0aGlzLm11bHRpUmVnZXhlc1tpbmRleF07XG5cbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBuZXcgTXVsdGlSZWdleCgpO1xuICAgICAgdGhpcy5ydWxlcy5zbGljZShpbmRleCkuZm9yRWFjaCgoW3JlLCBvcHRzXSkgPT4gbWF0Y2hlci5hZGRSdWxlKHJlLCBvcHRzKSk7XG4gICAgICBtYXRjaGVyLmNvbXBpbGUoKTtcbiAgICAgIHRoaXMubXVsdGlSZWdleGVzW2luZGV4XSA9IG1hdGNoZXI7XG4gICAgICByZXR1cm4gbWF0Y2hlcjtcbiAgICB9XG5cbiAgICByZXN1bWluZ1NjYW5BdFNhbWVQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2V4SW5kZXggIT09IDA7XG4gICAgfVxuXG4gICAgY29uc2lkZXJBbGwoKSB7XG4gICAgICB0aGlzLnJlZ2V4SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhZGRSdWxlKHJlLCBvcHRzKSB7XG4gICAgICB0aGlzLnJ1bGVzLnB1c2goW3JlLCBvcHRzXSk7XG4gICAgICBpZiAob3B0cy50eXBlID09PSBcImJlZ2luXCIpIHRoaXMuY291bnQrKztcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHMgKi9cbiAgICBleGVjKHMpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLmdldE1hdGNoZXIodGhpcy5yZWdleEluZGV4KTtcbiAgICAgIG0ubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgICBsZXQgcmVzdWx0ID0gbS5leGVjKHMpO1xuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGJlY2F1c2Ugd2UgaGF2ZSBubyBlYXN5IHdheSB0byBzYXkgXCJyZXN1bWUgc2Nhbm5pbmcgYXQgdGhlXG4gICAgICAvLyBleGlzdGluZyBwb3NpdGlvbiBidXQgYWxzbyBza2lwIHRoZSBjdXJyZW50IHJ1bGUgT05MWVwiLiBXaGF0IGhhcHBlbnMgaXNcbiAgICAgIC8vIGFsbCBwcmlvciBydWxlcyBhcmUgYWxzbyBza2lwcGVkIHdoaWNoIGNhbiByZXN1bHQgaW4gbWF0Y2hpbmcgdGhlIHdyb25nXG4gICAgICAvLyB0aGluZy4gRXhhbXBsZSBvZiBtYXRjaGluZyBcImJvb2dlclwiOlxuXG4gICAgICAvLyBvdXIgbWF0Y2hlciBpcyBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvL1xuICAgICAgLy8gLi4uLmJvb2dlci4uLi5cblxuICAgICAgLy8gaWYgXCJib29nZXJcIiBpcyBpZ25vcmVkIHRoZW4gd2UnZCByZWFsbHkgbmVlZCBhIHJlZ2V4IHRvIHNjYW4gZnJvbSB0aGVcbiAgICAgIC8vIFNBTUUgcG9zaXRpb24gZm9yIG9ubHk6IFtzdHJpbmcsIG51bWJlcl0gYnV0IGlnbm9yaW5nIFwiYm9vZ2VyXCIgKGlmIGl0XG4gICAgICAvLyB3YXMgdGhlIGZpcnN0IG1hdGNoKSwgYSBzaW1wbGUgcmVzdW1lIHdvdWxkIHNjYW4gYWhlYWQgd2hvIGtub3dzIGhvd1xuICAgICAgLy8gZmFyIGxvb2tpbmcgb25seSBmb3IgXCJudW1iZXJcIiwgaWdub3JpbmcgcG90ZW50aWFsIHN0cmluZyBtYXRjaGVzIChvclxuICAgICAgLy8gZnV0dXJlIFwiYm9vZ2VyXCIgbWF0Y2hlcyB0aGF0IG1pZ2h0IGJlIHZhbGlkLilcblxuICAgICAgLy8gU28gd2hhdCB3ZSBkbzogV2UgZXhlY3V0ZSB0d28gbWF0Y2hlcnMsIG9uZSByZXN1bWluZyBhdCB0aGUgc2FtZVxuICAgICAgLy8gcG9zaXRpb24sIGJ1dCB0aGUgc2Vjb25kIGZ1bGwgbWF0Y2hlciBzdGFydGluZyBhdCB0aGUgcG9zaXRpb24gYWZ0ZXI6XG5cbiAgICAgIC8vICAgICAvLS0tIHJlc3VtZSBmaXJzdCByZWdleCBtYXRjaCBoZXJlIChmb3IgW251bWJlcl0pXG4gICAgICAvLyAgICAgfC8tLS0tIGZ1bGwgbWF0Y2ggaGVyZSBmb3IgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy8gICAgIHZ2XG4gICAgICAvLyAuLi4uYm9vZ2VyLi4uLlxuXG4gICAgICAvLyBXaGljaCBldmVyIHJlc3VsdHMgaW4gYSBtYXRjaCBmaXJzdCBpcyB0aGVuIHVzZWQuIFNvIHRoaXMgMy00IHN0ZXBcbiAgICAgIC8vIHByb2Nlc3MgZXNzZW50aWFsbHkgYWxsb3dzIHVzIHRvIHNheSBcIm1hdGNoIGF0IHRoaXMgcG9zaXRpb24sIGV4Y2x1ZGluZ1xuICAgICAgLy8gYSBwcmlvciBydWxlIHRoYXQgd2FzIGlnbm9yZWRcIi5cbiAgICAgIC8vXG4gICAgICAvLyAxLiBNYXRjaCBcImJvb2dlclwiIGZpcnN0LCBpZ25vcmUuIEFsc28gcHJvdmVzIHRoYXQgW3N0cmluZ10gZG9lcyBub24gbWF0Y2guXG4gICAgICAvLyAyLiBSZXN1bWUgbWF0Y2hpbmcgZm9yIFtudW1iZXJdXG4gICAgICAvLyAzLiBNYXRjaCBhdCBpbmRleCArIDEgZm9yIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vIDQuIElmICMyIGFuZCAjMyByZXN1bHQgaW4gbWF0Y2hlcywgd2hpY2ggY2FtZSBmaXJzdD9cbiAgICAgIGlmICh0aGlzLnJlc3VtaW5nU2NhbkF0U2FtZVBvc2l0aW9uKCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaW5kZXggPT09IHRoaXMubGFzdEluZGV4KSA7IGVsc2UgeyAvLyB1c2UgdGhlIHNlY29uZCBtYXRjaGVyIHJlc3VsdFxuICAgICAgICAgIGNvbnN0IG0yID0gdGhpcy5nZXRNYXRjaGVyKDApO1xuICAgICAgICAgIG0yLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4ICsgMTtcbiAgICAgICAgICByZXN1bHQgPSBtMi5leGVjKHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5yZWdleEluZGV4ICs9IHJlc3VsdC5wb3NpdGlvbiArIDE7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4SW5kZXggPT09IHRoaXMuY291bnQpIHtcbiAgICAgICAgICAvLyB3cmFwLWFyb3VuZCB0byBjb25zaWRlcmluZyBhbGwgbWF0Y2hlcyBhZ2FpblxuICAgICAgICAgIHRoaXMuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG1vZGUsIGJ1aWxkcyBhIGh1Z2UgUmVzdW1hYmxlTXVsdGlSZWdleCB0aGF0IGNhbiBiZSB1c2VkIHRvIHdhbGtcbiAgICogdGhlIGNvbnRlbnQgYW5kIGZpbmQgbWF0Y2hlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAgICogQHJldHVybnMge1Jlc3VtYWJsZU11bHRpUmVnZXh9XG4gICAqL1xuICBmdW5jdGlvbiBidWlsZE1vZGVSZWdleChtb2RlKSB7XG4gICAgY29uc3QgbW0gPSBuZXcgUmVzdW1hYmxlTXVsdGlSZWdleCgpO1xuXG4gICAgbW9kZS5jb250YWlucy5mb3JFYWNoKHRlcm0gPT4gbW0uYWRkUnVsZSh0ZXJtLmJlZ2luLCB7IHJ1bGU6IHRlcm0sIHR5cGU6IFwiYmVnaW5cIiB9KSk7XG5cbiAgICBpZiAobW9kZS50ZXJtaW5hdG9yRW5kKSB7XG4gICAgICBtbS5hZGRSdWxlKG1vZGUudGVybWluYXRvckVuZCwgeyB0eXBlOiBcImVuZFwiIH0pO1xuICAgIH1cbiAgICBpZiAobW9kZS5pbGxlZ2FsKSB7XG4gICAgICBtbS5hZGRSdWxlKG1vZGUuaWxsZWdhbCwgeyB0eXBlOiBcImlsbGVnYWxcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW07XG4gIH1cblxuICAvKiogc2tpcCB2cyBhYm9ydCB2cyBpZ25vcmVcbiAgICpcbiAgICogQHNraXAgICAtIFRoZSBtb2RlIGlzIHN0aWxsIGVudGVyZWQgYW5kIGV4aXRlZCBub3JtYWxseSAoYW5kIGNvbnRhaW5zIHJ1bGVzIGFwcGx5KSxcbiAgICogICAgICAgICAgIGJ1dCBhbGwgY29udGVudCBpcyBoZWxkIGFuZCBhZGRlZCB0byB0aGUgcGFyZW50IGJ1ZmZlciByYXRoZXIgdGhhbiBiZWluZ1xuICAgKiAgICAgICAgICAgb3V0cHV0IHdoZW4gdGhlIG1vZGUgZW5kcy4gIE1vc3RseSB1c2VkIHdpdGggYHN1Ymxhbmd1YWdlYCB0byBidWlsZCB1cFxuICAgKiAgICAgICAgICAgYSBzaW5nbGUgbGFyZ2UgYnVmZmVyIHRoYW4gY2FuIGJlIHBhcnNlZCBieSBzdWJsYW5ndWFnZS5cbiAgICpcbiAgICogICAgICAgICAgICAgLSBUaGUgbW9kZSBiZWdpbiBhbmRzIGVuZHMgbm9ybWFsbHkuXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQgbW9kZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgIC0gVGhlIHBhcnNlciBjdXJzb3IgaXMgbW92ZWQgZm9yd2FyZCBub3JtYWxseS5cbiAgICpcbiAgICogQGFib3J0ICAtIEEgaGFjayBwbGFjZWhvbGRlciB1bnRpbCB3ZSBoYXZlIGlnbm9yZS4gIEFib3J0cyB0aGUgbW9kZSAoYXMgaWYgaXRcbiAgICogICAgICAgICAgIG5ldmVyIG1hdGNoZWQpIGJ1dCBET0VTIE5PVCBjb250aW51ZSB0byBtYXRjaCBzdWJzZXF1ZW50IGBjb250YWluc2BcbiAgICogICAgICAgICAgIG1vZGVzLiAgQWJvcnQgaXMgYmFkL3N1Ym9wdGltYWwgYmVjYXVzZSBpdCBjYW4gcmVzdWx0IGluIG1vZGVzXG4gICAqICAgICAgICAgICBmYXJ0aGVyIGRvd24gbm90IGdldHRpbmcgYXBwbGllZCBiZWNhdXNlIGFuIGVhcmxpZXIgcnVsZSBlYXRzIHRoZVxuICAgKiAgICAgICAgICAgY29udGVudCBidXQgdGhlbiBhYm9ydHMuXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgZG9lcyBub3QgYmVnaW4uXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGJ5IGBiZWdpbmAgaXMgYWRkZWQgdG8gdGhlIG1vZGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG1vdmVkIGZvcndhcmQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBpZ25vcmUgLSBJZ25vcmVzIHRoZSBtb2RlIChhcyBpZiBpdCBuZXZlciBtYXRjaGVkKSBhbmQgY29udGludWVzIHRvIG1hdGNoIGFueVxuICAgKiAgICAgICAgICAgc3Vic2VxdWVudCBgY29udGFpbnNgIG1vZGVzLiAgSWdub3JlIGlzbid0IHRlY2huaWNhbGx5IHBvc3NpYmxlIHdpdGhcbiAgICogICAgICAgICAgIHRoZSBjdXJyZW50IHBhcnNlciBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogICAgICAgICAgICAgLSBUaGUgbW9kZSBkb2VzIG5vdCBiZWdpbi5cbiAgICogICAgICAgICAgICAgLSBDb250ZW50IG1hdGNoZWQgYnkgYGJlZ2luYCBpcyBpZ25vcmVkLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG5vdCBtb3ZlZCBmb3J3YXJkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBtb2RlXG4gICAqXG4gICAqIFRoaXMgY2FuIHJhaXNlIGFuIGVycm9yIGlmIHRoZSBtb2RlIGNvbnRhaW5zIGNlcnRhaW4gZGV0ZWN0YWJsZSBrbm93biBsb2dpY1xuICAgKiBpc3N1ZXMuXG4gICAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZSB8IG51bGx9IFtwYXJlbnRdXG4gICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCBuZXZlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVNb2RlKG1vZGUsIHBhcmVudCkge1xuICAgIGNvbnN0IGNtb2RlID0gLyoqIEB0eXBlIENvbXBpbGVkTW9kZSAqLyAobW9kZSk7XG4gICAgaWYgKG1vZGUuaXNDb21waWxlZCkgcmV0dXJuIGNtb2RlO1xuXG4gICAgW1xuICAgICAgc2NvcGVDbGFzc05hbWUsXG4gICAgICAvLyBkbyB0aGlzIGVhcmx5IHNvIGNvbXBpbGVyIGV4dGVuc2lvbnMgZ2VuZXJhbGx5IGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXRcbiAgICAgIC8vIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIG1hdGNoL2JlZ2luXG4gICAgICBjb21waWxlTWF0Y2gsXG4gICAgICBNdWx0aUNsYXNzLFxuICAgICAgYmVmb3JlTWF0Y2hFeHRcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIGxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICAvLyBfX2JlZm9yZUJlZ2luIGlzIGNvbnNpZGVyZWQgcHJpdmF0ZSBBUEksIGludGVybmFsIHVzZSBvbmx5XG4gICAgbW9kZS5fX2JlZm9yZUJlZ2luID0gbnVsbDtcblxuICAgIFtcbiAgICAgIGJlZ2luS2V5d29yZHMsXG4gICAgICAvLyBkbyB0aGlzIGxhdGVyIHNvIGNvbXBpbGVyIGV4dGVuc2lvbnMgdGhhdCBjb21lIGVhcmxpZXIgaGF2ZSBhY2Nlc3MgdG8gdGhlXG4gICAgICAvLyByYXcgYXJyYXkgaWYgdGhleSB3YW50ZWQgdG8gcGVyaGFwcyBtYW5pcHVsYXRlIGl0LCBldGMuXG4gICAgICBjb21waWxlSWxsZWdhbCxcbiAgICAgIC8vIGRlZmF1bHQgdG8gMSByZWxldmFuY2UgaWYgbm90IHNwZWNpZmllZFxuICAgICAgY29tcGlsZVJlbGV2YW5jZVxuICAgIF0uZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgbW9kZS5pc0NvbXBpbGVkID0gdHJ1ZTtcblxuICAgIGxldCBrZXl3b3JkUGF0dGVybiA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBtb2RlLmtleXdvcmRzID09PSBcIm9iamVjdFwiICYmIG1vZGUua2V5d29yZHMuJHBhdHRlcm4pIHtcbiAgICAgIC8vIHdlIG5lZWQgYSBjb3B5IGJlY2F1c2Uga2V5d29yZHMgbWlnaHQgYmUgY29tcGlsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgIC8vIHNvIHdlIGNhbid0IGdvIGRlbGV0aW5nICRwYXR0ZXJuIGZyb20gdGhlIG9yaWdpbmFsIG9uIHRoZSBmaXJzdFxuICAgICAgLy8gcGFzc1xuICAgICAgbW9kZS5rZXl3b3JkcyA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGUua2V5d29yZHMpO1xuICAgICAga2V5d29yZFBhdHRlcm4gPSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgICAgZGVsZXRlIG1vZGUua2V5d29yZHMuJHBhdHRlcm47XG4gICAgfVxuICAgIGtleXdvcmRQYXR0ZXJuID0ga2V5d29yZFBhdHRlcm4gfHwgL1xcdysvO1xuXG4gICAgaWYgKG1vZGUua2V5d29yZHMpIHtcbiAgICAgIG1vZGUua2V5d29yZHMgPSBjb21waWxlS2V5d29yZHMobW9kZS5rZXl3b3JkcywgbGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSk7XG4gICAgfVxuXG4gICAgY21vZGUua2V5d29yZFBhdHRlcm5SZSA9IGxhbmdSZShrZXl3b3JkUGF0dGVybiwgdHJ1ZSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoIW1vZGUuYmVnaW4pIG1vZGUuYmVnaW4gPSAvXFxCfFxcYi87XG4gICAgICBjbW9kZS5iZWdpblJlID0gbGFuZ1JlKGNtb2RlLmJlZ2luKTtcbiAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgaWYgKG1vZGUuZW5kKSBjbW9kZS5lbmRSZSA9IGxhbmdSZShjbW9kZS5lbmQpO1xuICAgICAgY21vZGUudGVybWluYXRvckVuZCA9IHNvdXJjZShjbW9kZS5lbmQpIHx8ICcnO1xuICAgICAgaWYgKG1vZGUuZW5kc1dpdGhQYXJlbnQgJiYgcGFyZW50LnRlcm1pbmF0b3JFbmQpIHtcbiAgICAgICAgY21vZGUudGVybWluYXRvckVuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvckVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkgY21vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKC8qKiBAdHlwZSB7UmVnRXhwIHwgc3RyaW5nfSAqLyAobW9kZS5pbGxlZ2FsKSk7XG4gICAgaWYgKCFtb2RlLmNvbnRhaW5zKSBtb2RlLmNvbnRhaW5zID0gW107XG5cbiAgICBtb2RlLmNvbnRhaW5zID0gW10uY29uY2F0KC4uLm1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBleHBhbmRPckNsb25lTW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYyk7XG4gICAgfSkpO1xuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7IGNvbXBpbGVNb2RlKC8qKiBAdHlwZSBNb2RlICovIChjKSwgY21vZGUpOyB9KTtcblxuICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgY21vZGUubWF0Y2hlciA9IGJ1aWxkTW9kZVJlZ2V4KGNtb2RlKTtcbiAgICByZXR1cm4gY21vZGU7XG4gIH1cblxuICBpZiAoIWxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucykgbGFuZ3VhZ2UuY29tcGlsZXJFeHRlbnNpb25zID0gW107XG5cbiAgLy8gc2VsZiBpcyBub3QgdmFsaWQgYXQgdGhlIHRvcC1sZXZlbFxuICBpZiAobGFuZ3VhZ2UuY29udGFpbnMgJiYgbGFuZ3VhZ2UuY29udGFpbnMuaW5jbHVkZXMoJ3NlbGYnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVSUjogY29udGFpbnMgYHNlbGZgIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIGxhbmd1YWdlLiAgU2VlIGRvY3VtZW50YXRpb24uXCIpO1xuICB9XG5cbiAgLy8gd2UgbmVlZCBhIG51bGwgb2JqZWN0LCB3aGljaCBpbmhlcml0IHdpbGwgZ3VhcmFudGVlXG4gIGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgPSBpbmhlcml0JDEobGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlcyB8fCB7fSk7XG5cbiAgcmV0dXJuIGNvbXBpbGVNb2RlKC8qKiBAdHlwZSBNb2RlICovIChsYW5ndWFnZSkpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBtb2RlIGhhcyBhIGRlcGVuZGVuY3kgb24gaXQncyBwYXJlbnQgb3Igbm90XG4gKlxuICogSWYgYSBtb2RlIGRvZXMgaGF2ZSBhIHBhcmVudCBkZXBlbmRlbmN5IHRoZW4gb2Z0ZW4gd2UgbmVlZCB0byBjbG9uZSBpdCBpZlxuICogaXQncyB1c2VkIGluIG11bHRpcGxlIHBsYWNlcyBzbyB0aGF0IGVhY2ggY29weSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgcGFyZW50LFxuICogd2hlcmUtYXMgbW9kZXMgd2l0aG91dCBhIHBhcmVudCBjYW4gb2Z0ZW4gc2FmZWx5IGJlIHJlLXVzZWQgYXQgdGhlIGJvdHRvbSBvZlxuICogYSBtb2RlIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7TW9kZSB8IG51bGx9IG1vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIGlzIHRoZXJlIGEgZGVwZW5kZW5jeSBvbiB0aGUgcGFyZW50P1xuICogKi9cbmZ1bmN0aW9uIGRlcGVuZGVuY3lPblBhcmVudChtb2RlKSB7XG4gIGlmICghbW9kZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBtb2RlLmVuZHNXaXRoUGFyZW50IHx8IGRlcGVuZGVuY3lPblBhcmVudChtb2RlLnN0YXJ0cyk7XG59XG5cbi8qKlxuICogRXhwYW5kcyBhIG1vZGUgb3IgY2xvbmVzIGl0IGlmIG5lY2Vzc2FyeVxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBtb2RlcyB3aXRoIHBhcmVudGFsIGRlcGVuZGVuY2VpcyAoc2VlIG5vdGVzIG9uXG4gKiBgZGVwZW5kZW5jeU9uUGFyZW50YCkgYW5kIGZvciBub2RlcyB0aGF0IGhhdmUgYHZhcmlhbnRzYCAtIHdoaWNoIG11c3QgdGhlbiBiZVxuICogZXhwbG9kZWQgaW50byB0aGVpciBvd24gaW5kaXZpZHVhbCBtb2RlcyBhdCBjb21waWxlIHRpbWUuXG4gKlxuICogQHBhcmFtIHtNb2RlfSBtb2RlXG4gKiBAcmV0dXJucyB7TW9kZSB8IE1vZGVbXX1cbiAqICovXG5mdW5jdGlvbiBleHBhbmRPckNsb25lTW9kZShtb2RlKSB7XG4gIGlmIChtb2RlLnZhcmlhbnRzICYmICFtb2RlLmNhY2hlZFZhcmlhbnRzKSB7XG4gICAgbW9kZS5jYWNoZWRWYXJpYW50cyA9IG1vZGUudmFyaWFudHMubWFwKGZ1bmN0aW9uKHZhcmlhbnQpIHtcbiAgICAgIHJldHVybiBpbmhlcml0JDEobW9kZSwgeyB2YXJpYW50czogbnVsbCB9LCB2YXJpYW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEVYUEFORFxuICAvLyBpZiB3ZSBoYXZlIHZhcmlhbnRzIHRoZW4gZXNzZW50aWFsbHkgXCJyZXBsYWNlXCIgdGhlIG1vZGUgd2l0aCB0aGUgdmFyaWFudHNcbiAgLy8gdGhpcyBoYXBwZW5zIGluIGNvbXBpbGVNb2RlLCB3aGVyZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tXG4gIGlmIChtb2RlLmNhY2hlZFZhcmlhbnRzKSB7XG4gICAgcmV0dXJuIG1vZGUuY2FjaGVkVmFyaWFudHM7XG4gIH1cblxuICAvLyBDTE9ORVxuICAvLyBpZiB3ZSBoYXZlIGRlcGVuZGVuY2llcyBvbiBwYXJlbnRzIHRoZW4gd2UgbmVlZCBhIHVuaXF1ZVxuICAvLyBpbnN0YW5jZSBvZiBvdXJzZWx2ZXMsIHNvIHdlIGNhbiBiZSByZXVzZWQgd2l0aCBtYW55XG4gIC8vIGRpZmZlcmVudCBwYXJlbnRzIHdpdGhvdXQgaXNzdWVcbiAgaWYgKGRlcGVuZGVuY3lPblBhcmVudChtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0JDEobW9kZSwgeyBzdGFydHM6IG1vZGUuc3RhcnRzID8gaW5oZXJpdCQxKG1vZGUuc3RhcnRzKSA6IG51bGwgfSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmlzRnJvemVuKG1vZGUpKSB7XG4gICAgcmV0dXJuIGluaGVyaXQkMShtb2RlKTtcbiAgfVxuXG4gIC8vIG5vIHNwZWNpYWwgZGVwZW5kZW5jeSBpc3N1ZXMsIGp1c3QgcmV0dXJuIG91cnNlbHZlc1xuICByZXR1cm4gbW9kZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjExLjUuMFwiO1xuXG5jbGFzcyBIVE1MSW5qZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgaHRtbCkge1xuICAgIHN1cGVyKHJlYXNvbik7XG4gICAgdGhpcy5uYW1lID0gXCJIVE1MSW5qZWN0aW9uRXJyb3JcIjtcbiAgICB0aGlzLmh0bWwgPSBodG1sO1xuICB9XG59XG5cbi8qXG5TeW50YXggaGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgYXV0b2RldGVjdGlvbi5cbmh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuKi9cblxuLyoqXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Nb2RlfSBNb2RlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Db21waWxlZE1vZGV9IENvbXBpbGVkTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRTY29wZX0gQ29tcGlsZWRTY29wZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTGFuZ3VhZ2V9IExhbmd1YWdlXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTQXBpfSBITEpTQXBpXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTUGx1Z2lufSBITEpTUGx1Z2luXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5QbHVnaW5FdmVudH0gUGx1Z2luRXZlbnRcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhMSlNPcHRpb25zfSBITEpTT3B0aW9uc1xuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTGFuZ3VhZ2VGbn0gTGFuZ3VhZ2VGblxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSGlnaGxpZ2h0ZWRIVE1MRWxlbWVudH0gSGlnaGxpZ2h0ZWRIVE1MRWxlbWVudFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQmVmb3JlSGlnaGxpZ2h0Q29udGV4dH0gQmVmb3JlSGlnaGxpZ2h0Q29udGV4dFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5NYXRjaFR5cGV9IE1hdGNoVHlwZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5LZXl3b3JkRGF0YX0gS2V5d29yZERhdGFcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcy9wcml2YXRlJykuRW5oYW5jZWRNYXRjaH0gRW5oYW5jZWRNYXRjaFxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzL3ByaXZhdGUnKS5Bbm5vdGF0ZWRFcnJvcn0gQW5ub3RhdGVkRXJyb3JcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkF1dG9IaWdobGlnaHRSZXN1bHR9IEF1dG9IaWdobGlnaHRSZXN1bHRcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhpZ2hsaWdodE9wdGlvbnN9IEhpZ2hsaWdodE9wdGlvbnNcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhpZ2hsaWdodFJlc3VsdH0gSGlnaGxpZ2h0UmVzdWx0XG4qL1xuXG5cbmNvbnN0IGVzY2FwZSA9IGVzY2FwZUhUTUw7XG5jb25zdCBpbmhlcml0ID0gaW5oZXJpdCQxO1xuY29uc3QgTk9fTUFUQ0ggPSBTeW1ib2woXCJub21hdGNoXCIpO1xuY29uc3QgTUFYX0tFWVdPUkRfSElUUyA9IDc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGhsanMgLSBvYmplY3QgdGhhdCBpcyBleHRlbmRlZCAobGVnYWN5KVxuICogQHJldHVybnMge0hMSlNBcGl9XG4gKi9cbmNvbnN0IEhMSlMgPSBmdW5jdGlvbihobGpzKSB7XG4gIC8vIEdsb2JhbCBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCB3aXRoaW4gdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIExhbmd1YWdlPn0gKi9cbiAgY29uc3QgbGFuZ3VhZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICBjb25zdCBhbGlhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLyoqIEB0eXBlIHtITEpTUGx1Z2luW119ICovXG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcblxuICAvLyBzYWZlL3Byb2R1Y3Rpb24gbW9kZSAtIHN3YWxsb3dzIG1vcmUgZXJyb3JzLCB0cmllcyB0byBrZWVwIHJ1bm5pbmdcbiAgLy8gZXZlbiBpZiBhIHNpbmdsZSBzeW50YXggb3IgcGFyc2UgaGl0cyBhIGZhdGFsIGVycm9yXG4gIGxldCBTQUZFX01PREUgPSB0cnVlO1xuICBjb25zdCBMQU5HVUFHRV9OT1RfRk9VTkQgPSBcIkNvdWxkIG5vdCBmaW5kIHRoZSBsYW5ndWFnZSAne30nLCBkaWQgeW91IGZvcmdldCB0byBsb2FkL2luY2x1ZGUgYSBsYW5ndWFnZSBtb2R1bGU/XCI7XG4gIC8qKiBAdHlwZSB7TGFuZ3VhZ2V9ICovXG4gIGNvbnN0IFBMQUlOVEVYVF9MQU5HVUFHRSA9IHsgZGlzYWJsZUF1dG9kZXRlY3Q6IHRydWUsIG5hbWU6ICdQbGFpbiB0ZXh0JywgY29udGFpbnM6IFtdIH07XG5cbiAgLy8gR2xvYmFsIG9wdGlvbnMgdXNlZCB3aGVuIHdpdGhpbiBleHRlcm5hbCBBUElzLiBUaGlzIGlzIG1vZGlmaWVkIHdoZW5cbiAgLy8gY2FsbGluZyB0aGUgYGhsanMuY29uZmlndXJlYCBmdW5jdGlvbi5cbiAgLyoqIEB0eXBlIEhMSlNPcHRpb25zICovXG4gIGxldCBvcHRpb25zID0ge1xuICAgIGlnbm9yZVVuZXNjYXBlZEhUTUw6IGZhbHNlLFxuICAgIHRocm93VW5lc2NhcGVkSFRNTDogZmFsc2UsXG4gICAgbm9IaWdobGlnaHRSZTogL14obm8tP2hpZ2hsaWdodCkkL2ksXG4gICAgbGFuZ3VhZ2VEZXRlY3RSZTogL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgY3NzU2VsZWN0b3I6ICdwcmUgY29kZScsXG4gICAgbGFuZ3VhZ2VzOiBudWxsLFxuICAgIC8vIGJldGEgY29uZmlndXJhdGlvbiBvcHRpb25zLCBzdWJqZWN0IHRvIGNoYW5nZSwgd2VsY29tZSB0byBkaXNjdXNzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMTA4NlxuICAgIF9fZW1pdHRlcjogVG9rZW5UcmVlRW1pdHRlclxuICB9O1xuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgLyoqXG4gICAqIFRlc3RzIGEgbGFuZ3VhZ2UgbmFtZSB0byBzZWUgaWYgaGlnaGxpZ2h0aW5nIHNob3VsZCBiZSBza2lwcGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZE5vdEhpZ2hsaWdodChsYW5ndWFnZU5hbWUpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2VOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGJsb2NrIC0gdGhlIEhUTUwgZWxlbWVudCB0byBkZXRlcm1pbmUgbGFuZ3VhZ2UgZm9yXG4gICAqL1xuICBmdW5jdGlvbiBibG9ja0xhbmd1YWdlKGJsb2NrKSB7XG4gICAgbGV0IGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIGNvbnN0IG1hdGNoID0gb3B0aW9ucy5sYW5ndWFnZURldGVjdFJlLmV4ZWMoY2xhc3Nlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG1hdGNoWzFdKTtcbiAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgd2FybihMQU5HVUFHRV9OT1RfRk9VTkQucmVwbGFjZShcInt9XCIsIG1hdGNoWzFdKSk7XG4gICAgICAgIHdhcm4oXCJGYWxsaW5nIGJhY2sgdG8gbm8taGlnaGxpZ2h0IG1vZGUgZm9yIHRoaXMgYmxvY2suXCIsIGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5ndWFnZSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXNcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAuZmluZCgoX2NsYXNzKSA9PiBzaG91bGROb3RIaWdobGlnaHQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi5cbiAgICpcbiAgICogT0xEIEFQSVxuICAgKiBoaWdobGlnaHQobGFuZywgY29kZSwgaWdub3JlSWxsZWdhbHMsIGNvbnRpbnVhdGlvbilcbiAgICpcbiAgICogTkVXIEFQSVxuICAgKiBoaWdobGlnaHQoY29kZSwge2xhbmcsIGlnbm9yZUlsbGVnYWxzfSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVPckxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhpZ2hsaWdodE9wdGlvbnN9IG9wdGlvbnNPckNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICpcbiAgICogQHJldHVybnMge0hpZ2hsaWdodFJlc3VsdH0gUmVzdWx0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYW5ndWFnZSAtIHRoZSBsYW5ndWFnZSBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWxldmFuY2UgLSB0aGUgcmVsZXZhbmNlIHNjb3JlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBoaWdobGlnaHRlZCBIVE1MIGNvZGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgLSB0aGUgb3JpZ2luYWwgcmF3IGNvZGVcbiAgICogQHByb3BlcnR5IHtDb21waWxlZE1vZGV9IHRvcCAtIHRvcCBvZiB0aGUgY3VycmVudCBtb2RlIHN0YWNrXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWxsZWdhbCAtIGluZGljYXRlcyB3aGV0aGVyIGFueSBpbGxlZ2FsIG1hdGNoZXMgd2VyZSBmb3VuZFxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQoY29kZU9yTGFuZ3VhZ2VOYW1lLCBvcHRpb25zT3JDb2RlLCBpZ25vcmVJbGxlZ2Fscykge1xuICAgIGxldCBjb2RlID0gXCJcIjtcbiAgICBsZXQgbGFuZ3VhZ2VOYW1lID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNvZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvZGUgPSBjb2RlT3JMYW5ndWFnZU5hbWU7XG4gICAgICBpZ25vcmVJbGxlZ2FscyA9IG9wdGlvbnNPckNvZGUuaWdub3JlSWxsZWdhbHM7XG4gICAgICBsYW5ndWFnZU5hbWUgPSBvcHRpb25zT3JDb2RlLmxhbmd1YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbGQgQVBJXG4gICAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0KGxhbmcsIGNvZGUsIC4uLmFyZ3MpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIpO1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcIlBsZWFzZSB1c2UgaGlnaGxpZ2h0KGNvZGUsIG9wdGlvbnMpIGluc3RlYWQuXFxuaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjI3N1wiKTtcbiAgICAgIGxhbmd1YWdlTmFtZSA9IGNvZGVPckxhbmd1YWdlTmFtZTtcbiAgICAgIGNvZGUgPSBvcHRpb25zT3JDb2RlO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMxNDlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgaWYgKGlnbm9yZUlsbGVnYWxzID09PSB1bmRlZmluZWQpIHsgaWdub3JlSWxsZWdhbHMgPSB0cnVlOyB9XG5cbiAgICAvKiogQHR5cGUge0JlZm9yZUhpZ2hsaWdodENvbnRleHR9ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvZGUsXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lXG4gICAgfTtcbiAgICAvLyB0aGUgcGx1Z2luIGNhbiBjaGFuZ2UgdGhlIGRlc2lyZWQgbGFuZ3VhZ2Ugb3IgdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWRcbiAgICAvLyBqdXN0IGJlIGNoYW5naW5nIHRoZSBvYmplY3QgaXQgd2FzIHBhc3NlZFxuICAgIGZpcmUoXCJiZWZvcmU6aGlnaGxpZ2h0XCIsIGNvbnRleHQpO1xuXG4gICAgLy8gYSBiZWZvcmUgcGx1Z2luIGNhbiB1c3VycCB0aGUgcmVzdWx0IGNvbXBsZXRlbHkgYnkgcHJvdmlkaW5nIGl0J3Mgb3duXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBldmVuIG5lZWQgdG8gY2FsbCBoaWdobGlnaHRcbiAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0LnJlc3VsdFxuICAgICAgPyBjb250ZXh0LnJlc3VsdFxuICAgICAgOiBfaGlnaGxpZ2h0KGNvbnRleHQubGFuZ3VhZ2UsIGNvbnRleHQuY29kZSwgaWdub3JlSWxsZWdhbHMpO1xuXG4gICAgcmVzdWx0LmNvZGUgPSBjb250ZXh0LmNvZGU7XG4gICAgLy8gdGhlIHBsdWdpbiBjYW4gY2hhbmdlIGFueXRoaW5nIGluIHJlc3VsdCB0byBzdWl0ZSBpdFxuICAgIGZpcmUoXCJhZnRlcjpoaWdobGlnaHRcIiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogcHJpdmF0ZSBoaWdobGlnaHQgdGhhdCdzIHVzZWQgaW50ZXJuYWxseSBhbmQgZG9lcyBub3QgZmlyZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZSAtIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVRvSGlnaGxpZ2h0IC0gdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj99IFtpZ25vcmVJbGxlZ2Fsc10gLSB3aGV0aGVyIHRvIGlnbm9yZSBpbGxlZ2FsIG1hdGNoZXMsIGRlZmF1bHQgaXMgdG8gYmFpbFxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZT99IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IC0gcmVzdWx0IG9mIHRoZSBoaWdobGlnaHQgb3BlcmF0aW9uXG4gICovXG4gIGZ1bmN0aW9uIF9oaWdobGlnaHQobGFuZ3VhZ2VOYW1lLCBjb2RlVG9IaWdobGlnaHQsIGlnbm9yZUlsbGVnYWxzLCBjb250aW51YXRpb24pIHtcbiAgICBjb25zdCBrZXl3b3JkSGl0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5d29yZCBkYXRhIGlmIGEgbWF0Y2ggaXMgYSBrZXl3b3JkXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBjdXJyZW50IG1vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0IC0gdGhlIHRleHR1YWwgbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7S2V5d29yZERhdGEgfCBmYWxzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXl3b3JkRGF0YShtb2RlLCBtYXRjaFRleHQpIHtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzW21hdGNoVGV4dF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpIHtcbiAgICAgICAgZW1pdHRlci5hZGRUZXh0KG1vZGVCdWZmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIGJ1ZiArPSBtb2RlQnVmZmVyLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3Qgd29yZCA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXl3b3JkRGF0YSh0b3AsIHdvcmQpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGNvbnN0IFtraW5kLCBrZXl3b3JkUmVsZXZhbmNlXSA9IGRhdGE7XG4gICAgICAgICAgZW1pdHRlci5hZGRUZXh0KGJ1Zik7XG4gICAgICAgICAgYnVmID0gXCJcIjtcblxuICAgICAgICAgIGtleXdvcmRIaXRzW3dvcmRdID0gKGtleXdvcmRIaXRzW3dvcmRdIHx8IDApICsgMTtcbiAgICAgICAgICBpZiAoa2V5d29yZEhpdHNbd29yZF0gPD0gTUFYX0tFWVdPUkRfSElUUykgcmVsZXZhbmNlICs9IGtleXdvcmRSZWxldmFuY2U7XG4gICAgICAgICAgaWYgKGtpbmQuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgICAgIC8vIF8gaW1wbGllZCBmb3IgcmVsZXZhbmNlIG9ubHksIGRvIG5vdCBoaWdobGlnaHRcbiAgICAgICAgICAgIC8vIGJ5IGFwcGx5aW5nIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgYnVmICs9IG1hdGNoWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjc3NDbGFzcyA9IGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNba2luZF0gfHwga2luZDtcbiAgICAgICAgICAgIGVtaXR0ZXIuYWRkS2V5d29yZChtYXRjaFswXSwgY3NzQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHIobGFzdEluZGV4KTtcbiAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIGlmIChtb2RlQnVmZmVyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAvKiogQHR5cGUgSGlnaGxpZ2h0UmVzdWx0ICovXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9oaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlQnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pO1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi8gKHJlc3VsdC5fdG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLmFkZFN1Ymxhbmd1YWdlKHJlc3VsdC5fZW1pdHRlciwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKCkge1xuICAgICAgaWYgKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NTdWJMYW5ndWFnZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0tleXdvcmRzKCk7XG4gICAgICB9XG4gICAgICBtb2RlQnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZFNjb3BlfSBzY29wZVxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbWl0TXVsdGlDbGFzcyhzY29wZSwgbWF0Y2gpIHtcbiAgICAgIGxldCBpID0gMTtcbiAgICAgIGNvbnN0IG1heCA9IG1hdGNoLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA8PSBtYXgpIHtcbiAgICAgICAgaWYgKCFzY29wZS5fZW1pdFtpXSkgeyBpKys7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbnN0IGtsYXNzID0gbGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1tzY29wZVtpXV0gfHwgc2NvcGVbaV07XG4gICAgICAgIGNvbnN0IHRleHQgPSBtYXRjaFtpXTtcbiAgICAgICAgaWYgKGtsYXNzKSB7XG4gICAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKHRleHQsIGtsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gdGV4dDtcbiAgICAgICAgICBwcm9jZXNzS2V5d29yZHMoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBuZXcgbW9kZSB0byBzdGFydFxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydE5ld01vZGUobW9kZSwgbWF0Y2gpIHtcbiAgICAgIGlmIChtb2RlLnNjb3BlICYmIHR5cGVvZiBtb2RlLnNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVtaXR0ZXIub3Blbk5vZGUobGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLnNjb3BlXSB8fCBtb2RlLnNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmJlZ2luU2NvcGUpIHtcbiAgICAgICAgLy8gYmVnaW5TY29wZSBqdXN0IHdyYXBzIHRoZSBiZWdpbiBtYXRjaCBpdHNlbGYgaW4gYSBzY29wZVxuICAgICAgICBpZiAobW9kZS5iZWdpblNjb3BlLl93cmFwKSB7XG4gICAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKG1vZGVCdWZmZXIsIGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNbbW9kZS5iZWdpblNjb3BlLl93cmFwXSB8fCBtb2RlLmJlZ2luU2NvcGUuX3dyYXApO1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUuYmVnaW5TY29wZS5fbXVsdGkpIHtcbiAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IG1vZGVCdWZmZXIgc2hvdWxkIGp1c3QgYmUgdGhlIG1hdGNoXG4gICAgICAgICAgZW1pdE11bHRpQ2xhc3MobW9kZS5iZWdpblNjb3BlLCBtYXRjaCk7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9wID0gT2JqZWN0LmNyZWF0ZShtb2RlLCB7IHBhcmVudDogeyB2YWx1ZTogdG9wIH0gfSk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlIH0gbW9kZSAtIHRoZSBtb2RlIHRvIHBvdGVudGlhbGx5IGVuZFxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2ggLSB0aGUgbGF0ZXN0IG1hdGNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoUGx1c1JlbWFpbmRlciAtIG1hdGNoIHBsdXMgcmVtYWluZGVyIG9mIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7Q29tcGlsZWRNb2RlIHwgdm9pZH0gLSB0aGUgbmV4dCBtb2RlLCBvciBpZiB2b2lkIGNvbnRpbnVlIG9uIGluIGN1cnJlbnQgbW9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZE9mTW9kZShtb2RlLCBtYXRjaCwgbWF0Y2hQbHVzUmVtYWluZGVyKSB7XG4gICAgICBsZXQgbWF0Y2hlZCA9IHN0YXJ0c1dpdGgobW9kZS5lbmRSZSwgbWF0Y2hQbHVzUmVtYWluZGVyKTtcblxuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgaWYgKG1vZGVbXCJvbjplbmRcIl0pIHtcbiAgICAgICAgICBjb25zdCByZXNwID0gbmV3IFJlc3BvbnNlKG1vZGUpO1xuICAgICAgICAgIG1vZGVbXCJvbjplbmRcIl0obWF0Y2gsIHJlc3ApO1xuICAgICAgICAgIGlmIChyZXNwLmlzTWF0Y2hJZ25vcmVkKSBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHdoaWxlIChtb2RlLmVuZHNQYXJlbnQgJiYgbW9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIG1vZGUgPSBtb2RlLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV2ZW4gaWYgb246ZW5kIGZpcmVzIGFuIGBpZ25vcmVgIGl0J3Mgc3RpbGwgcG9zc2libGVcbiAgICAgIC8vIHRoYXQgd2UgbWlnaHQgdHJpZ2dlciB0aGUgZW5kIG5vZGUgYmVjYXVzZSBvZiBhIHBhcmVudCBtb2RlXG4gICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCkge1xuICAgICAgICByZXR1cm4gZW5kT2ZNb2RlKG1vZGUucGFyZW50LCBtYXRjaCwgbWF0Y2hQbHVzUmVtYWluZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbWF0Y2hpbmcgYnV0IHRoZW4gaWdub3JpbmcgYSBzZXF1ZW5jZSBvZiB0ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV4ZW1lIC0gc3RyaW5nIGNvbnRhaW5pbmcgZnVsbCBtYXRjaCB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9JZ25vcmUobGV4ZW1lKSB7XG4gICAgICBpZiAodG9wLm1hdGNoZXIucmVnZXhJbmRleCA9PT0gMCkge1xuICAgICAgICAvLyBubyBtb3JlIHJlZ2V4ZXMgdG8gcG90ZW50aWFsbHkgbWF0Y2ggaGVyZSwgc28gd2UgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgb25lXG4gICAgICAgIC8vIHNwYWNlXG4gICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lWzBdO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gbW92ZSB0aGUgY3Vyc29yLCB3ZSBzdGlsbCBoYXZlIGFkZGl0aW9uYWwgcmVnZXhlcyB0byB0cnkgYW5kXG4gICAgICAgIC8vIG1hdGNoIGF0IHRoaXMgdmVyeSBzcG90XG4gICAgICAgIHJlc3VtZVNjYW5BdFNhbWVQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgc3RhcnQgb2YgYSBuZXcgcG90ZW50aWFsIG1vZGUgbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRNYXRjaH0gbWF0Y2ggLSB0aGUgY3VycmVudCBtYXRjaFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGhvdyBmYXIgdG8gYWR2YW5jZSB0aGUgcGFyc2UgY3Vyc29yXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9CZWdpbk1hdGNoKG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IG5ld01vZGUgPSBtYXRjaC5ydWxlO1xuXG4gICAgICBjb25zdCByZXNwID0gbmV3IFJlc3BvbnNlKG5ld01vZGUpO1xuICAgICAgLy8gZmlyc3QgaW50ZXJuYWwgYmVmb3JlIGNhbGxiYWNrcywgdGhlbiB0aGUgcHVibGljIG9uZXNcbiAgICAgIGNvbnN0IGJlZm9yZUNhbGxiYWNrcyA9IFtuZXdNb2RlLl9fYmVmb3JlQmVnaW4sIG5ld01vZGVbXCJvbjpiZWdpblwiXV07XG4gICAgICBmb3IgKGNvbnN0IGNiIG9mIGJlZm9yZUNhbGxiYWNrcykge1xuICAgICAgICBpZiAoIWNiKSBjb250aW51ZTtcbiAgICAgICAgY2IobWF0Y2gsIHJlc3ApO1xuICAgICAgICBpZiAocmVzcC5pc01hdGNoSWdub3JlZCkgcmV0dXJuIGRvSWdub3JlKGxleGVtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdNb2RlLnNraXApIHtcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV3TW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGlmICghbmV3TW9kZS5yZXR1cm5CZWdpbiAmJiAhbmV3TW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFydE5ld01vZGUobmV3TW9kZSwgbWF0Y2gpO1xuICAgICAgcmV0dXJuIG5ld01vZGUucmV0dXJuQmVnaW4gPyAwIDogbGV4ZW1lLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIHBvdGVudGlhbCBlbmQgb2YgbW9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9FbmRNYXRjaChtYXRjaCkge1xuICAgICAgY29uc3QgbGV4ZW1lID0gbWF0Y2hbMF07XG4gICAgICBjb25zdCBtYXRjaFBsdXNSZW1haW5kZXIgPSBjb2RlVG9IaWdobGlnaHQuc3Vic3RyKG1hdGNoLmluZGV4KTtcblxuICAgICAgY29uc3QgZW5kTW9kZSA9IGVuZE9mTW9kZSh0b3AsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuICAgICAgaWYgKCFlbmRNb2RlKSB7IHJldHVybiBOT19NQVRDSDsgfVxuXG4gICAgICBjb25zdCBvcmlnaW4gPSB0b3A7XG4gICAgICBpZiAodG9wLmVuZFNjb3BlICYmIHRvcC5lbmRTY29wZS5fd3JhcCkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGVtaXR0ZXIuYWRkS2V5d29yZChsZXhlbWUsIHRvcC5lbmRTY29wZS5fd3JhcCk7XG4gICAgICB9IGVsc2UgaWYgKHRvcC5lbmRTY29wZSAmJiB0b3AuZW5kU2NvcGUuX211bHRpKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgZW1pdE11bHRpQ2xhc3ModG9wLmVuZFNjb3BlLCBtYXRjaCk7XG4gICAgICB9IGVsc2UgaWYgKG9yaWdpbi5za2lwKSB7XG4gICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEob3JpZ2luLnJldHVybkVuZCB8fCBvcmlnaW4uZXhjbHVkZUVuZCkpIHtcbiAgICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGlmIChvcmlnaW4uZXhjbHVkZUVuZCkge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRvcC5zY29wZSkge1xuICAgICAgICAgIGVtaXR0ZXIuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3Auc2tpcCAmJiAhdG9wLnN1Ykxhbmd1YWdlKSB7XG4gICAgICAgICAgcmVsZXZhbmNlICs9IHRvcC5yZWxldmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKHRvcCAhPT0gZW5kTW9kZS5wYXJlbnQpO1xuICAgICAgaWYgKGVuZE1vZGUuc3RhcnRzKSB7XG4gICAgICAgIHN0YXJ0TmV3TW9kZShlbmRNb2RlLnN0YXJ0cywgbWF0Y2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbi5yZXR1cm5FbmQgPyAwIDogbGV4ZW1lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQ29udGludWF0aW9ucygpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQgIT09IGxhbmd1YWdlOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuc2NvcGUpIHtcbiAgICAgICAgICBsaXN0LnVuc2hpZnQoY3VycmVudC5zY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QuZm9yRWFjaChpdGVtID0+IGVtaXR0ZXIub3Blbk5vZGUoaXRlbSkpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7e3R5cGU/OiBNYXRjaFR5cGUsIGluZGV4PzogbnVtYmVyLCBydWxlPzogTW9kZX19fSAqL1xuICAgIGxldCBsYXN0TWF0Y2ggPSB7fTtcblxuICAgIC8qKlxuICAgICAqICBQcm9jZXNzIGFuIGluZGl2aWR1YWwgbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0QmVmb3JlTWF0Y2ggLSB0ZXh0IHByZWNlZGluZyB0aGUgbWF0Y2ggKHNpbmNlIHRoZSBsYXN0IG1hdGNoKVxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRNYXRjaH0gW21hdGNoXSAtIHRoZSBtYXRjaCBpdHNlbGZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGV4ZW1lKHRleHRCZWZvcmVNYXRjaCwgbWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoICYmIG1hdGNoWzBdO1xuXG4gICAgICAvLyBhZGQgbm9uLW1hdGNoZWQgdGV4dCB0byB0aGUgY3VycmVudCBtb2RlIGJ1ZmZlclxuICAgICAgbW9kZUJ1ZmZlciArPSB0ZXh0QmVmb3JlTWF0Y2g7XG5cbiAgICAgIGlmIChsZXhlbWUgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBmb3VuZCBhIDAgd2lkdGggbWF0Y2ggYW5kIHdlJ3JlIHN0dWNrLCBzbyB3ZSBuZWVkIHRvIGFkdmFuY2VcbiAgICAgIC8vIHRoaXMgaGFwcGVucyB3aGVuIHdlIGhhdmUgYmFkbHkgYmVoYXZlZCBydWxlcyB0aGF0IGhhdmUgb3B0aW9uYWwgbWF0Y2hlcnMgdG8gdGhlIGRlZ3JlZSB0aGF0XG4gICAgICAvLyBzb21ldGltZXMgdGhleSBjYW4gZW5kIHVwIG1hdGNoaW5nIG5vdGhpbmcgYXQgYWxsXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzIxNDBcbiAgICAgIGlmIChsYXN0TWF0Y2gudHlwZSA9PT0gXCJiZWdpblwiICYmIG1hdGNoLnR5cGUgPT09IFwiZW5kXCIgJiYgbGFzdE1hdGNoLmluZGV4ID09PSBtYXRjaC5pbmRleCAmJiBsZXhlbWUgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gc3BpdCB0aGUgXCJza2lwcGVkXCIgY2hhcmFjdGVyIHRoYXQgb3VyIHJlZ2V4IGNob2tlZCBvbiBiYWNrIGludG8gdGhlIG91dHB1dCBzZXF1ZW5jZVxuICAgICAgICBtb2RlQnVmZmVyICs9IGNvZGVUb0hpZ2hsaWdodC5zbGljZShtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxKTtcbiAgICAgICAgaWYgKCFTQUZFX01PREUpIHtcbiAgICAgICAgICAvKiogQHR5cGUge0Fubm90YXRlZEVycm9yfSAqL1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgMCB3aWR0aCBtYXRjaCByZWdleCAoJHtsYW5ndWFnZU5hbWV9KWApO1xuICAgICAgICAgIGVyci5sYW5ndWFnZU5hbWUgPSBsYW5ndWFnZU5hbWU7XG4gICAgICAgICAgZXJyLmJhZFJ1bGUgPSBsYXN0TWF0Y2gucnVsZTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBsYXN0TWF0Y2ggPSBtYXRjaDtcblxuICAgICAgaWYgKG1hdGNoLnR5cGUgPT09IFwiYmVnaW5cIikge1xuICAgICAgICByZXR1cm4gZG9CZWdpbk1hdGNoKG1hdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gXCJpbGxlZ2FsXCIgJiYgIWlnbm9yZUlsbGVnYWxzKSB7XG4gICAgICAgIC8vIGlsbGVnYWwgbWF0Y2gsIHdlIGRvIG5vdCBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgIC8qKiBAdHlwZSB7QW5ub3RhdGVkRXJyb3J9ICovXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSWxsZWdhbCBsZXhlbWUgXCInICsgbGV4ZW1lICsgJ1wiIGZvciBtb2RlIFwiJyArICh0b3Auc2NvcGUgfHwgJzx1bm5hbWVkPicpICsgJ1wiJyk7XG4gICAgICAgIGVyci5tb2RlID0gdG9wO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnR5cGUgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZG9FbmRNYXRjaChtYXRjaCk7XG4gICAgICAgIGlmIChwcm9jZXNzZWQgIT09IE5PX01BVENIKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBlZGdlIGNhc2UgZm9yIHdoZW4gaWxsZWdhbCBtYXRjaGVzICQgKGVuZCBvZiBsaW5lKSB3aGljaCBpcyB0ZWNobmljYWxseVxuICAgICAgLy8gYSAwIHdpZHRoIG1hdGNoIGJ1dCBub3QgYSBiZWdpbi9lbmQgbWF0Y2ggc28gaXQncyBub3QgY2F1Z2h0IGJ5IHRoZVxuICAgICAgLy8gZmlyc3QgaGFuZGxlciAod2hlbiBpZ25vcmVJbGxlZ2FscyBpcyB0cnVlKVxuICAgICAgaWYgKG1hdGNoLnR5cGUgPT09IFwiaWxsZWdhbFwiICYmIGxleGVtZSA9PT0gXCJcIikge1xuICAgICAgICAvLyBhZHZhbmNlIHNvIHdlIGFyZW4ndCBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmZpbml0ZSBsb29wcyBhcmUgQkFELCB0aGlzIGlzIGEgbGFzdCBkaXRjaCBjYXRjaCBhbGwuIGlmIHdlIGhhdmUgYVxuICAgICAgLy8gZGVjZW50IG51bWJlciBvZiBpdGVyYXRpb25zIHlldCBvdXIgaW5kZXggKGN1cnNvciBwb3NpdGlvbiBpbiBvdXJcbiAgICAgIC8vIHBhcnNpbmcpIHN0aWxsIDN4IGJlaGluZCBvdXIgaW5kZXggdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZ1xuICAgICAgLy8gc28gd2UgYmFpbFxuICAgICAgaWYgKGl0ZXJhdGlvbnMgPiAxMDAwMDAgJiYgaXRlcmF0aW9ucyA+IG1hdGNoLmluZGV4ICogMykge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ3BvdGVudGlhbCBpbmZpbml0ZSBsb29wLCB3YXkgbW9yZSBpdGVyYXRpb25zIHRoYW4gbWF0Y2hlcycpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBXaHkgbWlnaHQgYmUgZmluZCBvdXJzZWx2ZXMgaGVyZT8gIEFuIHBvdGVudGlhbCBlbmQgbWF0Y2ggdGhhdCB3YXNcbiAgICAgIHRyaWdnZXJlZCBidXQgY291bGQgbm90IGJlIGNvbXBsZXRlZC4gIElFLCBgZG9FbmRNYXRjaGAgcmV0dXJuZWQgTk9fTUFUQ0guXG4gICAgICAodGhpcyBjb3VsZCBiZSBiZWNhdXNlIGEgY2FsbGJhY2sgcmVxdWVzdHMgdGhlIG1hdGNoIGJlIGlnbm9yZWQsIGV0YylcblxuICAgICAgVGhpcyBjYXVzZXMgbm8gcmVhbCBoYXJtIG90aGVyIHRoYW4gc3RvcHBpbmcgYSBmZXcgdGltZXMgdG9vIG1hbnkuXG4gICAgICAqL1xuXG4gICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIHJldHVybiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2VOYW1lKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICBlcnJvcihMQU5HVUFHRV9OT1RfRk9VTkQucmVwbGFjZShcInt9XCIsIGxhbmd1YWdlTmFtZSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlOiBcIicgKyBsYW5ndWFnZU5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZCA9IGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Q29tcGlsZWRNb2RlfSAqL1xuICAgIGxldCB0b3AgPSBjb250aW51YXRpb24gfHwgbWQ7XG4gICAgLyoqIEB0eXBlIFJlY29yZDxzdHJpbmcsQ29tcGlsZWRNb2RlPiAqL1xuICAgIGNvbnN0IGNvbnRpbnVhdGlvbnMgPSB7fTsgLy8ga2VlcCBjb250aW51YXRpb25zIGZvciBzdWItbGFuZ3VhZ2VzXG4gICAgY29uc3QgZW1pdHRlciA9IG5ldyBvcHRpb25zLl9fZW1pdHRlcihvcHRpb25zKTtcbiAgICBwcm9jZXNzQ29udGludWF0aW9ucygpO1xuICAgIGxldCBtb2RlQnVmZmVyID0gJyc7XG4gICAgbGV0IHJlbGV2YW5jZSA9IDA7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgbGV0IHJlc3VtZVNjYW5BdFNhbWVQb3NpdGlvbiA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRvcC5tYXRjaGVyLmNvbnNpZGVyQWxsKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICBpZiAocmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uKSB7XG4gICAgICAgICAgLy8gb25seSByZWdleGVzIG5vdCBtYXRjaGVkIHByZXZpb3VzbHkgd2lsbCBub3cgYmVcbiAgICAgICAgICAvLyBjb25zaWRlcmVkIGZvciBhIHBvdGVudGlhbCBtYXRjaFxuICAgICAgICAgIHJlc3VtZVNjYW5BdFNhbWVQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcC5tYXRjaGVyLmNvbnNpZGVyQWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9wLm1hdGNoZXIubGFzdEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0b3AubWF0Y2hlci5leGVjKGNvZGVUb0hpZ2hsaWdodCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWF0Y2hcIiwgbWF0Y2hbMF0sIG1hdGNoLnJ1bGUgJiYgbWF0Y2gucnVsZS5iZWdpbilcblxuICAgICAgICBpZiAoIW1hdGNoKSBicmVhaztcblxuICAgICAgICBjb25zdCBiZWZvcmVNYXRjaCA9IGNvZGVUb0hpZ2hsaWdodC5zdWJzdHJpbmcoaW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ291bnQgPSBwcm9jZXNzTGV4ZW1lKGJlZm9yZU1hdGNoLCBtYXRjaCk7XG4gICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBwcm9jZXNzZWRDb3VudDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NMZXhlbWUoY29kZVRvSGlnaGxpZ2h0LnN1YnN0cihpbmRleCkpO1xuICAgICAgZW1pdHRlci5jbG9zZUFsbE5vZGVzKCk7XG4gICAgICBlbWl0dGVyLmZpbmFsaXplKCk7XG4gICAgICByZXN1bHQgPSBlbWl0dGVyLnRvSFRNTCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICByZWxldmFuY2U6IHJlbGV2YW5jZSxcbiAgICAgICAgaWxsZWdhbDogZmFsc2UsXG4gICAgICAgIF9lbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICBfdG9wOiB0b3BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0lsbGVnYWwnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZShjb2RlVG9IaWdobGlnaHQpLFxuICAgICAgICAgIGlsbGVnYWw6IHRydWUsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIF9pbGxlZ2FsQnk6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgY29udGV4dDogY29kZVRvSGlnaGxpZ2h0LnNsaWNlKGluZGV4IC0gMTAwLCBpbmRleCArIDEwMCksXG4gICAgICAgICAgICBtb2RlOiBlcnIubW9kZSxcbiAgICAgICAgICAgIHJlc3VsdFNvRmFyOiByZXN1bHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIF9lbWl0dGVyOiBlbWl0dGVyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFNBRkVfTU9ERSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZShjb2RlVG9IaWdobGlnaHQpLFxuICAgICAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICBlcnJvclJhaXNlZDogZXJyLFxuICAgICAgICAgIF9lbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICAgIF90b3A6IHRvcFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgdmFsaWQgaGlnaGxpZ2h0IHJlc3VsdCwgd2l0aG91dCBhY3R1YWxseSBkb2luZyBhbnkgYWN0dWFsIHdvcmssXG4gICAqIGF1dG8gaGlnaGxpZ2h0IHN0YXJ0cyB3aXRoIHRoaXMgYW5kIGl0J3MgcG9zc2libGUgZm9yIHNtYWxsIHNuaXBwZXRzIHRoYXRcbiAgICogYXV0by1kZXRlY3Rpb24gbWF5IG5vdCBmaW5kIGEgYmV0dGVyIG1hdGNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBqdXN0VGV4dEhpZ2hsaWdodFJlc3VsdChjb2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgdmFsdWU6IGVzY2FwZShjb2RlKSxcbiAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgX3RvcDogUExBSU5URVhUX0xBTkdVQUdFLFxuICAgICAgX2VtaXR0ZXI6IG5ldyBvcHRpb25zLl9fZW1pdHRlcihvcHRpb25zKVxuICAgIH07XG4gICAgcmVzdWx0Ll9lbWl0dGVyLmFkZFRleHQoY29kZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kQmVzdCAob2JqZWN0IHdpdGggdGhlIHNhbWUgc3RydWN0dXJlIGZvciBzZWNvbmQtYmVzdCBoZXVyaXN0aWNhbGx5XG4gICAgZGV0ZWN0ZWQgbGFuZ3VhZ2UsIG1heSBiZSBhYnNlbnQpXG5cbiAgICBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2xhbmd1YWdlU3Vic2V0XVxuICAgIEByZXR1cm5zIHtBdXRvSGlnaGxpZ2h0UmVzdWx0fVxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvKGNvZGUsIGxhbmd1YWdlU3Vic2V0KSB7XG4gICAgbGFuZ3VhZ2VTdWJzZXQgPSBsYW5ndWFnZVN1YnNldCB8fCBvcHRpb25zLmxhbmd1YWdlcyB8fCBPYmplY3Qua2V5cyhsYW5ndWFnZXMpO1xuICAgIGNvbnN0IHBsYWludGV4dCA9IGp1c3RUZXh0SGlnaGxpZ2h0UmVzdWx0KGNvZGUpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGxhbmd1YWdlU3Vic2V0LmZpbHRlcihnZXRMYW5ndWFnZSkuZmlsdGVyKGF1dG9EZXRlY3Rpb24pLm1hcChuYW1lID0+XG4gICAgICBfaGlnaGxpZ2h0KG5hbWUsIGNvZGUsIGZhbHNlKVxuICAgICk7XG4gICAgcmVzdWx0cy51bnNoaWZ0KHBsYWludGV4dCk7IC8vIHBsYWludGV4dCBpcyBhbHdheXMgYW4gb3B0aW9uXG5cbiAgICBjb25zdCBzb3J0ZWQgPSByZXN1bHRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIC8vIHNvcnQgYmFzZSBvbiByZWxldmFuY2VcbiAgICAgIGlmIChhLnJlbGV2YW5jZSAhPT0gYi5yZWxldmFuY2UpIHJldHVybiBiLnJlbGV2YW5jZSAtIGEucmVsZXZhbmNlO1xuXG4gICAgICAvLyBhbHdheXMgYXdhcmQgdGhlIHRpZSB0byB0aGUgYmFzZSBsYW5ndWFnZVxuICAgICAgLy8gaWUgaWYgQysrIGFuZCBBcmR1aW5vIGFyZSB0aWVkLCBpdCdzIG1vcmUgbGlrZWx5IHRvIGJlIEMrK1xuICAgICAgaWYgKGEubGFuZ3VhZ2UgJiYgYi5sYW5ndWFnZSkge1xuICAgICAgICBpZiAoZ2V0TGFuZ3VhZ2UoYS5sYW5ndWFnZSkuc3VwZXJzZXRPZiA9PT0gYi5sYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGdldExhbmd1YWdlKGIubGFuZ3VhZ2UpLnN1cGVyc2V0T2YgPT09IGEubGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIHNheSB0aGV5IGFyZSBlcXVhbCwgd2hpY2ggaGFzIHRoZSBlZmZlY3Qgb2Ygc29ydGluZyBvblxuICAgICAgLy8gcmVsZXZhbmNlIHdoaWxlIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIG9yZGVyaW5nIC0gd2hpY2ggaXMgaG93IHRpZXNcbiAgICAgIC8vIGhhdmUgaGlzdG9yaWNhbGx5IGJlZW4gc2V0dGxlZCwgaWUgdGhlIGxhbmd1YWdlIHRoYXQgY29tZXMgZmlyc3QgYWx3YXlzXG4gICAgICAvLyB3aW5zIGluIHRoZSBjYXNlIG9mIGEgdGllXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIGNvbnN0IFtiZXN0LCBzZWNvbmRCZXN0XSA9IHNvcnRlZDtcblxuICAgIC8qKiBAdHlwZSB7QXV0b0hpZ2hsaWdodFJlc3VsdH0gKi9cbiAgICBjb25zdCByZXN1bHQgPSBiZXN0O1xuICAgIHJlc3VsdC5zZWNvbmRCZXN0ID0gc2Vjb25kQmVzdDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5ldyBjbGFzcyBuYW1lIGZvciBibG9jayBnaXZlbiB0aGUgbGFuZ3VhZ2UgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3VycmVudExhbmddXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzdWx0TGFuZ11cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBjdXJyZW50TGFuZywgcmVzdWx0TGFuZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gKGN1cnJlbnRMYW5nICYmIGFsaWFzZXNbY3VycmVudExhbmddKSB8fCByZXN1bHRMYW5nO1xuXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGxqc1wiKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYSBET00gbm9kZSBjb250YWluaW5nIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGlnaGxpZ2h0ZWRIVE1MRWxlbWVudH0gZWxlbWVudCAtIHRoZSBIVE1MIGVsZW1lbnQgdG8gaGlnaGxpZ2h0XG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqL1xuICAgIGxldCBub2RlID0gbnVsbDtcbiAgICBjb25zdCBsYW5ndWFnZSA9IGJsb2NrTGFuZ3VhZ2UoZWxlbWVudCk7XG5cbiAgICBpZiAoc2hvdWxkTm90SGlnaGxpZ2h0KGxhbmd1YWdlKSkgcmV0dXJuO1xuXG4gICAgZmlyZShcImJlZm9yZTpoaWdobGlnaHRFbGVtZW50XCIsXG4gICAgICB7IGVsOiBlbGVtZW50LCBsYW5ndWFnZTogbGFuZ3VhZ2UgfSk7XG5cbiAgICAvLyB3ZSBzaG91bGQgYmUgYWxsIHRleHQsIG5vIGNoaWxkIG5vZGVzICh1bmVzY2FwZWQgSFRNTCkgLSB0aGlzIGlzIHBvc3NpYmx5XG4gICAgLy8gYW4gSFRNTCBpbmplY3Rpb24gYXR0YWNrIC0gaXQncyBsaWtlbHkgdG9vIGxhdGUgaWYgdGhpcyBpcyBhbHJlYWR5IGluXG4gICAgLy8gcHJvZHVjdGlvbiAodGhlIGNvZGUgaGFzIGxpa2VseSBhbHJlYWR5IGRvbmUgaXRzIGRhbWFnZSBieSB0aGUgdGltZVxuICAgIC8vIHdlJ3JlIHNlZWluZyBpdCkuLi4gYnV0IHdlIHllbGwgbG91ZGx5IGFib3V0IHRoaXMgc28gdGhhdCBob3BlZnVsbHkgaXQnc1xuICAgIC8vIG1vcmUgbGlrZWx5IHRvIGJlIGNhdWdodCBpbiBkZXZlbG9wbWVudCBiZWZvcmUgbWFraW5nIGl0IHRvIHByb2R1Y3Rpb25cbiAgICBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaWdub3JlVW5lc2NhcGVkSFRNTCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJPbmUgb2YgeW91ciBjb2RlIGJsb2NrcyBpbmNsdWRlcyB1bmVzY2FwZWQgSFRNTC4gVGhpcyBpcyBhIHBvdGVudGlhbGx5IHNlcmlvdXMgc2VjdXJpdHkgcmlzay5cIik7XG4gICAgICAgIGNvbnNvbGUud2FybihcImh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvd2lraS9zZWN1cml0eVwiKTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGVsZW1lbnQgd2l0aCB1bmVzY2FwZWQgSFRNTDpcIik7XG4gICAgICAgIGNvbnNvbGUud2FybihlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRocm93VW5lc2NhcGVkSFRNTCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgSFRNTEluamVjdGlvbkVycm9yKFxuICAgICAgICAgIFwiT25lIG9mIHlvdXIgY29kZSBibG9ja3MgaW5jbHVkZXMgdW5lc2NhcGVkIEhUTUwuXCIsXG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUxcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBlbGVtZW50O1xuICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgIGNvbnN0IHJlc3VsdCA9IGxhbmd1YWdlID8gaGlnaGxpZ2h0KHRleHQsIHsgbGFuZ3VhZ2UsIGlnbm9yZUlsbGVnYWxzOiB0cnVlIH0pIDogaGlnaGxpZ2h0QXV0byh0ZXh0KTtcblxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBsYW5ndWFnZSwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICBlbGVtZW50LnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2ZXJzaW9uIDExLjBcbiAgICAgIHJlOiByZXN1bHQucmVsZXZhbmNlLFxuICAgICAgcmVsZXZhbmNlOiByZXN1bHQucmVsZXZhbmNlXG4gICAgfTtcbiAgICBpZiAocmVzdWx0LnNlY29uZEJlc3QpIHtcbiAgICAgIGVsZW1lbnQuc2Vjb25kQmVzdCA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5zZWNvbmRCZXN0Lmxhbmd1YWdlLFxuICAgICAgICByZWxldmFuY2U6IHJlc3VsdC5zZWNvbmRCZXN0LnJlbGV2YW5jZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmaXJlKFwiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiLCB7IGVsOiBlbGVtZW50LCByZXN1bHQsIHRleHQgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBoaWdobGlnaHQuanMgZ2xvYmFsIG9wdGlvbnMgd2l0aCB0aGUgcGFzc2VkIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPEhMSlNPcHRpb25zPn0gdXNlck9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyT3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBpbmhlcml0KG9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlbW92ZSB2MTIsIGRlcHJlY2F0ZWRcbiAgY29uc3QgaW5pdEhpZ2hsaWdodGluZyA9ICgpID0+IHtcbiAgICBoaWdobGlnaHRBbGwoKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNi4wXCIsIFwiaW5pdEhpZ2hsaWdodGluZygpIGRlcHJlY2F0ZWQuICBVc2UgaGlnaGxpZ2h0QWxsKCkgbm93LlwiKTtcbiAgfTtcblxuICAvLyBUT0RPOiByZW1vdmUgdjEyLCBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgaGlnaGxpZ2h0QWxsKCk7XG4gICAgZGVwcmVjYXRlZChcIjEwLjYuMFwiLCBcImluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSBkZXByZWNhdGVkLiAgVXNlIGhpZ2hsaWdodEFsbCgpIG5vdy5cIik7XG4gIH1cblxuICBsZXQgd2FudHNIaWdobGlnaHQgPSBmYWxzZTtcblxuICAvKipcbiAgICogYXV0by1oaWdobGlnaHRzIGFsbCBwcmU+Y29kZSBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QWxsKCkge1xuICAgIC8vIGlmIHdlIGFyZSBjYWxsZWQgdG9vIGVhcmx5IGluIHRoZSBsb2FkaW5nIHByb2Nlc3NcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHdhbnRzSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbnMuY3NzU2VsZWN0b3IpO1xuICAgIGJsb2Nrcy5mb3JFYWNoKGhpZ2hsaWdodEVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdCgpIHtcbiAgICAvLyBpZiBhIGhpZ2hsaWdodCB3YXMgcmVxdWVzdGVkIGJlZm9yZSBET00gd2FzIGxvYWRlZCwgZG8gbm93XG4gICAgaWYgKHdhbnRzSGlnaGxpZ2h0KSBoaWdobGlnaHRBbGwoKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBib290LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsYW5ndWFnZSBncmFtbWFyIG1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VOYW1lXG4gICAqIEBwYXJhbSB7TGFuZ3VhZ2VGbn0gbGFuZ3VhZ2VEZWZpbml0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3Rlckxhbmd1YWdlKGxhbmd1YWdlTmFtZSwgbGFuZ3VhZ2VEZWZpbml0aW9uKSB7XG4gICAgbGV0IGxhbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBsYW5nID0gbGFuZ3VhZ2VEZWZpbml0aW9uKGhsanMpO1xuICAgIH0gY2F0Y2ggKGVycm9yJDEpIHtcbiAgICAgIGVycm9yKFwiTGFuZ3VhZ2UgZGVmaW5pdGlvbiBmb3IgJ3t9JyBjb3VsZCBub3QgYmUgcmVnaXN0ZXJlZC5cIi5yZXBsYWNlKFwie31cIiwgbGFuZ3VhZ2VOYW1lKSk7XG4gICAgICAvLyBoYXJkIG9yIHNvZnQgZXJyb3JcbiAgICAgIGlmICghU0FGRV9NT0RFKSB7IHRocm93IGVycm9yJDE7IH0gZWxzZSB7IGVycm9yKGVycm9yJDEpOyB9XG4gICAgICAvLyBsYW5ndWFnZXMgdGhhdCBoYXZlIHNlcmlvdXMgZXJyb3JzIGFyZSByZXBsYWNlZCB3aXRoIGVzc2VudGlhbGx5IGFcbiAgICAgIC8vIFwicGxhaW50ZXh0XCIgc3RhbmQtaW4gc28gdGhhdCB0aGUgY29kZSBibG9ja3Mgd2lsbCBzdGlsbCBnZXQgbm9ybWFsXG4gICAgICAvLyBjc3MgY2xhc3NlcyBhcHBsaWVkIHRvIHRoZW0gLSBhbmQgb25lIGJhZCBsYW5ndWFnZSB3b24ndCBicmVhayB0aGVcbiAgICAgIC8vIGVudGlyZSBoaWdobGlnaHRlclxuICAgICAgbGFuZyA9IFBMQUlOVEVYVF9MQU5HVUFHRTtcbiAgICB9XG4gICAgLy8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBuYW1lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgaW4gdGhlIG1ldGEtZGF0YVxuICAgIGlmICghbGFuZy5uYW1lKSBsYW5nLm5hbWUgPSBsYW5ndWFnZU5hbWU7XG4gICAgbGFuZ3VhZ2VzW2xhbmd1YWdlTmFtZV0gPSBsYW5nO1xuICAgIGxhbmcucmF3RGVmaW5pdGlvbiA9IGxhbmd1YWdlRGVmaW5pdGlvbi5iaW5kKG51bGwsIGhsanMpO1xuXG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgcmVnaXN0ZXJBbGlhc2VzKGxhbmcuYWxpYXNlcywgeyBsYW5ndWFnZU5hbWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxhbmd1YWdlIGdyYW1tYXIgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJMYW5ndWFnZShsYW5ndWFnZU5hbWUpIHtcbiAgICBkZWxldGUgbGFuZ3VhZ2VzW2xhbmd1YWdlTmFtZV07XG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBPYmplY3Qua2V5cyhhbGlhc2VzKSkge1xuICAgICAgaWYgKGFsaWFzZXNbYWxpYXNdID09PSBsYW5ndWFnZU5hbWUpIHtcbiAgICAgICAgZGVsZXRlIGFsaWFzZXNbYWxpYXNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IExpc3Qgb2YgbGFuZ3VhZ2UgaW50ZXJuYWwgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB7TGFuZ3VhZ2UgfCB1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRMYW5ndWFnZShuYW1lKSB7XG4gICAgbmFtZSA9IChuYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBsYW5ndWFnZXNbbmFtZV0gfHwgbGFuZ3VhZ2VzW2FsaWFzZXNbbmFtZV1dO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBhbGlhc0xpc3QgLSBzaW5nbGUgYWxpYXMgb3IgbGlzdCBvZiBhbGlhc2VzXG4gICAqIEBwYXJhbSB7e2xhbmd1YWdlTmFtZTogc3RyaW5nfX0gb3B0c1xuICAgKi9cbiAgZnVuY3Rpb24gcmVnaXN0ZXJBbGlhc2VzKGFsaWFzTGlzdCwgeyBsYW5ndWFnZU5hbWUgfSkge1xuICAgIGlmICh0eXBlb2YgYWxpYXNMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgYWxpYXNMaXN0ID0gW2FsaWFzTGlzdF07XG4gICAgfVxuICAgIGFsaWFzTGlzdC5mb3JFYWNoKGFsaWFzID0+IHsgYWxpYXNlc1thbGlhcy50b0xvd2VyQ2FzZSgpXSA9IGxhbmd1YWdlTmFtZTsgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGxhbmd1YWdlIGhhcyBhdXRvLWRldGVjdGlvbiBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgbGFuZ3VhZ2VcbiAgICovXG4gIGZ1bmN0aW9uIGF1dG9EZXRlY3Rpb24obmFtZSkge1xuICAgIGNvbnN0IGxhbmcgPSBnZXRMYW5ndWFnZShuYW1lKTtcbiAgICByZXR1cm4gbGFuZyAmJiAhbGFuZy5kaXNhYmxlQXV0b2RldGVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlcyB0aGUgb2xkIGhpZ2hsaWdodEJsb2NrIHBsdWdpbnMgdG8gdGhlIG5ld1xuICAgKiBoaWdobGlnaHRFbGVtZW50IEFQSVxuICAgKiBAcGFyYW0ge0hMSlNQbHVnaW59IHBsdWdpblxuICAgKi9cbiAgZnVuY3Rpb24gdXBncmFkZVBsdWdpbkFQSShwbHVnaW4pIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2MTJcbiAgICBpZiAocGx1Z2luW1wiYmVmb3JlOmhpZ2hsaWdodEJsb2NrXCJdICYmICFwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0RWxlbWVudFwiXSkge1xuICAgICAgcGx1Z2luW1wiYmVmb3JlOmhpZ2hsaWdodEVsZW1lbnRcIl0gPSAoZGF0YSkgPT4ge1xuICAgICAgICBwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIl0oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7IGJsb2NrOiBkYXRhLmVsIH0sIGRhdGEpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0QmxvY2tcIl0gJiYgIXBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEVsZW1lbnRcIl0pIHtcbiAgICAgIHBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEVsZW1lbnRcIl0gPSAoZGF0YSkgPT4ge1xuICAgICAgICBwbHVnaW5bXCJhZnRlcjpoaWdobGlnaHRCbG9ja1wiXShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgYmxvY2s6IGRhdGEuZWwgfSwgZGF0YSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgdXBncmFkZVBsdWdpbkFQSShwbHVnaW4pO1xuICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UGx1Z2luRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55fSBhcmdzXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50LCBhcmdzKSB7XG4gICAgY29uc3QgY2IgPSBldmVudDtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICBpZiAocGx1Z2luW2NiXSkge1xuICAgICAgICBwbHVnaW5bY2JdKGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERFUFJFQ0FURURcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBlbFxuICAgKi9cbiAgZnVuY3Rpb24gZGVwcmVjYXRlSGlnaGxpZ2h0QmxvY2soZWwpIHtcbiAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0QmxvY2sgd2lsbCBiZSByZW1vdmVkIGVudGlyZWx5IGluIHYxMi4wXCIpO1xuICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJQbGVhc2UgdXNlIGhpZ2hsaWdodEVsZW1lbnQgbm93LlwiKTtcblxuICAgIHJldHVybiBoaWdobGlnaHRFbGVtZW50KGVsKTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBkZWZpbml0aW9uICovXG4gIE9iamVjdC5hc3NpZ24oaGxqcywge1xuICAgIGhpZ2hsaWdodCxcbiAgICBoaWdobGlnaHRBdXRvLFxuICAgIGhpZ2hsaWdodEFsbCxcbiAgICBoaWdobGlnaHRFbGVtZW50LFxuICAgIC8vIFRPRE86IFJlbW92ZSB3aXRoIHYxMiBBUElcbiAgICBoaWdobGlnaHRCbG9jazogZGVwcmVjYXRlSGlnaGxpZ2h0QmxvY2ssXG4gICAgY29uZmlndXJlLFxuICAgIGluaXRIaWdobGlnaHRpbmcsXG4gICAgaW5pdEhpZ2hsaWdodGluZ09uTG9hZCxcbiAgICByZWdpc3Rlckxhbmd1YWdlLFxuICAgIHVucmVnaXN0ZXJMYW5ndWFnZSxcbiAgICBsaXN0TGFuZ3VhZ2VzLFxuICAgIGdldExhbmd1YWdlLFxuICAgIHJlZ2lzdGVyQWxpYXNlcyxcbiAgICBhdXRvRGV0ZWN0aW9uLFxuICAgIGluaGVyaXQsXG4gICAgYWRkUGx1Z2luXG4gIH0pO1xuXG4gIGhsanMuZGVidWdNb2RlID0gZnVuY3Rpb24oKSB7IFNBRkVfTU9ERSA9IGZhbHNlOyB9O1xuICBobGpzLnNhZmVNb2RlID0gZnVuY3Rpb24oKSB7IFNBRkVfTU9ERSA9IHRydWU7IH07XG4gIGhsanMudmVyc2lvblN0cmluZyA9IHZlcnNpb247XG5cbiAgaGxqcy5yZWdleCA9IHtcbiAgICBjb25jYXQ6IGNvbmNhdCxcbiAgICBsb29rYWhlYWQ6IGxvb2thaGVhZCxcbiAgICBlaXRoZXI6IGVpdGhlcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgYW55TnVtYmVyT2ZUaW1lczogYW55TnVtYmVyT2ZUaW1lc1xuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIE1PREVTKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgTU9ERVNba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZGVlcEZyZWV6ZSQxKE1PREVTW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGFsbCB0aGUgbW9kZXMvcmVnZXhlcyBpbnRvIG91ciBtYWluIG9iamVjdFxuICBPYmplY3QuYXNzaWduKGhsanMsIE1PREVTKTtcblxuICByZXR1cm4gaGxqcztcbn07XG5cbi8vIGV4cG9ydCBhbiBcImluc3RhbmNlXCIgb2YgdGhlIGhpZ2hsaWdodGVyXG52YXIgaGlnaGxpZ2h0ID0gSExKUyh7fSk7XG5cbnZhciBjb3JlID0gaGlnaGxpZ2h0O1xuaGlnaGxpZ2h0LkhpZ2hsaWdodEpTID0gaGlnaGxpZ2h0O1xuaGlnaGxpZ2h0LmRlZmF1bHQgPSBoaWdobGlnaHQ7XG5cbmNvbnN0IElERU5UX1JFID0gJ1tBLVphLXokX11bMC05QS1aYS16JF9dKic7XG5jb25zdCBLRVlXT1JEUyA9IFtcbiAgXCJhc1wiLCAvLyBmb3IgZXhwb3J0c1xuICBcImluXCIsXG4gIFwib2ZcIixcbiAgXCJpZlwiLFxuICBcImZvclwiLFxuICBcIndoaWxlXCIsXG4gIFwiZmluYWxseVwiLFxuICBcInZhclwiLFxuICBcIm5ld1wiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwiZG9cIixcbiAgXCJyZXR1cm5cIixcbiAgXCJ2b2lkXCIsXG4gIFwiZWxzZVwiLFxuICBcImJyZWFrXCIsXG4gIFwiY2F0Y2hcIixcbiAgXCJpbnN0YW5jZW9mXCIsXG4gIFwid2l0aFwiLFxuICBcInRocm93XCIsXG4gIFwiY2FzZVwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJ0cnlcIixcbiAgXCJzd2l0Y2hcIixcbiAgXCJjb250aW51ZVwiLFxuICBcInR5cGVvZlwiLFxuICBcImRlbGV0ZVwiLFxuICBcImxldFwiLFxuICBcInlpZWxkXCIsXG4gIFwiY29uc3RcIixcbiAgXCJjbGFzc1wiLFxuICAvLyBKUyBoYW5kbGVzIHRoZXNlIHdpdGggYSBzcGVjaWFsIHJ1bGVcbiAgLy8gXCJnZXRcIixcbiAgLy8gXCJzZXRcIixcbiAgXCJkZWJ1Z2dlclwiLFxuICBcImFzeW5jXCIsXG4gIFwiYXdhaXRcIixcbiAgXCJzdGF0aWNcIixcbiAgXCJpbXBvcnRcIixcbiAgXCJmcm9tXCIsXG4gIFwiZXhwb3J0XCIsXG4gIFwiZXh0ZW5kc1wiXG5dO1xuY29uc3QgTElURVJBTFMgPSBbXG4gIFwidHJ1ZVwiLFxuICBcImZhbHNlXCIsXG4gIFwibnVsbFwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIk5hTlwiLFxuICBcIkluZmluaXR5XCJcbl07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzXG5jb25zdCBUWVBFUyA9IFtcbiAgLy8gRnVuZGFtZW50YWwgb2JqZWN0c1xuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIlN5bWJvbFwiLFxuICAvLyBudW1iZXJzIGFuZCBkYXRlc1xuICBcIk1hdGhcIixcbiAgXCJEYXRlXCIsXG4gIFwiTnVtYmVyXCIsXG4gIFwiQmlnSW50XCIsXG4gIC8vIHRleHRcbiAgXCJTdHJpbmdcIixcbiAgXCJSZWdFeHBcIixcbiAgLy8gSW5kZXhlZCBjb2xsZWN0aW9uc1xuICBcIkFycmF5XCIsXG4gIFwiRmxvYXQzMkFycmF5XCIsXG4gIFwiRmxvYXQ2NEFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiSW50MTZBcnJheVwiLFxuICBcIkludDMyQXJyYXlcIixcbiAgXCJVaW50MTZBcnJheVwiLFxuICBcIlVpbnQzMkFycmF5XCIsXG4gIFwiQmlnSW50NjRBcnJheVwiLFxuICBcIkJpZ1VpbnQ2NEFycmF5XCIsXG4gIC8vIEtleWVkIGNvbGxlY3Rpb25zXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgLy8gU3RydWN0dXJlZCBkYXRhXG4gIFwiQXJyYXlCdWZmZXJcIixcbiAgXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFxuICBcIkF0b21pY3NcIixcbiAgXCJEYXRhVmlld1wiLFxuICBcIkpTT05cIixcbiAgLy8gQ29udHJvbCBhYnN0cmFjdGlvbiBvYmplY3RzXG4gIFwiUHJvbWlzZVwiLFxuICBcIkdlbmVyYXRvclwiLFxuICBcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXG4gIFwiQXN5bmNGdW5jdGlvblwiLFxuICAvLyBSZWZsZWN0aW9uXG4gIFwiUmVmbGVjdFwiLFxuICBcIlByb3h5XCIsXG4gIC8vIEludGVybmF0aW9uYWxpemF0aW9uXG4gIFwiSW50bFwiLFxuICAvLyBXZWJBc3NlbWJseVxuICBcIldlYkFzc2VtYmx5XCJcbl07XG5cbmNvbnN0IEVSUk9SX1RZUEVTID0gW1xuICBcIkVycm9yXCIsXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBUWVBFUyxcbiAgRVJST1JfVFlQRVNcbik7XG5cbi8qXG5MYW5ndWFnZTogSmF2YVNjcmlwdFxuRGVzY3JpcHRpb246IEphdmFTY3JpcHQgKEpTKSBpcyBhIGxpZ2h0d2VpZ2h0LCBpbnRlcnByZXRlZCwgb3IganVzdC1pbi10aW1lIGNvbXBpbGVkIHByb2dyYW1taW5nIGxhbmd1YWdlIHdpdGggZmlyc3QtY2xhc3MgZnVuY3Rpb25zLlxuQ2F0ZWdvcnk6IGNvbW1vbiwgc2NyaXB0aW5nLCB3ZWJcbldlYnNpdGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHRcbiovXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiBqYXZhc2NyaXB0KGhsanMpIHtcbiAgY29uc3QgcmVnZXggPSBobGpzLnJlZ2V4O1xuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgbGlrZSBcIjxCb29nZXJcIiBhbmQgY2hlY2tzIHRvIHNlZVxuICAgKiBpZiB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIFwiPC9Cb29nZXJcIiBsYXRlciBpbiB0aGVcbiAgICogY29udGVudC5cbiAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgKiBAcGFyYW0ge3thZnRlcjpudW1iZXJ9fSBwYXJhbTFcbiAgICovXG4gIGNvbnN0IGhhc0Nsb3NpbmdUYWcgPSAobWF0Y2gsIHsgYWZ0ZXIgfSkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFwiPC9cIiArIG1hdGNoWzBdLnNsaWNlKDEpO1xuICAgIGNvbnN0IHBvcyA9IG1hdGNoLmlucHV0LmluZGV4T2YodGFnLCBhZnRlcik7XG4gICAgcmV0dXJuIHBvcyAhPT0gLTE7XG4gIH07XG5cbiAgY29uc3QgSURFTlRfUkUkMSA9IElERU5UX1JFO1xuICBjb25zdCBGUkFHTUVOVCA9IHtcbiAgICBiZWdpbjogJzw+JyxcbiAgICBlbmQ6ICc8Lz4nXG4gIH07XG4gIC8vIHRvIGF2b2lkIHNvbWUgc3BlY2lhbCBjYXNlcyBpbnNpZGUgaXNUcnVseU9wZW5pbmdUYWdcbiAgY29uc3QgWE1MX1NFTEZfQ0xPU0lORyA9IC88W0EtWmEtejAtOVxcXFwuXzotXStcXHMqXFwvPi87XG4gIGNvbnN0IFhNTF9UQUcgPSB7XG4gICAgYmVnaW46IC88W0EtWmEtejAtOVxcXFwuXzotXSsvLFxuICAgIGVuZDogL1xcL1tBLVphLXowLTlcXFxcLl86LV0rPnxcXC8+LyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIGlzVHJ1bHlPcGVuaW5nVGFnOiAobWF0Y2gsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1hdGNoSW5kZXggPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2guaW5wdXRbYWZ0ZXJNYXRjaEluZGV4XTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gSFRNTCBzaG91bGQgbm90IGluY2x1ZGUgYW5vdGhlciByYXcgYDxgIGluc2lkZSBhIHRhZ1xuICAgICAgICAvLyBuZXN0ZWQgdHlwZT9cbiAgICAgICAgLy8gYDxBcnJheTxBcnJheTxudW1iZXI+PmAsIGV0Yy5cbiAgICAgICAgbmV4dENoYXIgPT09IFwiPFwiIHx8XG4gICAgICAgIC8vIHRoZSAsIGdpdmVzIGF3YXkgdGhhdCB0aGlzIGlzIG5vdCBIVE1MXG4gICAgICAgIC8vIGA8VCwgQSBleHRlbmRzIGtleW9mIFQsIFY+YFxuICAgICAgICBuZXh0Q2hhciA9PT0gXCIsXCIpIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBgPHNvbWV0aGluZz5gXG4gICAgICAvLyBRdWl0ZSBwb3NzaWJseSBhIHRhZywgbGV0cyBsb29rIGZvciBhIG1hdGNoaW5nIGNsb3NpbmcgdGFnLi4uXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGA8YmxhaCAvPmAgKHNlbGYtY2xvc2luZylcbiAgICAgIC8vIGhhbmRsZWQgYnkgc2ltcGxlU2VsZkNsb3NpbmcgcnVsZVxuXG4gICAgICAvLyBgPEZyb20gZXh0ZW5kcyBzdHJpbmc+YFxuICAgICAgLy8gdGVjaG5pY2FsbHkgdGhpcyBjb3VsZCBiZSBIVE1MLCBidXQgaXQgc21lbGxzIGxpa2UgYSB0eXBlXG4gICAgICBsZXQgbTtcbiAgICAgIGNvbnN0IGFmdGVyTWF0Y2ggPSBtYXRjaC5pbnB1dC5zdWJzdHIoYWZ0ZXJNYXRjaEluZGV4KTtcbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgdWdoLCBidXQgYWRkZWQgc3BlY2lmaWNhbGx5IGZvciBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8zMjc2XG4gICAgICBpZiAoKG0gPSBhZnRlck1hdGNoLm1hdGNoKC9eXFxzK2V4dGVuZHNcXHMrLykpKSB7XG4gICAgICAgIGlmIChtLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1yZXR1cm5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IEtFWVdPUkRTJDEgPSB7XG4gICAgJHBhdHRlcm46IElERU5UX1JFLFxuICAgIGtleXdvcmQ6IEtFWVdPUkRTLFxuICAgIGxpdGVyYWw6IExJVEVSQUxTLFxuICAgIGJ1aWx0X2luOiBCVUlMVF9JTlMsXG4gICAgXCJ2YXJpYWJsZS5sYW5ndWFnZVwiOiBCVUlMVF9JTl9WQVJJQUJMRVNcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcbiAgY29uc3QgZGVjaW1hbERpZ2l0cyA9ICdbMC05XShfP1swLTldKSonO1xuICBjb25zdCBmcmFjID0gYFxcXFwuKCR7ZGVjaW1hbERpZ2l0c30pYDtcbiAgLy8gRGVjaW1hbEludGVnZXJMaXRlcmFsLCBpbmNsdWRpbmcgQW5uZXggQiBOb25PY3RhbERlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkZGl0aW9uYWwtc3ludGF4LW51bWVyaWMtbGl0ZXJhbHNcbiAgY29uc3QgZGVjaW1hbEludGVnZXIgPSBgMHxbMS05XShfP1swLTldKSp8MFswLTddKls4OV1bMC05XSpgO1xuICBjb25zdCBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gRGVjaW1hbExpdGVyYWxcbiAgICAgIHsgYmVnaW46IGAoXFxcXGIoJHtkZWNpbWFsSW50ZWdlcn0pKCgke2ZyYWN9KXxcXFxcLik/fCgke2ZyYWN9KSlgICtcbiAgICAgICAgYFtlRV1bKy1dPygke2RlY2ltYWxEaWdpdHN9KVxcXFxiYCB9LFxuICAgICAgeyBiZWdpbjogYFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KVxcXFxiKCgke2ZyYWN9KVxcXFxifFxcXFwuKT98KCR7ZnJhY30pXFxcXGJgIH0sXG5cbiAgICAgIC8vIERlY2ltYWxCaWdJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogYFxcXFxiKDB8WzEtOV0oXz9bMC05XSkqKW5cXFxcYmAgfSxcblxuICAgICAgLy8gTm9uRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFt4WF1bMC05YS1mQS1GXShfP1swLTlhLWZBLUZdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW2JCXVswLTFdKF8/WzAtMV0pKm4/XFxcXGJcIiB9LFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbb09dWzAtN10oXz9bMC03XSkqbj9cXFxcYlwiIH0sXG5cbiAgICAgIC8vIExlZ2FjeU9jdGFsSW50ZWdlckxpdGVyYWwgKGRvZXMgbm90IGluY2x1ZGUgdW5kZXJzY29yZSBzZXBhcmF0b3JzKVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFswLTddK24/XFxcXGJcIiB9LFxuICAgIF0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAnXFxcXCRcXFxceycsXG4gICAgZW5kOiAnXFxcXH0nLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBbXSAvLyBkZWZpbmVkIGxhdGVyXG4gIH07XG4gIGNvbnN0IEhUTUxfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdodG1sYCcsXG4gICAgZW5kOiAnJyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZDogJ2AnLFxuICAgICAgcmV0dXJuRW5kOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgU1VCU1RcbiAgICAgIF0sXG4gICAgICBzdWJMYW5ndWFnZTogJ3htbCdcbiAgICB9XG4gIH07XG4gIGNvbnN0IENTU19URU1QTEFURSA9IHtcbiAgICBiZWdpbjogJ2Nzc2AnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICdjc3MnXG4gICAgfVxuICB9O1xuICBjb25zdCBURU1QTEFURV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ2AnLFxuICAgIGVuZDogJ2AnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgY29uc3QgSlNET0NfQ09NTUVOVCA9IGhsanMuQ09NTUVOVChcbiAgICAvXFwvXFwqXFwqKD8hXFwvKS8sXG4gICAgJ1xcXFwqLycsXG4gICAge1xuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGJlZ2luOiAnKD89QFtBLVphLXpdKyknLFxuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgICAgICAgICBiZWdpbjogJ0BbQS1aYS16XSsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdcXFxceycsXG4gICAgICAgICAgICAgIGVuZDogJ1xcXFx9JyxcbiAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICAgICAgICAgICAgYmVnaW46IElERU5UX1JFJDEgKyAnKD89XFxcXHMqKC0pfCQpJyxcbiAgICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZWF0IHNwYWNlcyAobm90IG5ld2xpbmVzKSBzbyB3ZSBjYW4gZmluZFxuICAgICAgICAgICAgLy8gdHlwZXMgb3IgdmFyaWFibGVzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJlZ2luOiAvKD89W15cXG5dKVxccy8sXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgKTtcbiAgY29uc3QgQ09NTUVOVCA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29tbWVudFwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICBKU0RPQ19DT01NRU5ULFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERVxuICAgIF1cbiAgfTtcbiAgY29uc3QgU1VCU1RfSU5URVJOQUxTID0gW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgIEhUTUxfVEVNUExBVEUsXG4gICAgQ1NTX1RFTVBMQVRFLFxuICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICBOVU1CRVIsXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbDpcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMzI4OFxuICAgIC8vIGhsanMuUkVHRVhQX01PREVcbiAgXTtcbiAgU1VCU1QuY29udGFpbnMgPSBTVUJTVF9JTlRFUk5BTFNcbiAgICAuY29uY2F0KHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gcGFpciB1cCB7fSBpbnNpZGUgb3VyIHN1YnN0IHRvIHByZXZlbnRcbiAgICAgIC8vIGl0IGZyb20gZW5kaW5nIHRvbyBlYXJseSBieSBtYXRjaGluZyBhbm90aGVyIH1cbiAgICAgIGJlZ2luOiAvXFx7LyxcbiAgICAgIGVuZDogL1xcfS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIFwic2VsZlwiXG4gICAgICBdLmNvbmNhdChTVUJTVF9JTlRFUk5BTFMpXG4gICAgfSk7XG4gIGNvbnN0IFNVQlNUX0FORF9DT01NRU5UUyA9IFtdLmNvbmNhdChDT01NRU5ULCBTVUJTVC5jb250YWlucyk7XG4gIGNvbnN0IFBBUkFNU19DT05UQUlOUyA9IFNVQlNUX0FORF9DT01NRU5UUy5jb25jYXQoW1xuICAgIC8vIGVhdCByZWN1cnNpdmUgcGFyZW5zIGluIHN1YiBleHByZXNzaW9uc1xuICAgIHtcbiAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgIGVuZDogL1xcKS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXCJzZWxmXCJdLmNvbmNhdChTVUJTVF9BTkRfQ09NTUVOVFMpXG4gICAgfVxuICBdKTtcbiAgY29uc3QgUEFSQU1TID0ge1xuICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS8sXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICB9O1xuXG4gIC8vIEVTNiBjbGFzc2VzXG4gIGNvbnN0IENMQVNTX09SX0VYVEVORFMgPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIGNsYXNzIENhciBleHRlbmRzIHZlaGljbGVcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICAvZXh0ZW5kcy8sXG4gICAgICAgICAgL1xccysvLFxuICAgICAgICAgIHJlZ2V4LmNvbmNhdChJREVOVF9SRSQxLCBcIihcIiwgcmVnZXguY29uY2F0KC9cXC4vLCBJREVOVF9SRSQxKSwgXCIpKlwiKVxuICAgICAgICBdLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgICAgIDM6IFwidGl0bGUuY2xhc3NcIixcbiAgICAgICAgICA1OiBcImtleXdvcmRcIixcbiAgICAgICAgICA3OiBcInRpdGxlLmNsYXNzLmluaGVyaXRlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBjbGFzcyBDYXJcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5jbGFzc1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICBdXG4gIH07XG5cbiAgY29uc3QgQ0xBU1NfUkVGRVJFTkNFID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDpcbiAgICByZWdleC5laXRoZXIoXG4gICAgICAvLyBIYXJkIGNvZGVkIGV4Y2VwdGlvbnNcbiAgICAgIC9cXGJKU09OLyxcbiAgICAgIC8vIEZsb2F0MzJBcnJheSwgT3V0VFxuICAgICAgL1xcYltBLVpdW2Etel0rKFtBLVpdW2Etel0qfFxcZCkqLyxcbiAgICAgIC8vIENTU0ZhY3RvcnksIENTU0ZhY3RvcnlUXG4gICAgICAvXFxiW0EtWl17Mix9KFtBLVpdW2Etel0rfFxcZCkrKFtBLVpdW2Etel0qKSovLFxuICAgICAgLy8gRlBzLCBGUHNUXG4gICAgICAvXFxiW0EtWl17Mix9W2Etel0rKFtBLVpdW2Etel0rfFxcZCkqKFtBLVpdW2Etel0qKSovLFxuICAgICAgLy8gUFxuICAgICAgLy8gc2luZ2xlIGxldHRlcnMgYXJlIG5vdCBoaWdobGlnaHRlZFxuICAgICAgLy8gQkxBSFxuICAgICAgLy8gdGhpcyB3aWxsIGJlIGZsYWdnZWQgYXMgYSBVUFBFUl9DQVNFX0NPTlNUQU5UIGluc3RlYWRcbiAgICApLFxuICAgIGNsYXNzTmFtZTogXCJ0aXRsZS5jbGFzc1wiLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBfOiBbXG4gICAgICAgIC8vIHNlIHdlIHN0aWxsIGdldCByZWxldmFuY2UgY3JlZGl0IGZvciBKUyBsaWJyYXJ5IGNsYXNzZXNcbiAgICAgICAgLi4uVFlQRVMsXG4gICAgICAgIC4uLkVSUk9SX1RZUEVTXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IFVTRV9TVFJJQ1QgPSB7XG4gICAgbGFiZWw6IFwidXNlX3N0cmljdFwiLFxuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIHJlbGV2YW5jZTogMTAsXG4gICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICB9O1xuXG4gIGNvbnN0IEZVTkNUSU9OX0RFRklOSVRJT04gPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC8oPz1cXHMqXFwoKS9cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGFub255bW91cyBmdW5jdGlvblxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9mdW5jdGlvbi8sXG4gICAgICAgICAgL1xccyooPz1cXCgpL1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBjbGFzc05hbWU6IHtcbiAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgfSxcbiAgICBsYWJlbDogXCJmdW5jLmRlZlwiLFxuICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdLFxuICAgIGlsbGVnYWw6IC8lL1xuICB9O1xuXG4gIGNvbnN0IFVQUEVSX0NBU0VfQ09OU1RBTlQgPSB7XG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIG1hdGNoOiAvXFxiW0EtWl1bQS1aXzAtOV0rXFxiLyxcbiAgICBjbGFzc05hbWU6IFwidmFyaWFibGUuY29uc3RhbnRcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG5vbmVPZihsaXN0KSB7XG4gICAgcmV0dXJuIHJlZ2V4LmNvbmNhdChcIig/IVwiLCBsaXN0LmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gIH1cblxuICBjb25zdCBGVU5DVElPTl9DQUxMID0ge1xuICAgIG1hdGNoOiByZWdleC5jb25jYXQoXG4gICAgICAvXFxiLyxcbiAgICAgIG5vbmVPZihbXG4gICAgICAgIC4uLkJVSUxUX0lOX0dMT0JBTFMsXG4gICAgICAgIFwic3VwZXJcIlxuICAgICAgXSksXG4gICAgICBJREVOVF9SRSQxLCByZWdleC5sb29rYWhlYWQoL1xcKC8pKSxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIixcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBQUk9QRVJUWV9BQ0NFU1MgPSB7XG4gICAgYmVnaW46IHJlZ2V4LmNvbmNhdCgvXFwuLywgcmVnZXgubG9va2FoZWFkKFxuICAgICAgcmVnZXguY29uY2F0KElERU5UX1JFJDEsIC8oPyFbMC05QS1aYS16JF8oXSkvKVxuICAgICkpLFxuICAgIGVuZDogSURFTlRfUkUkMSxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAga2V5d29yZHM6IFwicHJvdG90eXBlXCIsXG4gICAgY2xhc3NOYW1lOiBcInByb3BlcnR5XCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgR0VUVEVSX09SX1NFVFRFUiA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2dldHxzZXQvLFxuICAgICAgL1xccysvLFxuICAgICAgSURFTlRfUkUkMSxcbiAgICAgIC8oPz1cXCgpL1xuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKFxcKS9cbiAgICAgIH0sXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgY29uc3QgRlVOQ19MRUFEX0lOX1JFID0gJyhcXFxcKCcgK1xuICAgICdbXigpXSooXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAnXFxcXCl8JyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICcpXFxcXHMqPT4nO1xuXG4gIGNvbnN0IEZVTkNUSU9OX1ZBUklBQkxFID0ge1xuICAgIG1hdGNoOiBbXG4gICAgICAvY29uc3R8dmFyfGxldC8sIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsIC9cXHMqLyxcbiAgICAgIC89XFxzKi8sXG4gICAgICAvKGFzeW5jXFxzKik/LywgLy8gYXN5bmMgaXMgb3B0aW9uYWxcbiAgICAgIHJlZ2V4Lmxvb2thaGVhZChGVU5DX0xFQURfSU5fUkUpXG4gICAgXSxcbiAgICBrZXl3b3JkczogXCJhc3luY1wiLFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAzOiBcInRpdGxlLmZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnSmF2YXNjcmlwdCcsXG4gICAgYWxpYXNlczogWydqcycsICdqc3gnLCAnbWpzJywgJ2NqcyddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBleHRlbmRlZCBieSBUeXBlU2NyaXB0XG4gICAgZXhwb3J0czogeyBQQVJBTVNfQ09OVEFJTlMsIENMQVNTX1JFRkVSRU5DRSB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICBVU0VfU1RSSUNULFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIEhUTUxfVEVNUExBVEUsXG4gICAgICBDU1NfVEVNUExBVEUsXG4gICAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgICBDT01NRU5ULFxuICAgICAgTlVNQkVSLFxuICAgICAgQ0xBU1NfUkVGRVJFTkNFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IElERU5UX1JFJDEgKyByZWdleC5sb29rYWhlYWQoJzonKSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fVkFSSUFCTEUsXG4gICAgICB7IC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgYmVnaW46ICcoJyArIGhsanMuUkVfU1RBUlRFUlNfUkUgKyAnfFxcXFxiKGNhc2V8cmV0dXJufHRocm93KVxcXFxiKVxcXFxzKicsXG4gICAgICAgIGtleXdvcmRzOiAncmV0dXJuIHRocm93IGNhc2UnLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgQ09NTUVOVCxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGVcbiAgICAgICAgICAgIC8vIGNvcnJlY3QgYm91bmRpbmcgKCApIGJlZm9yZSB0aGUgPT4uICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBzdWItZXhwcmVzc2lvbnMgaW5zaWRlIGFsc28gc3Vycm91bmRlZCBieSBwYXJlbnMuXG4gICAgICAgICAgICBiZWdpbjogRlVOQ19MRUFEX0lOX1JFLFxuICAgICAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICBlbmQ6ICdcXFxccyo9PicsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgICAgICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IC8vIGNvdWxkIGJlIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgcGFyYW1zIHRvIGEgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgYmVnaW46IC8sLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWF0Y2g6IC9cXHMrLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBKU1hcbiAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgIHsgYmVnaW46IEZSQUdNRU5ULmJlZ2luLCBlbmQ6IEZSQUdNRU5ULmVuZCB9LFxuICAgICAgICAgICAgICB7IG1hdGNoOiBYTUxfU0VMRl9DTE9TSU5HIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogWE1MX1RBRy5iZWdpbixcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYXJlZnVsbHkgY2hlY2sgdGhlIG9wZW5pbmcgdGFnIHRvIHNlZSBpZiBpdCB0cnVseVxuICAgICAgICAgICAgICAgIC8vIGlzIGEgdGFnIGFuZCBub3QgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgICAgICdvbjpiZWdpbic6IFhNTF9UQUcuaXNUcnVseU9wZW5pbmdUYWcsXG4gICAgICAgICAgICAgICAgZW5kOiBYTUxfVEFHLmVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiBYTUxfVEFHLmJlZ2luLFxuICAgICAgICAgICAgICAgIGVuZDogWE1MX1RBRy5lbmQsXG4gICAgICAgICAgICAgICAgc2tpcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250YWluczogWydzZWxmJ11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9ERUZJTklUSU9OLFxuICAgICAge1xuICAgICAgICAvLyBwcmV2ZW50IHRoaXMgZnJvbSBnZXR0aW5nIHN3YWxsb3dlZCB1cCBieSBmdW5jdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGV5IGFwcGVhciBcImZ1bmN0aW9uIGxpa2VcIlxuICAgICAgICBiZWdpbktleXdvcmRzOiBcIndoaWxlIGlmIHN3aXRjaCBjYXRjaCBmb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBjb3VudCB0aGUgcGFyZW5zIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHRoZSBjb3JyZWN0XG4gICAgICAgIC8vIGJvdW5kaW5nICggKS4gIFRoZXJlIGNvdWxkIGJlIGFueSBudW1iZXIgb2Ygc3ViLWV4cHJlc3Npb25zIGluc2lkZVxuICAgICAgICAvLyBhbHNvIHN1cnJvdW5kZWQgYnkgcGFyZW5zLlxuICAgICAgICBiZWdpbjogJ1xcXFxiKD8hZnVuY3Rpb24pJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArXG4gICAgICAgICAgJ1xcXFwoJyArIC8vIGZpcnN0IHBhcmVuc1xuICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICAgJ1teKCldKicgK1xuICAgICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICdcXFxcKVxcXFxzKlxcXFx7JywgLy8gZW5kIHBhcmVuc1xuICAgICAgICByZXR1cm5CZWdpbjp0cnVlLFxuICAgICAgICBsYWJlbDogXCJmdW5jLmRlZlwiLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFBBUkFNUyxcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7IGJlZ2luOiBJREVOVF9SRSQxLCBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIiB9KVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gY2F0Y2ggLi4uIHNvIGl0IHdvbid0IHRyaWdnZXIgdGhlIHByb3BlcnR5IHJ1bGUgYmVsb3dcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IC9cXC5cXC5cXC4vLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBQUk9QRVJUWV9BQ0NFU1MsXG4gICAgICAvLyBoYWNrOiBwcmV2ZW50cyBkZXRlY3Rpb24gb2Yga2V5d29yZHMgaW4gc29tZSBjaXJjdW1zdGFuY2VzXG4gICAgICAvLyAua2V5d29yZCgpXG4gICAgICAvLyAka2V5d29yZCA9IHhcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6ICdcXFxcJCcgKyBJREVOVF9SRSQxLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbIC9cXGJjb25zdHJ1Y3Rvcig/PVxccypcXCgpLyBdLFxuICAgICAgICBjbGFzc05hbWU6IHsgMTogXCJ0aXRsZS5mdW5jdGlvblwiIH0sXG4gICAgICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fQ0FMTCxcbiAgICAgIFVQUEVSX0NBU0VfQ09OU1RBTlQsXG4gICAgICBDTEFTU19PUl9FWFRFTkRTLFxuICAgICAgR0VUVEVSX09SX1NFVFRFUixcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IC9cXCRbKC5dLyAvLyByZWxldmFuY2UgYm9vc3RlciBmb3IgYSBwYXR0ZXJuIGNvbW1vbiB0byBKUyBsaWJzOiBgJChzb21ldGhpbmcpYCBhbmQgYCQuc29tZXRoaW5nYFxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxudmFyIGphdmFzY3JpcHRfMSA9IGphdmFzY3JpcHQ7XG5cbi8qXG5MYW5ndWFnZTogUHl0aG9uXG5EZXNjcmlwdGlvbjogUHl0aG9uIGlzIGFuIGludGVycHJldGVkLCBvYmplY3Qtb3JpZW50ZWQsIGhpZ2gtbGV2ZWwgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugd2l0aCBkeW5hbWljIHNlbWFudGljcy5cbldlYnNpdGU6IGh0dHBzOi8vd3d3LnB5dGhvbi5vcmdcbkNhdGVnb3J5OiBjb21tb25cbiovXG5mdW5jdGlvbiBweXRob24oaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIGNvbnN0IElERU5UX1JFID0gL1tcXHB7WElEX1N0YXJ0fV9dXFxwe1hJRF9Db250aW51ZX0qL3U7XG4gIGNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuICAgICdhbmQnLFxuICAgICdhcycsXG4gICAgJ2Fzc2VydCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXdhaXQnLFxuICAgICdicmVhaycsXG4gICAgJ2NsYXNzJyxcbiAgICAnY29udGludWUnLFxuICAgICdkZWYnLFxuICAgICdkZWwnLFxuICAgICdlbGlmJyxcbiAgICAnZWxzZScsXG4gICAgJ2V4Y2VwdCcsXG4gICAgJ2ZpbmFsbHknLFxuICAgICdmb3InLFxuICAgICdmcm9tJyxcbiAgICAnZ2xvYmFsJyxcbiAgICAnaWYnLFxuICAgICdpbXBvcnQnLFxuICAgICdpbicsXG4gICAgJ2lzJyxcbiAgICAnbGFtYmRhJyxcbiAgICAnbm9ubG9jYWx8MTAnLFxuICAgICdub3QnLFxuICAgICdvcicsXG4gICAgJ3Bhc3MnLFxuICAgICdyYWlzZScsXG4gICAgJ3JldHVybicsXG4gICAgJ3RyeScsXG4gICAgJ3doaWxlJyxcbiAgICAnd2l0aCcsXG4gICAgJ3lpZWxkJ1xuICBdO1xuXG4gIGNvbnN0IEJVSUxUX0lOUyA9IFtcbiAgICAnX19pbXBvcnRfXycsXG4gICAgJ2FicycsXG4gICAgJ2FsbCcsXG4gICAgJ2FueScsXG4gICAgJ2FzY2lpJyxcbiAgICAnYmluJyxcbiAgICAnYm9vbCcsXG4gICAgJ2JyZWFrcG9pbnQnLFxuICAgICdieXRlYXJyYXknLFxuICAgICdieXRlcycsXG4gICAgJ2NhbGxhYmxlJyxcbiAgICAnY2hyJyxcbiAgICAnY2xhc3NtZXRob2QnLFxuICAgICdjb21waWxlJyxcbiAgICAnY29tcGxleCcsXG4gICAgJ2RlbGF0dHInLFxuICAgICdkaWN0JyxcbiAgICAnZGlyJyxcbiAgICAnZGl2bW9kJyxcbiAgICAnZW51bWVyYXRlJyxcbiAgICAnZXZhbCcsXG4gICAgJ2V4ZWMnLFxuICAgICdmaWx0ZXInLFxuICAgICdmbG9hdCcsXG4gICAgJ2Zvcm1hdCcsXG4gICAgJ2Zyb3plbnNldCcsXG4gICAgJ2dldGF0dHInLFxuICAgICdnbG9iYWxzJyxcbiAgICAnaGFzYXR0cicsXG4gICAgJ2hhc2gnLFxuICAgICdoZWxwJyxcbiAgICAnaGV4JyxcbiAgICAnaWQnLFxuICAgICdpbnB1dCcsXG4gICAgJ2ludCcsXG4gICAgJ2lzaW5zdGFuY2UnLFxuICAgICdpc3N1YmNsYXNzJyxcbiAgICAnaXRlcicsXG4gICAgJ2xlbicsXG4gICAgJ2xpc3QnLFxuICAgICdsb2NhbHMnLFxuICAgICdtYXAnLFxuICAgICdtYXgnLFxuICAgICdtZW1vcnl2aWV3JyxcbiAgICAnbWluJyxcbiAgICAnbmV4dCcsXG4gICAgJ29iamVjdCcsXG4gICAgJ29jdCcsXG4gICAgJ29wZW4nLFxuICAgICdvcmQnLFxuICAgICdwb3cnLFxuICAgICdwcmludCcsXG4gICAgJ3Byb3BlcnR5JyxcbiAgICAncmFuZ2UnLFxuICAgICdyZXByJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdyb3VuZCcsXG4gICAgJ3NldCcsXG4gICAgJ3NldGF0dHInLFxuICAgICdzbGljZScsXG4gICAgJ3NvcnRlZCcsXG4gICAgJ3N0YXRpY21ldGhvZCcsXG4gICAgJ3N0cicsXG4gICAgJ3N1bScsXG4gICAgJ3N1cGVyJyxcbiAgICAndHVwbGUnLFxuICAgICd0eXBlJyxcbiAgICAndmFycycsXG4gICAgJ3ppcCdcbiAgXTtcblxuICBjb25zdCBMSVRFUkFMUyA9IFtcbiAgICAnX19kZWJ1Z19fJyxcbiAgICAnRWxsaXBzaXMnLFxuICAgICdGYWxzZScsXG4gICAgJ05vbmUnLFxuICAgICdOb3RJbXBsZW1lbnRlZCcsXG4gICAgJ1RydWUnXG4gIF07XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3R5cGluZy5odG1sXG4gIC8vIFRPRE86IENvdWxkIHRoZXNlIGJlIHN1cHBsZW1lbnRlZCBieSBhIENhbWVsQ2FzZSBtYXRjaGVyIGluIGNlcnRhaW5cbiAgLy8gY29udGV4dHMsIGxlYXZpbmcgdGhlc2UgcmVtYWluaW5nIG9ubHkgZm9yIHJlbGV2YW5jZSBoaW50aW5nP1xuICBjb25zdCBUWVBFUyA9IFtcbiAgICBcIkFueVwiLFxuICAgIFwiQ2FsbGFibGVcIixcbiAgICBcIkNvcm91dGluZVwiLFxuICAgIFwiRGljdFwiLFxuICAgIFwiTGlzdFwiLFxuICAgIFwiTGl0ZXJhbFwiLFxuICAgIFwiR2VuZXJpY1wiLFxuICAgIFwiT3B0aW9uYWxcIixcbiAgICBcIlNlcXVlbmNlXCIsXG4gICAgXCJTZXRcIixcbiAgICBcIlR1cGxlXCIsXG4gICAgXCJUeXBlXCIsXG4gICAgXCJVbmlvblwiXG4gIF07XG5cbiAgY29uc3QgS0VZV09SRFMgPSB7XG4gICAgJHBhdHRlcm46IC9bQS1aYS16XVxcdyt8X19cXHcrX18vLFxuICAgIGtleXdvcmQ6IFJFU0VSVkVEX1dPUkRTLFxuICAgIGJ1aWx0X2luOiBCVUlMVF9JTlMsXG4gICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgdHlwZTogVFlQRVNcbiAgfTtcblxuICBjb25zdCBQUk9NUFQgPSB7XG4gICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgYmVnaW46IC9eKD4+PnxcXC5cXC5cXC4pIC9cbiAgfTtcblxuICBjb25zdCBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46IC9cXHsvLFxuICAgIGVuZDogL1xcfS8sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC8jL1xuICB9O1xuXG4gIGNvbnN0IExJVEVSQUxfQlJBQ0tFVCA9IHtcbiAgICBiZWdpbjogL1xce1xcey8sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgY29udGFpbnM6IFsgaGxqcy5CQUNLU0xBU0hfRVNDQVBFIF0sXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW3VVXXxbYkJdfFtyUl18W2JCXVtyUl18W3JSXVtiQl0pPycnJy8sXG4gICAgICAgIGVuZDogLycnJy8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICAgIFBST01QVFxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLyhbdVVdfFtiQl18W3JSXXxbYkJdW3JSXXxbclJdW2JCXSk/XCJcIlwiLyxcbiAgICAgICAgZW5kOiAvXCJcIlwiLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgICAgUFJPTVBUXG4gICAgICAgIF0sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtmRl1bclJdfFtyUl1bZkZdfFtmRl0pJycnLyxcbiAgICAgICAgZW5kOiAvJycnLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgICAgUFJPTVBULFxuICAgICAgICAgIExJVEVSQUxfQlJBQ0tFVCxcbiAgICAgICAgICBTVUJTVFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLyhbZkZdW3JSXXxbclJdW2ZGXXxbZkZdKVwiXCJcIi8sXG4gICAgICAgIGVuZDogL1wiXCJcIi8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICAgIFBST01QVCxcbiAgICAgICAgICBMSVRFUkFMX0JSQUNLRVQsXG4gICAgICAgICAgU1VCU1RcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW3VVXXxbclJdKScvLFxuICAgICAgICBlbmQ6IC8nLyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW3VVXXxbclJdKVwiLyxcbiAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLyhbYkJdfFtiQl1bclJdfFtyUl1bYkJdKScvLFxuICAgICAgICBlbmQ6IC8nL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW2JCXXxbYkJdW3JSXXxbclJdW2JCXSlcIi8sXG4gICAgICAgIGVuZDogL1wiL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW2ZGXVtyUl18W3JSXVtmRl18W2ZGXSknLyxcbiAgICAgICAgZW5kOiAvJy8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICAgIExJVEVSQUxfQlJBQ0tFVCxcbiAgICAgICAgICBTVUJTVFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLyhbZkZdW3JSXXxbclJdW2ZGXXxbZkZdKVwiLyxcbiAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgICBMSVRFUkFMX0JSQUNLRVQsXG4gICAgICAgICAgU1VCU1RcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICBdXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkaWdpdHBhcnQgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgcG9pbnRmbG9hdCA9IGAoXFxcXGIoJHtkaWdpdHBhcnR9KSk/XFxcXC4oJHtkaWdpdHBhcnR9KXxcXFxcYigke2RpZ2l0cGFydH0pXFxcXC5gO1xuICAvLyBXaGl0ZXNwYWNlIGFmdGVyIGEgbnVtYmVyIChvciBhbnkgbGV4aWNhbCB0b2tlbikgaXMgbmVlZGVkIG9ubHkgaWYgaXRzIGFic2VuY2VcbiAgLy8gd291bGQgY2hhbmdlIHRoZSB0b2tlbml6YXRpb25cbiAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjd2hpdGVzcGFjZS1iZXR3ZWVuLXRva2Vuc1xuICAvLyBXZSBkZXZpYXRlIHNsaWdodGx5LCByZXF1aXJpbmcgYSB3b3JkIGJvdW5kYXJ5IG9yIGEga2V5d29yZFxuICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcmVjb2duaXppbmcgKnByZWZpeGVzKiAoZS5nLiwgYDBgIGluIGAweDQxYCBvciBgMDhgIG9yIGAwX18xYClcbiAgY29uc3QgbG9va2FoZWFkID0gYFxcXFxifCR7UkVTRVJWRURfV09SRFMuam9pbignfCcpfWA7XG4gIGNvbnN0IE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gZXhwb25lbnRmbG9hdCwgcG9pbnRmbG9hdFxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjZmxvYXRpbmctcG9pbnQtbGl0ZXJhbHNcbiAgICAgIC8vIG9wdGlvbmFsbHkgaW1hZ2luYXJ5XG4gICAgICAvLyBodHRwczovL2RvY3MucHl0aG9uLm9yZy8zLjkvcmVmZXJlbmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNpbWFnaW5hcnktbGl0ZXJhbHNcbiAgICAgIC8vIE5vdGU6IG5vIGxlYWRpbmcgXFxiIGJlY2F1c2UgZmxvYXRzIGNhbiBzdGFydCB3aXRoIGEgZGVjaW1hbCBwb2ludFxuICAgICAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gbWlzaGFuZGxlIGUuZy4gYGZuKC41KWAsXG4gICAgICAvLyBubyB0cmFpbGluZyBcXGIgZm9yIHBvaW50ZmxvYXQgYmVjYXVzZSBpdCBjYW4gZW5kIHdpdGggYSBkZWNpbWFsIHBvaW50XG4gICAgICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtaXNoYW5kbGUgZS5nLiBgMC4uaGV4KClgOyB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAvLyBiZWNhdXNlIGJvdGggTVVTVCBjb250YWluIGEgZGVjaW1hbCBwb2ludCBhbmQgc28gY2Fubm90IGJlIGNvbmZ1c2VkIHdpdGhcbiAgICAgIC8vIHRoZSBpbnRlcmlvciBwYXJ0IG9mIGFuIGlkZW50aWZpZXJcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGAoXFxcXGIoJHtkaWdpdHBhcnR9KXwoJHtwb2ludGZsb2F0fSkpW2VFXVsrLV0/KCR7ZGlnaXRwYXJ0fSlbakpdPyg/PSR7bG9va2FoZWFkfSlgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogYCgke3BvaW50ZmxvYXR9KVtqSl0/YFxuICAgICAgfSxcblxuICAgICAgLy8gZGVjaW50ZWdlciwgYmluaW50ZWdlciwgb2N0aW50ZWdlciwgaGV4aW50ZWdlclxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjaW50ZWdlci1saXRlcmFsc1xuICAgICAgLy8gb3B0aW9uYWxseSBcImxvbmdcIiBpbiBQeXRob24gMlxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi43L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjaW50ZWdlci1hbmQtbG9uZy1pbnRlZ2VyLWxpdGVyYWxzXG4gICAgICAvLyBkZWNpbnRlZ2VyIGlzIG9wdGlvbmFsbHkgaW1hZ2luYXJ5XG4gICAgICAvLyBodHRwczovL2RvY3MucHl0aG9uLm9yZy8zLjkvcmVmZXJlbmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNpbWFnaW5hcnktbGl0ZXJhbHNcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGBcXFxcYihbMS05XShfP1swLTldKSp8MCsoXz8wKSopW2xMakpdPyg/PSR7bG9va2FoZWFkfSlgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogYFxcXFxiMFtiQl0oXz9bMDFdKStbbExdPyg/PSR7bG9va2FoZWFkfSlgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogYFxcXFxiMFtvT10oXz9bMC03XSkrW2xMXT8oPz0ke2xvb2thaGVhZH0pYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGBcXFxcYjBbeFhdKF8/WzAtOWEtZkEtRl0pK1tsTF0/KD89JHtsb29rYWhlYWR9KWBcbiAgICAgIH0sXG5cbiAgICAgIC8vIGltYWdudW1iZXIgKGRpZ2l0cGFydC1iYXNlZClcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMuOS9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNpcy5odG1sI2ltYWdpbmFyeS1saXRlcmFsc1xuICAgICAge1xuICAgICAgICBiZWdpbjogYFxcXFxiKCR7ZGlnaXRwYXJ0fSlbakpdKD89JHtsb29rYWhlYWR9KWBcbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IENPTU1FTlRfVFlQRSA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29tbWVudFwiLFxuICAgIGJlZ2luOiByZWdleC5sb29rYWhlYWQoLyMgdHlwZTovKSxcbiAgICBlbmQ6IC8kLyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gcHJldmVudCBrZXl3b3JkcyBmcm9tIGNvbG9yaW5nIGB0eXBlYFxuICAgICAgICBiZWdpbjogLyMgdHlwZTovXG4gICAgICB9LFxuICAgICAgLy8gY29tbWVudCB3aXRoaW4gYSBkYXRhdHlwZSBjb21tZW50IGluY2x1ZGVzIG5vIGtleXdvcmRzXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvIy8sXG4gICAgICAgIGVuZDogL1xcYlxcQi8sXG4gICAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBjb25zdCBQQVJBTVMgPSB7XG4gICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gRXhjbHVkZSBwYXJhbXMgaW4gZnVuY3Rpb25zIHdpdGhvdXQgcGFyYW1zXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJcIixcbiAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgc2tpcDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgUFJPTVBULFxuICAgICAgICAgIE5VTUJFUixcbiAgICAgICAgICBTVFJJTkcsXG4gICAgICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBTVUJTVC5jb250YWlucyA9IFtcbiAgICBTVFJJTkcsXG4gICAgTlVNQkVSLFxuICAgIFBST01QVFxuICBdO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1B5dGhvbicsXG4gICAgYWxpYXNlczogW1xuICAgICAgJ3B5JyxcbiAgICAgICdneXAnLFxuICAgICAgJ2lweXRob24nXG4gICAgXSxcbiAgICB1bmljb2RlUmVnZXg6IHRydWUsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC8oPFxcL3wtPnxcXD8pfD0+LyxcbiAgICBjb250YWluczogW1xuICAgICAgUFJPTVBULFxuICAgICAgTlVNQkVSLFxuICAgICAge1xuICAgICAgICAvLyB2ZXJ5IGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAgIGJlZ2luOiAvXFxic2VsZlxcYi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGVhdCBcImlmXCIgcHJpb3IgdG8gc3RyaW5nIHNvIHRoYXQgaXQgd29uJ3QgYWNjaWRlbnRhbGx5IGJlXG4gICAgICAgIC8vIGxhYmVsZWQgYXMgYW4gZi1zdHJpbmdcbiAgICAgICAgYmVnaW5LZXl3b3JkczogXCJpZlwiLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBTVFJJTkcsXG4gICAgICBDT01NRU5UX1RZUEUsXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9cXGJkZWYvLCAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUsXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgICAgIC9cXGJjbGFzcy8sIC9cXHMrLyxcbiAgICAgICAgICAgICAgSURFTlRfUkUsIC9cXHMqLyxcbiAgICAgICAgICAgICAgL1xcKFxccyovLCBJREVOVF9SRSwvXFxzKlxcKS9cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXRjaDogW1xuICAgICAgICAgICAgICAvXFxiY2xhc3MvLCAvXFxzKy8sXG4gICAgICAgICAgICAgIElERU5UX1JFXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgICAgICAzOiBcInRpdGxlLmNsYXNzXCIsXG4gICAgICAgICAgNjogXCJ0aXRsZS5jbGFzcy5pbmhlcml0ZWRcIixcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXltcXHQgXSpALyxcbiAgICAgICAgZW5kOiAvKD89Iyl8JC8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgTlVNQkVSLFxuICAgICAgICAgIFBBUkFNUyxcbiAgICAgICAgICBTVFJJTkdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxudmFyIHB5dGhvbl8xID0gcHl0aG9uO1xuXG4vLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTUvaHRtbC9qbHMtMy5odG1sI2pscy0zLjEwXG52YXIgZGVjaW1hbERpZ2l0cyA9ICdbMC05XShfKlswLTldKSonO1xudmFyIGZyYWMgPSBgXFxcXC4oJHtkZWNpbWFsRGlnaXRzfSlgO1xudmFyIGhleERpZ2l0cyA9ICdbMC05YS1mQS1GXShfKlswLTlhLWZBLUZdKSonO1xudmFyIE5VTUVSSUMgPSB7XG4gIGNsYXNzTmFtZTogJ251bWJlcicsXG4gIHZhcmlhbnRzOiBbXG4gICAgLy8gRGVjaW1hbEZsb2F0aW5nUG9pbnRMaXRlcmFsXG4gICAgLy8gaW5jbHVkaW5nIEV4cG9uZW50UGFydFxuICAgIHsgYmVnaW46IGAoXFxcXGIoJHtkZWNpbWFsRGlnaXRzfSkoKCR7ZnJhY30pfFxcXFwuKT98KCR7ZnJhY30pKWAgK1xuICAgICAgYFtlRV1bKy1dPygke2RlY2ltYWxEaWdpdHN9KVtmRmREXT9cXFxcYmAgfSxcbiAgICAvLyBleGNsdWRpbmcgRXhwb25lbnRQYXJ0XG4gICAgeyBiZWdpbjogYFxcXFxiKCR7ZGVjaW1hbERpZ2l0c30pKCgke2ZyYWN9KVtmRmREXT9cXFxcYnxcXFxcLihbZkZkRF1cXFxcYik/KWAgfSxcbiAgICB7IGJlZ2luOiBgKCR7ZnJhY30pW2ZGZERdP1xcXFxiYCB9LFxuICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxEaWdpdHN9KVtmRmREXVxcXFxiYCB9LFxuXG4gICAgLy8gSGV4YWRlY2ltYWxGbG9hdGluZ1BvaW50TGl0ZXJhbFxuICAgIHsgYmVnaW46IGBcXFxcYjBbeFhdKCgke2hleERpZ2l0c30pXFxcXC4/fCgke2hleERpZ2l0c30pP1xcXFwuKCR7aGV4RGlnaXRzfSkpYCArXG4gICAgICBgW3BQXVsrLV0/KCR7ZGVjaW1hbERpZ2l0c30pW2ZGZERdP1xcXFxiYCB9LFxuXG4gICAgLy8gRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gICAgeyBiZWdpbjogJ1xcXFxiKDB8WzEtOV0oXypbMC05XSkqKVtsTF0/XFxcXGInIH0sXG5cbiAgICAvLyBIZXhJbnRlZ2VyTGl0ZXJhbFxuICAgIHsgYmVnaW46IGBcXFxcYjBbeFhdKCR7aGV4RGlnaXRzfSlbbExdP1xcXFxiYCB9LFxuXG4gICAgLy8gT2N0YWxJbnRlZ2VyTGl0ZXJhbFxuICAgIHsgYmVnaW46ICdcXFxcYjAoXypbMC03XSkqW2xMXT9cXFxcYicgfSxcblxuICAgIC8vIEJpbmFyeUludGVnZXJMaXRlcmFsXG4gICAgeyBiZWdpbjogJ1xcXFxiMFtiQl1bMDFdKF8qWzAxXSkqW2xMXT9cXFxcYicgfSxcbiAgXSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuXG4vKlxuTGFuZ3VhZ2U6IEphdmFcbkF1dGhvcjogVnNldm9sb2QgU29sb3Z5b3YgPHZzZXZvbG9kLnNvbG92eW92QGdtYWlsLmNvbT5cbkNhdGVnb3J5OiBjb21tb24sIGVudGVycHJpc2VcbldlYnNpdGU6IGh0dHBzOi8vd3d3LmphdmEuY29tL1xuKi9cblxuLyoqXG4gKiBBbGxvd3MgcmVjdXJzaXZlIHJlZ2V4IGV4cHJlc3Npb25zIHRvIGEgZ2l2ZW4gZGVwdGhcbiAqXG4gKiBpZTogcmVjdXJSZWdleChcIihhYmN+fn4pXCIsIC9+fn4vZywgMikgYmVjb21lczpcbiAqIChhYmMoYWJjKGFiYykpKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZVxuICogQHBhcmFtIHtSZWdFeHB9IHN1YnN0aXR1dGlvbiAoc2hvdWxkIGJlIGEgZyBtb2RlIHJlZ2V4KVxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfWBgXG4gKi9cbmZ1bmN0aW9uIHJlY3VyUmVnZXgocmUsIHN1YnN0aXR1dGlvbiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09PSAtMSkgcmV0dXJuIFwiXCI7XG5cbiAgcmV0dXJuIHJlLnJlcGxhY2Uoc3Vic3RpdHV0aW9uLCBfID0+IHtcbiAgICByZXR1cm4gcmVjdXJSZWdleChyZSwgc3Vic3RpdHV0aW9uLCBkZXB0aCAtIDEpO1xuICB9KTtcbn1cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmEoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIGNvbnN0IEpBVkFfSURFTlRfUkUgPSAnW1xcdTAwQzAtXFx1MDJCOGEtekEtWl8kXVtcXHUwMEMwLVxcdTAyQjhhLXpBLVpfJDAtOV0qJztcbiAgY29uc3QgR0VORVJJQ19JREVOVF9SRSA9IEpBVkFfSURFTlRfUkVcbiAgICArIHJlY3VyUmVnZXgoJyg/OjwnICsgSkFWQV9JREVOVF9SRSArICd+fn4oPzpcXFxccyosXFxcXHMqJyArIEpBVkFfSURFTlRfUkUgKyAnfn5+KSo+KT8nLCAvfn5+L2csIDIpO1xuICBjb25zdCBNQUlOX0tFWVdPUkRTID0gW1xuICAgICdzeW5jaHJvbml6ZWQnLFxuICAgICdhYnN0cmFjdCcsXG4gICAgJ3ByaXZhdGUnLFxuICAgICd2YXInLFxuICAgICdzdGF0aWMnLFxuICAgICdpZicsXG4gICAgJ2NvbnN0ICcsXG4gICAgJ2ZvcicsXG4gICAgJ3doaWxlJyxcbiAgICAnc3RyaWN0ZnAnLFxuICAgICdmaW5hbGx5JyxcbiAgICAncHJvdGVjdGVkJyxcbiAgICAnaW1wb3J0JyxcbiAgICAnbmF0aXZlJyxcbiAgICAnZmluYWwnLFxuICAgICd2b2lkJyxcbiAgICAnZW51bScsXG4gICAgJ2Vsc2UnLFxuICAgICdicmVhaycsXG4gICAgJ3RyYW5zaWVudCcsXG4gICAgJ2NhdGNoJyxcbiAgICAnaW5zdGFuY2VvZicsXG4gICAgJ3ZvbGF0aWxlJyxcbiAgICAnY2FzZScsXG4gICAgJ2Fzc2VydCcsXG4gICAgJ3BhY2thZ2UnLFxuICAgICdkZWZhdWx0JyxcbiAgICAncHVibGljJyxcbiAgICAndHJ5JyxcbiAgICAnc3dpdGNoJyxcbiAgICAnY29udGludWUnLFxuICAgICd0aHJvd3MnLFxuICAgICdwcm90ZWN0ZWQnLFxuICAgICdwdWJsaWMnLFxuICAgICdwcml2YXRlJyxcbiAgICAnbW9kdWxlJyxcbiAgICAncmVxdWlyZXMnLFxuICAgICdleHBvcnRzJyxcbiAgICAnZG8nLFxuICAgICdzZWFsZWQnXG4gIF07XG5cbiAgY29uc3QgQlVJTFRfSU5TID0gW1xuICAgICdzdXBlcicsXG4gICAgJ3RoaXMnXG4gIF07XG5cbiAgY29uc3QgTElURVJBTFMgPSBbXG4gICAgJ2ZhbHNlJyxcbiAgICAndHJ1ZScsXG4gICAgJ251bGwnXG4gIF07XG5cbiAgY29uc3QgVFlQRVMgPSBbXG4gICAgJ2NoYXInLFxuICAgICdib29sZWFuJyxcbiAgICAnbG9uZycsXG4gICAgJ2Zsb2F0JyxcbiAgICAnaW50JyxcbiAgICAnYnl0ZScsXG4gICAgJ3Nob3J0JyxcbiAgICAnZG91YmxlJ1xuICBdO1xuXG4gIGNvbnN0IEtFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6IE1BSU5fS0VZV09SRFMsXG4gICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgdHlwZTogVFlQRVMsXG4gICAgYnVpbHRfaW46IEJVSUxUX0lOU1xuICB9O1xuXG4gIGNvbnN0IEFOTk9UQVRJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgYmVnaW46ICdAJyArIEpBVkFfSURFTlRfUkUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICBjb250YWluczogWyBcInNlbGZcIiBdIC8vIGFsbG93IG5lc3RlZCAoKSBpbnNpZGUgb3VyIGFubm90YXRpb25cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IFBBUkFNUyA9IHtcbiAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgY29udGFpbnM6IFsgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSBdLFxuICAgIGVuZHNQYXJlbnQ6IHRydWVcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdKYXZhJyxcbiAgICBhbGlhc2VzOiBbICdqc3AnIF0sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC88XFwvfCMvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgICcvXFxcXCpcXFxcKicsXG4gICAgICAgICdcXFxcKi8nLFxuICAgICAgICB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIGVhdCB1cCBAJ3MgaW4gZW1haWxzIHRvIHByZXZlbnQgdGhlbSB0byBiZSByZWNvZ25pemVkIGFzIGRvY3RhZ3NcbiAgICAgICAgICAgICAgYmVnaW46IC9cXHcrQC8sXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdAW0EtWmEtel0rJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8vIHJlbGV2YW5jZSBib29zdFxuICAgICAge1xuICAgICAgICBiZWdpbjogL2ltcG9ydCBqYXZhXFwuW2Etel0rXFwuLyxcbiAgICAgICAga2V5d29yZHM6IFwiaW1wb3J0XCIsXG4gICAgICAgIHJlbGV2YW5jZTogMlxuICAgICAgfSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXCJcIlwiLyxcbiAgICAgICAgZW5kOiAvXCJcIlwiLyxcbiAgICAgICAgY2xhc3NOYW1lOiBcInN0cmluZ1wiLFxuICAgICAgICBjb250YWluczogWyBobGpzLkJBQ0tTTEFTSF9FU0NBUEUgXVxuICAgICAgfSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL1xcYig/OmNsYXNzfGludGVyZmFjZXxlbnVtfGV4dGVuZHN8aW1wbGVtZW50c3xuZXcpLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSkFWQV9JREVOVF9SRVxuICAgICAgICBdLFxuICAgICAgICBjbGFzc05hbWU6IHtcbiAgICAgICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgICAgICAzOiBcInRpdGxlLmNsYXNzXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gRXhjZXB0aW9ucyBmb3IgaHlwaGVuYXRlZCBrZXl3b3Jkc1xuICAgICAgICBtYXRjaDogL25vbi1zZWFsZWQvLFxuICAgICAgICBzY29wZTogXCJrZXl3b3JkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiBbXG4gICAgICAgICAgcmVnZXguY29uY2F0KC8oPyFlbHNlKS8sIEpBVkFfSURFTlRfUkUpLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBKQVZBX0lERU5UX1JFLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICAvPS9cbiAgICAgICAgXSxcbiAgICAgICAgY2xhc3NOYW1lOiB7XG4gICAgICAgICAgMTogXCJ0eXBlXCIsXG4gICAgICAgICAgMzogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgIDU6IFwib3BlcmF0b3JcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogW1xuICAgICAgICAgIC9yZWNvcmQvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBKQVZBX0lERU5UX1JFXG4gICAgICAgIF0sXG4gICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgICAgIDM6IFwidGl0bGUuY2xhc3NcIlxuICAgICAgICB9LFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFBBUkFNUyxcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBFeHByZXNzaW9uIGtleXdvcmRzIHByZXZlbnQgJ2tleXdvcmQgTmFtZSguLi4pJyBmcm9tIGJlaW5nXG4gICAgICAgIC8vIHJlY29nbml6ZWQgYXMgYSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICduZXcgdGhyb3cgcmV0dXJuIGVsc2UnLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiBbXG4gICAgICAgICAgJyg/OicgKyBHRU5FUklDX0lERU5UX1JFICsgJ1xcXFxzKyknLFxuICAgICAgICAgIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICAgICAgICAvXFxzKig/PVxcKCkvXG4gICAgICAgIF0sXG4gICAgICAgIGNsYXNzTmFtZTogeyAyOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSxcbiAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgQU5OT1RBVElPTixcbiAgICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgICBOVU1FUklDLFxuICAgICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgTlVNRVJJQyxcbiAgICAgIEFOTk9UQVRJT05cbiAgICBdXG4gIH07XG59XG5cbnZhciBqYXZhXzEgPSBqYXZhO1xuXG4vKlxuIExhbmd1YWdlOiBTUUxcbiBXZWJzaXRlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUUxcbiBDYXRlZ29yeTogY29tbW9uLCBkYXRhYmFzZVxuICovXG4vKlxuXG5Hb2FsczpcblxuU1FMIGlzIGludGVuZGVkIHRvIGhpZ2hsaWdodCBiYXNpYy9jb21tb24gU1FMIGtleXdvcmRzIGFuZCBleHByZXNzaW9uc1xuXG4tIElmIHByZXR0eSBtdWNoIGV2ZXJ5IHNpbmdsZSBTUUwgc2VydmVyIGluY2x1ZGVzIHN1cHBvcnRzLCB0aGVuIGl0J3MgYSBjYW5pZGF0ZS5cbi0gSXQgaXMgTk9UIGludGVuZGVkIHRvIGluY2x1ZGUgdG9ucyBvZiB2ZW5kb3Igc3BlY2lmaWMga2V5d29yZHMgKE9yYWNsZSwgTXlTUUwsXG4gIFBvc3RncmVTUUwpIGFsdGhvdWdoIHRoZSBsaXN0IG9mIGRhdGEgdHlwZXMgaXMgcHVycG9zZWx5IGEgYml0IG1vcmUgZXhwYW5zaXZlLlxuLSBGb3IgbW9yZSBzcGVjaWZpYyBTUUwgZ3JhbW1hcnMgcGxlYXNlIHNlZTpcbiAgLSBQb3N0Z3JlU1FMIGFuZCBQTC9wZ1NRTCAtIGNvcmVcbiAgLSBULVNRTCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHRqcy10c3FsXG4gIC0gc3FsX21vcmUgKGNvcmUpXG5cbiAqL1xuXG5mdW5jdGlvbiBzcWwoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIGNvbnN0IENPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnLS0nLCAnJCcpO1xuICBjb25zdCBTVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICBlbmQ6IC8nLyxcbiAgICAgICAgY29udGFpbnM6IFsgeyBiZWdpbjogLycnLyB9IF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IFFVT1RFRF9JREVOVElGSUVSID0ge1xuICAgIGJlZ2luOiAvXCIvLFxuICAgIGVuZDogL1wiLyxcbiAgICBjb250YWluczogWyB7IGJlZ2luOiAvXCJcIi8gfSBdXG4gIH07XG5cbiAgY29uc3QgTElURVJBTFMgPSBbXG4gICAgXCJ0cnVlXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIC8vIE5vdCBzdXJlIGl0J3MgY29ycmVjdCB0byBjYWxsIE5VTEwgbGl0ZXJhbCwgYW5kIGNsYXVzZXMgbGlrZSBJUyBbTk9UXSBOVUxMIGxvb2sgc3RyYW5nZSB0aGF0IHdheS5cbiAgICAvLyBcIm51bGxcIixcbiAgICBcInVua25vd25cIlxuICBdO1xuXG4gIGNvbnN0IE1VTFRJX1dPUkRfVFlQRVMgPSBbXG4gICAgXCJkb3VibGUgcHJlY2lzaW9uXCIsXG4gICAgXCJsYXJnZSBvYmplY3RcIixcbiAgICBcIndpdGggdGltZXpvbmVcIixcbiAgICBcIndpdGhvdXQgdGltZXpvbmVcIlxuICBdO1xuXG4gIGNvbnN0IFRZUEVTID0gW1xuICAgICdiaWdpbnQnLFxuICAgICdiaW5hcnknLFxuICAgICdibG9iJyxcbiAgICAnYm9vbGVhbicsXG4gICAgJ2NoYXInLFxuICAgICdjaGFyYWN0ZXInLFxuICAgICdjbG9iJyxcbiAgICAnZGF0ZScsXG4gICAgJ2RlYycsXG4gICAgJ2RlY2Zsb2F0JyxcbiAgICAnZGVjaW1hbCcsXG4gICAgJ2Zsb2F0JyxcbiAgICAnaW50JyxcbiAgICAnaW50ZWdlcicsXG4gICAgJ2ludGVydmFsJyxcbiAgICAnbmNoYXInLFxuICAgICduY2xvYicsXG4gICAgJ25hdGlvbmFsJyxcbiAgICAnbnVtZXJpYycsXG4gICAgJ3JlYWwnLFxuICAgICdyb3cnLFxuICAgICdzbWFsbGludCcsXG4gICAgJ3RpbWUnLFxuICAgICd0aW1lc3RhbXAnLFxuICAgICd2YXJjaGFyJyxcbiAgICAndmFyeWluZycsIC8vIG1vZGlmaWVyIChjaGFyYWN0ZXIgdmFyeWluZylcbiAgICAndmFyYmluYXJ5J1xuICBdO1xuXG4gIGNvbnN0IE5PTl9SRVNFUlZFRF9XT1JEUyA9IFtcbiAgICBcImFkZFwiLFxuICAgIFwiYXNjXCIsXG4gICAgXCJjb2xsYXRpb25cIixcbiAgICBcImRlc2NcIixcbiAgICBcImZpbmFsXCIsXG4gICAgXCJmaXJzdFwiLFxuICAgIFwibGFzdFwiLFxuICAgIFwidmlld1wiXG4gIF07XG5cbiAgLy8gaHR0cHM6Ly9qYWtld2hlYXQuZ2l0aHViLmlvL3NxbC1vdmVydmlldy9zcWwtMjAxNi1mb3VuZGF0aW9uLWdyYW1tYXIuaHRtbCNyZXNlcnZlZC13b3JkXG4gIGNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuICAgIFwiYWJzXCIsXG4gICAgXCJhY29zXCIsXG4gICAgXCJhbGxcIixcbiAgICBcImFsbG9jYXRlXCIsXG4gICAgXCJhbHRlclwiLFxuICAgIFwiYW5kXCIsXG4gICAgXCJhbnlcIixcbiAgICBcImFyZVwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcImFycmF5X2FnZ1wiLFxuICAgIFwiYXJyYXlfbWF4X2NhcmRpbmFsaXR5XCIsXG4gICAgXCJhc1wiLFxuICAgIFwiYXNlbnNpdGl2ZVwiLFxuICAgIFwiYXNpblwiLFxuICAgIFwiYXN5bW1ldHJpY1wiLFxuICAgIFwiYXRcIixcbiAgICBcImF0YW5cIixcbiAgICBcImF0b21pY1wiLFxuICAgIFwiYXV0aG9yaXphdGlvblwiLFxuICAgIFwiYXZnXCIsXG4gICAgXCJiZWdpblwiLFxuICAgIFwiYmVnaW5fZnJhbWVcIixcbiAgICBcImJlZ2luX3BhcnRpdGlvblwiLFxuICAgIFwiYmV0d2VlblwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJiaW5hcnlcIixcbiAgICBcImJsb2JcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImJvdGhcIixcbiAgICBcImJ5XCIsXG4gICAgXCJjYWxsXCIsXG4gICAgXCJjYWxsZWRcIixcbiAgICBcImNhcmRpbmFsaXR5XCIsXG4gICAgXCJjYXNjYWRlZFwiLFxuICAgIFwiY2FzZVwiLFxuICAgIFwiY2FzdFwiLFxuICAgIFwiY2VpbFwiLFxuICAgIFwiY2VpbGluZ1wiLFxuICAgIFwiY2hhclwiLFxuICAgIFwiY2hhcl9sZW5ndGhcIixcbiAgICBcImNoYXJhY3RlclwiLFxuICAgIFwiY2hhcmFjdGVyX2xlbmd0aFwiLFxuICAgIFwiY2hlY2tcIixcbiAgICBcImNsYXNzaWZpZXJcIixcbiAgICBcImNsb2JcIixcbiAgICBcImNsb3NlXCIsXG4gICAgXCJjb2FsZXNjZVwiLFxuICAgIFwiY29sbGF0ZVwiLFxuICAgIFwiY29sbGVjdFwiLFxuICAgIFwiY29sdW1uXCIsXG4gICAgXCJjb21taXRcIixcbiAgICBcImNvbmRpdGlvblwiLFxuICAgIFwiY29ubmVjdFwiLFxuICAgIFwiY29uc3RyYWludFwiLFxuICAgIFwiY29udGFpbnNcIixcbiAgICBcImNvbnZlcnRcIixcbiAgICBcImNvcHlcIixcbiAgICBcImNvcnJcIixcbiAgICBcImNvcnJlc3BvbmRpbmdcIixcbiAgICBcImNvc1wiLFxuICAgIFwiY29zaFwiLFxuICAgIFwiY291bnRcIixcbiAgICBcImNvdmFyX3BvcFwiLFxuICAgIFwiY292YXJfc2FtcFwiLFxuICAgIFwiY3JlYXRlXCIsXG4gICAgXCJjcm9zc1wiLFxuICAgIFwiY3ViZVwiLFxuICAgIFwiY3VtZV9kaXN0XCIsXG4gICAgXCJjdXJyZW50XCIsXG4gICAgXCJjdXJyZW50X2NhdGFsb2dcIixcbiAgICBcImN1cnJlbnRfZGF0ZVwiLFxuICAgIFwiY3VycmVudF9kZWZhdWx0X3RyYW5zZm9ybV9ncm91cFwiLFxuICAgIFwiY3VycmVudF9wYXRoXCIsXG4gICAgXCJjdXJyZW50X3JvbGVcIixcbiAgICBcImN1cnJlbnRfcm93XCIsXG4gICAgXCJjdXJyZW50X3NjaGVtYVwiLFxuICAgIFwiY3VycmVudF90aW1lXCIsXG4gICAgXCJjdXJyZW50X3RpbWVzdGFtcFwiLFxuICAgIFwiY3VycmVudF9wYXRoXCIsXG4gICAgXCJjdXJyZW50X3JvbGVcIixcbiAgICBcImN1cnJlbnRfdHJhbnNmb3JtX2dyb3VwX2Zvcl90eXBlXCIsXG4gICAgXCJjdXJyZW50X3VzZXJcIixcbiAgICBcImN1cnNvclwiLFxuICAgIFwiY3ljbGVcIixcbiAgICBcImRhdGVcIixcbiAgICBcImRheVwiLFxuICAgIFwiZGVhbGxvY2F0ZVwiLFxuICAgIFwiZGVjXCIsXG4gICAgXCJkZWNpbWFsXCIsXG4gICAgXCJkZWNmbG9hdFwiLFxuICAgIFwiZGVjbGFyZVwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcImRlbnNlX3JhbmtcIixcbiAgICBcImRlcmVmXCIsXG4gICAgXCJkZXNjcmliZVwiLFxuICAgIFwiZGV0ZXJtaW5pc3RpY1wiLFxuICAgIFwiZGlzY29ubmVjdFwiLFxuICAgIFwiZGlzdGluY3RcIixcbiAgICBcImRvdWJsZVwiLFxuICAgIFwiZHJvcFwiLFxuICAgIFwiZHluYW1pY1wiLFxuICAgIFwiZWFjaFwiLFxuICAgIFwiZWxlbWVudFwiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZW1wdHlcIixcbiAgICBcImVuZFwiLFxuICAgIFwiZW5kX2ZyYW1lXCIsXG4gICAgXCJlbmRfcGFydGl0aW9uXCIsXG4gICAgXCJlbmQtZXhlY1wiLFxuICAgIFwiZXF1YWxzXCIsXG4gICAgXCJlc2NhcGVcIixcbiAgICBcImV2ZXJ5XCIsXG4gICAgXCJleGNlcHRcIixcbiAgICBcImV4ZWNcIixcbiAgICBcImV4ZWN1dGVcIixcbiAgICBcImV4aXN0c1wiLFxuICAgIFwiZXhwXCIsXG4gICAgXCJleHRlcm5hbFwiLFxuICAgIFwiZXh0cmFjdFwiLFxuICAgIFwiZmFsc2VcIixcbiAgICBcImZldGNoXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcImZpcnN0X3ZhbHVlXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiZmxvb3JcIixcbiAgICBcImZvclwiLFxuICAgIFwiZm9yZWlnblwiLFxuICAgIFwiZnJhbWVfcm93XCIsXG4gICAgXCJmcmVlXCIsXG4gICAgXCJmcm9tXCIsXG4gICAgXCJmdWxsXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiZnVzaW9uXCIsXG4gICAgXCJnZXRcIixcbiAgICBcImdsb2JhbFwiLFxuICAgIFwiZ3JhbnRcIixcbiAgICBcImdyb3VwXCIsXG4gICAgXCJncm91cGluZ1wiLFxuICAgIFwiZ3JvdXBzXCIsXG4gICAgXCJoYXZpbmdcIixcbiAgICBcImhvbGRcIixcbiAgICBcImhvdXJcIixcbiAgICBcImlkZW50aXR5XCIsXG4gICAgXCJpblwiLFxuICAgIFwiaW5kaWNhdG9yXCIsXG4gICAgXCJpbml0aWFsXCIsXG4gICAgXCJpbm5lclwiLFxuICAgIFwiaW5vdXRcIixcbiAgICBcImluc2Vuc2l0aXZlXCIsXG4gICAgXCJpbnNlcnRcIixcbiAgICBcImludFwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiaW50ZXJzZWN0XCIsXG4gICAgXCJpbnRlcnNlY3Rpb25cIixcbiAgICBcImludGVydmFsXCIsXG4gICAgXCJpbnRvXCIsXG4gICAgXCJpc1wiLFxuICAgIFwiam9pblwiLFxuICAgIFwianNvbl9hcnJheVwiLFxuICAgIFwianNvbl9hcnJheWFnZ1wiLFxuICAgIFwianNvbl9leGlzdHNcIixcbiAgICBcImpzb25fb2JqZWN0XCIsXG4gICAgXCJqc29uX29iamVjdGFnZ1wiLFxuICAgIFwianNvbl9xdWVyeVwiLFxuICAgIFwianNvbl90YWJsZVwiLFxuICAgIFwianNvbl90YWJsZV9wcmltaXRpdmVcIixcbiAgICBcImpzb25fdmFsdWVcIixcbiAgICBcImxhZ1wiLFxuICAgIFwibGFuZ3VhZ2VcIixcbiAgICBcImxhcmdlXCIsXG4gICAgXCJsYXN0X3ZhbHVlXCIsXG4gICAgXCJsYXRlcmFsXCIsXG4gICAgXCJsZWFkXCIsXG4gICAgXCJsZWFkaW5nXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJsaWtlXCIsXG4gICAgXCJsaWtlX3JlZ2V4XCIsXG4gICAgXCJsaXN0YWdnXCIsXG4gICAgXCJsblwiLFxuICAgIFwibG9jYWxcIixcbiAgICBcImxvY2FsdGltZVwiLFxuICAgIFwibG9jYWx0aW1lc3RhbXBcIixcbiAgICBcImxvZ1wiLFxuICAgIFwibG9nMTBcIixcbiAgICBcImxvd2VyXCIsXG4gICAgXCJtYXRjaFwiLFxuICAgIFwibWF0Y2hfbnVtYmVyXCIsXG4gICAgXCJtYXRjaF9yZWNvZ25pemVcIixcbiAgICBcIm1hdGNoZXNcIixcbiAgICBcIm1heFwiLFxuICAgIFwibWVtYmVyXCIsXG4gICAgXCJtZXJnZVwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJtaW5cIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwibW9kXCIsXG4gICAgXCJtb2RpZmllc1wiLFxuICAgIFwibW9kdWxlXCIsXG4gICAgXCJtb250aFwiLFxuICAgIFwibXVsdGlzZXRcIixcbiAgICBcIm5hdGlvbmFsXCIsXG4gICAgXCJuYXR1cmFsXCIsXG4gICAgXCJuY2hhclwiLFxuICAgIFwibmNsb2JcIixcbiAgICBcIm5ld1wiLFxuICAgIFwibm9cIixcbiAgICBcIm5vbmVcIixcbiAgICBcIm5vcm1hbGl6ZVwiLFxuICAgIFwibm90XCIsXG4gICAgXCJudGhfdmFsdWVcIixcbiAgICBcIm50aWxlXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJudWxsaWZcIixcbiAgICBcIm51bWVyaWNcIixcbiAgICBcIm9jdGV0X2xlbmd0aFwiLFxuICAgIFwib2NjdXJyZW5jZXNfcmVnZXhcIixcbiAgICBcIm9mXCIsXG4gICAgXCJvZmZzZXRcIixcbiAgICBcIm9sZFwiLFxuICAgIFwib21pdFwiLFxuICAgIFwib25cIixcbiAgICBcIm9uZVwiLFxuICAgIFwib25seVwiLFxuICAgIFwib3BlblwiLFxuICAgIFwib3JcIixcbiAgICBcIm9yZGVyXCIsXG4gICAgXCJvdXRcIixcbiAgICBcIm91dGVyXCIsXG4gICAgXCJvdmVyXCIsXG4gICAgXCJvdmVybGFwc1wiLFxuICAgIFwib3ZlcmxheVwiLFxuICAgIFwicGFyYW1ldGVyXCIsXG4gICAgXCJwYXJ0aXRpb25cIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBlclwiLFxuICAgIFwicGVyY2VudFwiLFxuICAgIFwicGVyY2VudF9yYW5rXCIsXG4gICAgXCJwZXJjZW50aWxlX2NvbnRcIixcbiAgICBcInBlcmNlbnRpbGVfZGlzY1wiLFxuICAgIFwicGVyaW9kXCIsXG4gICAgXCJwb3J0aW9uXCIsXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIFwicG9zaXRpb25fcmVnZXhcIixcbiAgICBcInBvd2VyXCIsXG4gICAgXCJwcmVjZWRlc1wiLFxuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgXCJwcmVwYXJlXCIsXG4gICAgXCJwcmltYXJ5XCIsXG4gICAgXCJwcm9jZWR1cmVcIixcbiAgICBcInB0ZlwiLFxuICAgIFwicmFuZ2VcIixcbiAgICBcInJhbmtcIixcbiAgICBcInJlYWRzXCIsXG4gICAgXCJyZWFsXCIsXG4gICAgXCJyZWN1cnNpdmVcIixcbiAgICBcInJlZlwiLFxuICAgIFwicmVmZXJlbmNlc1wiLFxuICAgIFwicmVmZXJlbmNpbmdcIixcbiAgICBcInJlZ3JfYXZneFwiLFxuICAgIFwicmVncl9hdmd5XCIsXG4gICAgXCJyZWdyX2NvdW50XCIsXG4gICAgXCJyZWdyX2ludGVyY2VwdFwiLFxuICAgIFwicmVncl9yMlwiLFxuICAgIFwicmVncl9zbG9wZVwiLFxuICAgIFwicmVncl9zeHhcIixcbiAgICBcInJlZ3Jfc3h5XCIsXG4gICAgXCJyZWdyX3N5eVwiLFxuICAgIFwicmVsZWFzZVwiLFxuICAgIFwicmVzdWx0XCIsXG4gICAgXCJyZXR1cm5cIixcbiAgICBcInJldHVybnNcIixcbiAgICBcInJldm9rZVwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInJvbGxiYWNrXCIsXG4gICAgXCJyb2xsdXBcIixcbiAgICBcInJvd1wiLFxuICAgIFwicm93X251bWJlclwiLFxuICAgIFwicm93c1wiLFxuICAgIFwicnVubmluZ1wiLFxuICAgIFwic2F2ZXBvaW50XCIsXG4gICAgXCJzY29wZVwiLFxuICAgIFwic2Nyb2xsXCIsXG4gICAgXCJzZWFyY2hcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwic2Vla1wiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJzZW5zaXRpdmVcIixcbiAgICBcInNlc3Npb25fdXNlclwiLFxuICAgIFwic2V0XCIsXG4gICAgXCJzaG93XCIsXG4gICAgXCJzaW1pbGFyXCIsXG4gICAgXCJzaW5cIixcbiAgICBcInNpbmhcIixcbiAgICBcInNraXBcIixcbiAgICBcInNtYWxsaW50XCIsXG4gICAgXCJzb21lXCIsXG4gICAgXCJzcGVjaWZpY1wiLFxuICAgIFwic3BlY2lmaWN0eXBlXCIsXG4gICAgXCJzcWxcIixcbiAgICBcInNxbGV4Y2VwdGlvblwiLFxuICAgIFwic3Fsc3RhdGVcIixcbiAgICBcInNxbHdhcm5pbmdcIixcbiAgICBcInNxcnRcIixcbiAgICBcInN0YXJ0XCIsXG4gICAgXCJzdGF0aWNcIixcbiAgICBcInN0ZGRldl9wb3BcIixcbiAgICBcInN0ZGRldl9zYW1wXCIsXG4gICAgXCJzdWJtdWx0aXNldFwiLFxuICAgIFwic3Vic2V0XCIsXG4gICAgXCJzdWJzdHJpbmdcIixcbiAgICBcInN1YnN0cmluZ19yZWdleFwiLFxuICAgIFwic3VjY2VlZHNcIixcbiAgICBcInN1bVwiLFxuICAgIFwic3ltbWV0cmljXCIsXG4gICAgXCJzeXN0ZW1cIixcbiAgICBcInN5c3RlbV90aW1lXCIsXG4gICAgXCJzeXN0ZW1fdXNlclwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRhYmxlc2FtcGxlXCIsXG4gICAgXCJ0YW5cIixcbiAgICBcInRhbmhcIixcbiAgICBcInRoZW5cIixcbiAgICBcInRpbWVcIixcbiAgICBcInRpbWVzdGFtcFwiLFxuICAgIFwidGltZXpvbmVfaG91clwiLFxuICAgIFwidGltZXpvbmVfbWludXRlXCIsXG4gICAgXCJ0b1wiLFxuICAgIFwidHJhaWxpbmdcIixcbiAgICBcInRyYW5zbGF0ZVwiLFxuICAgIFwidHJhbnNsYXRlX3JlZ2V4XCIsXG4gICAgXCJ0cmFuc2xhdGlvblwiLFxuICAgIFwidHJlYXRcIixcbiAgICBcInRyaWdnZXJcIixcbiAgICBcInRyaW1cIixcbiAgICBcInRyaW1fYXJyYXlcIixcbiAgICBcInRydWVcIixcbiAgICBcInRydW5jYXRlXCIsXG4gICAgXCJ1ZXNjYXBlXCIsXG4gICAgXCJ1bmlvblwiLFxuICAgIFwidW5pcXVlXCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJ1bm5lc3RcIixcbiAgICBcInVwZGF0ZVwiLFxuICAgIFwidXBwZXJcIixcbiAgICBcInVzZXJcIixcbiAgICBcInVzaW5nXCIsXG4gICAgXCJ2YWx1ZVwiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJ2YWx1ZV9vZlwiLFxuICAgIFwidmFyX3BvcFwiLFxuICAgIFwidmFyX3NhbXBcIixcbiAgICBcInZhcmJpbmFyeVwiLFxuICAgIFwidmFyY2hhclwiLFxuICAgIFwidmFyeWluZ1wiLFxuICAgIFwidmVyc2lvbmluZ1wiLFxuICAgIFwid2hlblwiLFxuICAgIFwid2hlbmV2ZXJcIixcbiAgICBcIndoZXJlXCIsXG4gICAgXCJ3aWR0aF9idWNrZXRcIixcbiAgICBcIndpbmRvd1wiLFxuICAgIFwid2l0aFwiLFxuICAgIFwid2l0aGluXCIsXG4gICAgXCJ3aXRob3V0XCIsXG4gICAgXCJ5ZWFyXCIsXG4gIF07XG5cbiAgLy8gdGhlc2UgYXJlIHJlc2VydmVkIHdvcmRzIHdlIGhhdmUgaWRlbnRpZmllZCB0byBiZSBmdW5jdGlvbnNcbiAgLy8gYW5kIHNob3VsZCBvbmx5IGJlIGhpZ2hsaWdodGVkIGluIGEgZGlzcGF0Y2gtbGlrZSBjb250ZXh0XG4gIC8vIGllLCBhcnJheV9hZ2coLi4uKSwgZXRjLlxuICBjb25zdCBSRVNFUlZFRF9GVU5DVElPTlMgPSBbXG4gICAgXCJhYnNcIixcbiAgICBcImFjb3NcIixcbiAgICBcImFycmF5X2FnZ1wiLFxuICAgIFwiYXNpblwiLFxuICAgIFwiYXRhblwiLFxuICAgIFwiYXZnXCIsXG4gICAgXCJjYXN0XCIsXG4gICAgXCJjZWlsXCIsXG4gICAgXCJjZWlsaW5nXCIsXG4gICAgXCJjb2FsZXNjZVwiLFxuICAgIFwiY29yclwiLFxuICAgIFwiY29zXCIsXG4gICAgXCJjb3NoXCIsXG4gICAgXCJjb3VudFwiLFxuICAgIFwiY292YXJfcG9wXCIsXG4gICAgXCJjb3Zhcl9zYW1wXCIsXG4gICAgXCJjdW1lX2Rpc3RcIixcbiAgICBcImRlbnNlX3JhbmtcIixcbiAgICBcImRlcmVmXCIsXG4gICAgXCJlbGVtZW50XCIsXG4gICAgXCJleHBcIixcbiAgICBcImV4dHJhY3RcIixcbiAgICBcImZpcnN0X3ZhbHVlXCIsXG4gICAgXCJmbG9vclwiLFxuICAgIFwianNvbl9hcnJheVwiLFxuICAgIFwianNvbl9hcnJheWFnZ1wiLFxuICAgIFwianNvbl9leGlzdHNcIixcbiAgICBcImpzb25fb2JqZWN0XCIsXG4gICAgXCJqc29uX29iamVjdGFnZ1wiLFxuICAgIFwianNvbl9xdWVyeVwiLFxuICAgIFwianNvbl90YWJsZVwiLFxuICAgIFwianNvbl90YWJsZV9wcmltaXRpdmVcIixcbiAgICBcImpzb25fdmFsdWVcIixcbiAgICBcImxhZ1wiLFxuICAgIFwibGFzdF92YWx1ZVwiLFxuICAgIFwibGVhZFwiLFxuICAgIFwibGlzdGFnZ1wiLFxuICAgIFwibG5cIixcbiAgICBcImxvZ1wiLFxuICAgIFwibG9nMTBcIixcbiAgICBcImxvd2VyXCIsXG4gICAgXCJtYXhcIixcbiAgICBcIm1pblwiLFxuICAgIFwibW9kXCIsXG4gICAgXCJudGhfdmFsdWVcIixcbiAgICBcIm50aWxlXCIsXG4gICAgXCJudWxsaWZcIixcbiAgICBcInBlcmNlbnRfcmFua1wiLFxuICAgIFwicGVyY2VudGlsZV9jb250XCIsXG4gICAgXCJwZXJjZW50aWxlX2Rpc2NcIixcbiAgICBcInBvc2l0aW9uXCIsXG4gICAgXCJwb3NpdGlvbl9yZWdleFwiLFxuICAgIFwicG93ZXJcIixcbiAgICBcInJhbmtcIixcbiAgICBcInJlZ3JfYXZneFwiLFxuICAgIFwicmVncl9hdmd5XCIsXG4gICAgXCJyZWdyX2NvdW50XCIsXG4gICAgXCJyZWdyX2ludGVyY2VwdFwiLFxuICAgIFwicmVncl9yMlwiLFxuICAgIFwicmVncl9zbG9wZVwiLFxuICAgIFwicmVncl9zeHhcIixcbiAgICBcInJlZ3Jfc3h5XCIsXG4gICAgXCJyZWdyX3N5eVwiLFxuICAgIFwicm93X251bWJlclwiLFxuICAgIFwic2luXCIsXG4gICAgXCJzaW5oXCIsXG4gICAgXCJzcXJ0XCIsXG4gICAgXCJzdGRkZXZfcG9wXCIsXG4gICAgXCJzdGRkZXZfc2FtcFwiLFxuICAgIFwic3Vic3RyaW5nXCIsXG4gICAgXCJzdWJzdHJpbmdfcmVnZXhcIixcbiAgICBcInN1bVwiLFxuICAgIFwidGFuXCIsXG4gICAgXCJ0YW5oXCIsXG4gICAgXCJ0cmFuc2xhdGVcIixcbiAgICBcInRyYW5zbGF0ZV9yZWdleFwiLFxuICAgIFwidHJlYXRcIixcbiAgICBcInRyaW1cIixcbiAgICBcInRyaW1fYXJyYXlcIixcbiAgICBcInVubmVzdFwiLFxuICAgIFwidXBwZXJcIixcbiAgICBcInZhbHVlX29mXCIsXG4gICAgXCJ2YXJfcG9wXCIsXG4gICAgXCJ2YXJfc2FtcFwiLFxuICAgIFwid2lkdGhfYnVja2V0XCIsXG4gIF07XG5cbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGNhblxuICBjb25zdCBQT1NTSUJMRV9XSVRIT1VUX1BBUkVOUyA9IFtcbiAgICBcImN1cnJlbnRfY2F0YWxvZ1wiLFxuICAgIFwiY3VycmVudF9kYXRlXCIsXG4gICAgXCJjdXJyZW50X2RlZmF1bHRfdHJhbnNmb3JtX2dyb3VwXCIsXG4gICAgXCJjdXJyZW50X3BhdGhcIixcbiAgICBcImN1cnJlbnRfcm9sZVwiLFxuICAgIFwiY3VycmVudF9zY2hlbWFcIixcbiAgICBcImN1cnJlbnRfdHJhbnNmb3JtX2dyb3VwX2Zvcl90eXBlXCIsXG4gICAgXCJjdXJyZW50X3VzZXJcIixcbiAgICBcInNlc3Npb25fdXNlclwiLFxuICAgIFwic3lzdGVtX3RpbWVcIixcbiAgICBcInN5c3RlbV91c2VyXCIsXG4gICAgXCJjdXJyZW50X3RpbWVcIixcbiAgICBcImxvY2FsdGltZVwiLFxuICAgIFwiY3VycmVudF90aW1lc3RhbXBcIixcbiAgICBcImxvY2FsdGltZXN0YW1wXCJcbiAgXTtcblxuICAvLyB0aG9zZSBleGlzdCB0byBib29zdCByZWxldmFuY2UgbWFraW5nIHRoZXNlIHZlcnlcbiAgLy8gXCJTUUwgbGlrZVwiIGtleXdvcmQgY29tYm9zIHdvcnRoICsxIGV4dHJhIHJlbGV2YW5jZVxuICBjb25zdCBDT01CT1MgPSBbXG4gICAgXCJjcmVhdGUgdGFibGVcIixcbiAgICBcImluc2VydCBpbnRvXCIsXG4gICAgXCJwcmltYXJ5IGtleVwiLFxuICAgIFwiZm9yZWlnbiBrZXlcIixcbiAgICBcIm5vdCBudWxsXCIsXG4gICAgXCJhbHRlciB0YWJsZVwiLFxuICAgIFwiYWRkIGNvbnN0cmFpbnRcIixcbiAgICBcImdyb3VwaW5nIHNldHNcIixcbiAgICBcIm9uIG92ZXJmbG93XCIsXG4gICAgXCJjaGFyYWN0ZXIgc2V0XCIsXG4gICAgXCJyZXNwZWN0IG51bGxzXCIsXG4gICAgXCJpZ25vcmUgbnVsbHNcIixcbiAgICBcIm51bGxzIGZpcnN0XCIsXG4gICAgXCJudWxscyBsYXN0XCIsXG4gICAgXCJkZXB0aCBmaXJzdFwiLFxuICAgIFwiYnJlYWR0aCBmaXJzdFwiXG4gIF07XG5cbiAgY29uc3QgRlVOQ1RJT05TID0gUkVTRVJWRURfRlVOQ1RJT05TO1xuXG4gIGNvbnN0IEtFWVdPUkRTID0gW1xuICAgIC4uLlJFU0VSVkVEX1dPUkRTLFxuICAgIC4uLk5PTl9SRVNFUlZFRF9XT1JEU1xuICBdLmZpbHRlcigoa2V5d29yZCkgPT4ge1xuICAgIHJldHVybiAhUkVTRVJWRURfRlVOQ1RJT05TLmluY2x1ZGVzKGtleXdvcmQpO1xuICB9KTtcblxuICBjb25zdCBWQVJJQUJMRSA9IHtcbiAgICBjbGFzc05hbWU6IFwidmFyaWFibGVcIixcbiAgICBiZWdpbjogL0BbYS16MC05XSsvLFxuICB9O1xuXG4gIGNvbnN0IE9QRVJBVE9SID0ge1xuICAgIGNsYXNzTmFtZTogXCJvcGVyYXRvclwiLFxuICAgIGJlZ2luOiAvWy0rKi89JV5+XXwmJj98XFx8XFx8P3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT8vLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgfTtcblxuICBjb25zdCBGVU5DVElPTl9DQUxMID0ge1xuICAgIGJlZ2luOiByZWdleC5jb25jYXQoL1xcYi8sIHJlZ2V4LmVpdGhlciguLi5GVU5DVElPTlMpLCAvXFxzKlxcKC8pLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBrZXl3b3JkczogeyBidWlsdF9pbjogRlVOQ1RJT05TIH1cbiAgfTtcblxuICAvLyBrZXl3b3JkcyB3aXRoIGxlc3MgdGhhbiAzIGxldHRlcnMgYXJlIHJlZHVjZWQgaW4gcmVsZXZhbmN5XG4gIGZ1bmN0aW9uIHJlZHVjZVJlbGV2YW5jeShsaXN0LCB7XG4gICAgZXhjZXB0aW9ucywgd2hlblxuICB9ID0ge30pIHtcbiAgICBjb25zdCBxdWFsaWZ5Rm4gPSB3aGVuO1xuICAgIGV4Y2VwdGlvbnMgPSBleGNlcHRpb25zIHx8IFtdO1xuICAgIHJldHVybiBsaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0ubWF0Y2goL1xcfFxcZCskLykgfHwgZXhjZXB0aW9ucy5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAocXVhbGlmeUZuKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtfXwwYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU1FMJyxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIC8vIGRvZXMgbm90IGluY2x1ZGUge30gb3IgSFRNTCB0YWdzIGA8L2BcbiAgICBpbGxlZ2FsOiAvW3t9XXw8XFwvLyxcbiAgICBrZXl3b3Jkczoge1xuICAgICAgJHBhdHRlcm46IC9cXGJbXFx3XFwuXSsvLFxuICAgICAga2V5d29yZDpcbiAgICAgICAgcmVkdWNlUmVsZXZhbmN5KEtFWVdPUkRTLCB7IHdoZW46ICh4KSA9PiB4Lmxlbmd0aCA8IDMgfSksXG4gICAgICBsaXRlcmFsOiBMSVRFUkFMUyxcbiAgICAgIHR5cGU6IFRZUEVTLFxuICAgICAgYnVpbHRfaW46IFBPU1NJQkxFX1dJVEhPVVRfUEFSRU5TXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogcmVnZXguZWl0aGVyKC4uLkNPTUJPUyksXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICAkcGF0dGVybjogL1tcXHdcXC5dKy8sXG4gICAgICAgICAga2V5d29yZDogS0VZV09SRFMuY29uY2F0KENPTUJPUyksXG4gICAgICAgICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgICAgICAgdHlwZTogVFlQRVNcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0eXBlXCIsXG4gICAgICAgIGJlZ2luOiByZWdleC5laXRoZXIoLi4uTVVMVElfV09SRF9UWVBFUylcbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9DQUxMLFxuICAgICAgVkFSSUFCTEUsXG4gICAgICBTVFJJTkcsXG4gICAgICBRVU9URURfSURFTlRJRklFUixcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBDT01NRU5UX01PREUsXG4gICAgICBPUEVSQVRPUlxuICAgIF1cbiAgfTtcbn1cblxudmFyIHNxbF8xID0gc3FsO1xuXG4vKlxuTGFuZ3VhZ2U6IEhUTUwsIFhNTFxuV2Vic2l0ZTogaHR0cHM6Ly93d3cudzMub3JnL1hNTC9cbkNhdGVnb3J5OiBjb21tb24sIHdlYlxuQXVkaXQ6IDIwMjBcbiovXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24geG1sKGhsanMpIHtcbiAgY29uc3QgcmVnZXggPSBobGpzLnJlZ2V4O1xuICAvLyBFbGVtZW50IG5hbWVzIGNhbiBjb250YWluIGxldHRlcnMsIGRpZ2l0cywgaHlwaGVucywgdW5kZXJzY29yZXMsIGFuZCBwZXJpb2RzXG4gIGNvbnN0IFRBR19OQU1FX1JFID0gcmVnZXguY29uY2F0KC9bQS1aX10vLCByZWdleC5vcHRpb25hbCgvW0EtWjAtOV8uLV0qOi8pLCAvW0EtWjAtOV8uLV0qLyk7XG4gIGNvbnN0IFhNTF9JREVOVF9SRSA9IC9bQS1aYS16MC05Ll86LV0rLztcbiAgY29uc3QgWE1MX0VOVElUSUVTID0ge1xuICAgIGNsYXNzTmFtZTogJ3N5bWJvbCcsXG4gICAgYmVnaW46IC8mW2Etel0rO3wmI1swLTldKzt8JiN4W2EtZjAtOV0rOy9cbiAgfTtcbiAgY29uc3QgWE1MX01FVEFfS0VZV09SRFMgPSB7XG4gICAgYmVnaW46IC9cXHMvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2tleXdvcmQnLFxuICAgICAgICBiZWdpbjogLyM/W2Etel9dW2EtejEtOV8tXSsvLFxuICAgICAgICBpbGxlZ2FsOiAvXFxuL1xuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3QgWE1MX01FVEFfUEFSX0tFWVdPUkRTID0gaGxqcy5pbmhlcml0KFhNTF9NRVRBX0tFWVdPUkRTLCB7XG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS9cbiAgfSk7XG4gIGNvbnN0IEFQT1NfTUVUQV9TVFJJTkdfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLkFQT1NfU1RSSU5HX01PREUsIHsgY2xhc3NOYW1lOiAnc3RyaW5nJyB9KTtcbiAgY29uc3QgUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLlFVT1RFX1NUUklOR19NT0RFLCB7IGNsYXNzTmFtZTogJ3N0cmluZycgfSk7XG4gIGNvbnN0IFRBR19JTlRFUk5BTFMgPSB7XG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgaWxsZWdhbDogLzwvLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IFhNTF9JREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLz1cXHMqLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiAvXCIvLFxuICAgICAgICAgICAgICAgIGVuZDogL1wiLyxcbiAgICAgICAgICAgICAgICBjb250YWluczogWyBYTUxfRU5USVRJRVMgXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC8nLyxcbiAgICAgICAgICAgICAgICBlbmQ6IC8nLyxcbiAgICAgICAgICAgICAgICBjb250YWluczogWyBYTUxfRU5USVRJRVMgXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IGJlZ2luOiAvW15cXHNcIic9PD5gXSsvIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0hUTUwsIFhNTCcsXG4gICAgYWxpYXNlczogW1xuICAgICAgJ2h0bWwnLFxuICAgICAgJ3hodG1sJyxcbiAgICAgICdyc3MnLFxuICAgICAgJ2F0b20nLFxuICAgICAgJ3hqYicsXG4gICAgICAneHNkJyxcbiAgICAgICd4c2wnLFxuICAgICAgJ3BsaXN0JyxcbiAgICAgICd3c2YnLFxuICAgICAgJ3N2ZydcbiAgICBdLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvPCFbYS16XS8sXG4gICAgICAgIGVuZDogLz4vLFxuICAgICAgICByZWxldmFuY2U6IDEwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFhNTF9NRVRBX0tFWVdPUkRTLFxuICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREUsXG4gICAgICAgICAgQVBPU19NRVRBX1NUUklOR19NT0RFLFxuICAgICAgICAgIFhNTF9NRVRBX1BBUl9LRVlXT1JEUyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1xcWy8sXG4gICAgICAgICAgICBlbmQ6IC9cXF0vLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICAgICAgICAgIGJlZ2luOiAvPCFbYS16XS8sXG4gICAgICAgICAgICAgICAgZW5kOiAvPi8sXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgIFhNTF9NRVRBX0tFWVdPUkRTLFxuICAgICAgICAgICAgICAgICAgWE1MX01FVEFfUEFSX0tFWVdPUkRTLFxuICAgICAgICAgICAgICAgICAgUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgICAgIEFQT1NfTUVUQV9TVFJJTkdfTU9ERVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGhsanMuQ09NTUVOVChcbiAgICAgICAgLzwhLS0vLFxuICAgICAgICAvLS0+LyxcbiAgICAgICAgeyByZWxldmFuY2U6IDEwIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPCFcXFtDREFUQVxcWy8sXG4gICAgICAgIGVuZDogL1xcXVxcXT4vLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgWE1MX0VOVElUSUVTLFxuICAgICAgLy8geG1sIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBlbmQ6IC9cXD8+LyxcbiAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLzxcXD94bWwvLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvPFxcP1thLXpdW2EtejAtOV0rLyxcbiAgICAgICAgICB9XG4gICAgICAgIF1cblxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLypcbiAgICAgICAgVGhlIGxvb2thaGVhZCBwYXR0ZXJuICg/PS4uLikgZW5zdXJlcyB0aGF0ICdiZWdpbicgb25seSBtYXRjaGVzXG4gICAgICAgICc8c3R5bGUnIGFzIGEgc2luZ2xlIHdvcmQsIGZvbGxvd2VkIGJ5IGEgd2hpdGVzcGFjZSBvciBhblxuICAgICAgICBlbmRpbmcgYnJhY2tldC5cbiAgICAgICAgKi9cbiAgICAgICAgYmVnaW46IC88c3R5bGUoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHsgbmFtZTogJ3N0eWxlJyB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zdHlsZT4vLFxuICAgICAgICAgIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogW1xuICAgICAgICAgICAgJ2NzcycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSA8c3R5bGUgdGFnIGFib3V0IHRoZSBsb29rYWhlYWQgcGF0dGVyblxuICAgICAgICBiZWdpbjogLzxzY3JpcHQoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHsgbmFtZTogJ3NjcmlwdCcgfSxcbiAgICAgICAgY29udGFpbnM6IFsgVEFHX0lOVEVSTkFMUyBdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC88XFwvc2NyaXB0Pi8sXG4gICAgICAgICAgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbXG4gICAgICAgICAgICAnamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnaGFuZGxlYmFycycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHdlIG5lZWQgdGhpcyBmb3Igbm93IGZvciBqU1hcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IC88Pnw8XFwvPi9cbiAgICAgIH0sXG4gICAgICAvLyBvcGVuIHRhZ1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogcmVnZXguY29uY2F0KFxuICAgICAgICAgIC88LyxcbiAgICAgICAgICByZWdleC5sb29rYWhlYWQocmVnZXguY29uY2F0KFxuICAgICAgICAgICAgVEFHX05BTUVfUkUsXG4gICAgICAgICAgICAvLyA8dGFnLz5cbiAgICAgICAgICAgIC8vIDx0YWc+XG4gICAgICAgICAgICAvLyA8dGFnIC4uLlxuICAgICAgICAgICAgcmVnZXguZWl0aGVyKC9cXC8+LywgLz4vLCAvXFxzLylcbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBlbmQ6IC9cXC8/Pi8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBiZWdpbjogVEFHX05BTUVfUkUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBzdGFydHM6IFRBR19JTlRFUk5BTFNcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBjbG9zZSB0YWdcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IHJlZ2V4LmNvbmNhdChcbiAgICAgICAgICAvPFxcLy8sXG4gICAgICAgICAgcmVnZXgubG9va2FoZWFkKHJlZ2V4LmNvbmNhdChcbiAgICAgICAgICAgIFRBR19OQU1FX1JFLCAvPi9cbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgYmVnaW46IFRBR19OQU1FX1JFLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLz4vLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxudmFyIHhtbF8xID0geG1sO1xuXG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmFzY3JpcHQnLCBqYXZhc2NyaXB0XzEpO1xuY29yZS5yZWdpc3Rlckxhbmd1YWdlKCdzcWwnLCBzcWxfMSk7XG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmEnLCBqYXZhXzEpO1xuY29yZS5yZWdpc3Rlckxhbmd1YWdlKCd4bWwnLCB4bWxfMSk7XG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3B5dGhvbicsIHB5dGhvbl8xKTtcbmNsYXNzIFBhcnNvbnNJbnB1dCB7XG4gICAgLy8gVGhlIGlucHV0IGVsZW1lbnRcbiAgICBlbDtcbiAgICBfZHJvcEFyZWE7XG4gICAgX2RyYWdBcmVhO1xuICAgIF9kcm9wU29ydGFibGU7XG4gICAgX2RyYWdTb3J0YWJsZTtcbiAgICBwYXJlbnRFbGVtZW50O1xuICAgIF9wcmV2UG9zaXRpb247XG4gICAgcmV1c2FibGU7XG4gICAgcmFuZG9taXplO1xuICAgIHN0b3JlZFNvdXJjZUJsb2NrcztcbiAgICBzdG9yZWRTb3VyY2VCbG9ja0V4cGxhbmF0aW9ucztcbiAgICBobGpzTGFuZ3VhZ2U7XG4gICAgY29udGV4dEJlZm9yZTtcbiAgICBjb250ZXh0QWZ0ZXI7XG4gICAgLy8gaWYgdGhlIGlucHV0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9uY2VcbiAgICBpbml0aWFsaXplZDtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtZW50LCByZXVzYWJsZSwgcmFuZG9taXplKSB7XG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5lbC5pZCA9ICdyZWdleHRvb2wtJyArIHRoaXMucGFyZW50RWxlbWVudC50b29sTnVtYmVyICsgJy1wYXJzb25zLWlucHV0JztcbiAgICAgICAgY29uc3QgZHJhZ1RpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkcmFnVGlwLmlubmVyVGV4dCA9ICdEcmFnIG9yIGNsaWNrIHRoZSBibG9ja3MgYmVsb3cgdG8gZm9ybSB5b3VyIGNvZGU6JztcbiAgICAgICAgZHJhZ1RpcC5jbGFzc0xpc3QuYWRkKCdocGFyc29ucy10aXAnKTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmQoZHJhZ1RpcCk7XG4gICAgICAgIHRoaXMuX2RyYWdBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5fZHJhZ0FyZWEpO1xuICAgICAgICB0aGlzLl9kcmFnQXJlYS5jbGFzc0xpc3QuYWRkKCdkcmFnLWFyZWEnKTtcbiAgICAgICAgY29uc3QgZHJvcFRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkcm9wVGlwLmlubmVyVGV4dCA9ICdZb3VyIGNvZGUgKGNsaWNrIG9uIGEgYmxvY2sgdG8gcmVtb3ZlIGl0KTonO1xuICAgICAgICBkcm9wVGlwLmNsYXNzTGlzdC5hZGQoJ2hwYXJzb25zLXRpcCcpO1xuICAgICAgICB0aGlzLmVsLmFwcGVuZChkcm9wVGlwKTtcbiAgICAgICAgY29uc3QgY29udGV4dEJlZm9yZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZXh0QmVmb3JlLmlkID0gJ2hwYXJzb25zLScgKyB0aGlzLnBhcmVudEVsZW1lbnQudG9vbE51bWJlciArICctY29udGV4dC1iZWZvcmUnO1xuICAgICAgICBjb250ZXh0QmVmb3JlLmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQnKTtcbiAgICAgICAgY29udGV4dEJlZm9yZS5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoY29udGV4dEJlZm9yZSk7XG4gICAgICAgIHRoaXMuY29udGV4dEJlZm9yZSA9IGNvbnRleHRCZWZvcmU7XG4gICAgICAgIHRoaXMuX2Ryb3BBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcEFyZWEpO1xuICAgICAgICB0aGlzLl9kcm9wQXJlYS5jbGFzc0xpc3QuYWRkKCdkcm9wLWFyZWEnKTtcbiAgICAgICAgdGhpcy5fcHJldlBvc2l0aW9uID0gLTE7XG4gICAgICAgIGNvbnN0IGNvbnRleHRBZnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZXh0QWZ0ZXIuaWQgPSAnaHBhcnNvbnMtJyArIHRoaXMucGFyZW50RWxlbWVudC50b29sTnVtYmVyICsgJy1jb250ZXh0LWFmdGVyJztcbiAgICAgICAgY29udGV4dEFmdGVyLmNsYXNzTGlzdC5hZGQoJ2NvbnRleHQnKTtcbiAgICAgICAgY29udGV4dEFmdGVyLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChjb250ZXh0QWZ0ZXIpO1xuICAgICAgICB0aGlzLmNvbnRleHRBZnRlciA9IGNvbnRleHRBZnRlcjtcbiAgICAgICAgdGhpcy5zdG9yZWRTb3VyY2VCbG9ja3MgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9yZWRTb3VyY2VCbG9ja0V4cGxhbmF0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMucmV1c2FibGUgPSByZXVzYWJsZTtcbiAgICAgICAgdGhpcy5yYW5kb21pemUgPSByYW5kb21pemU7XG4gICAgICAgIHRoaXMuX2RyYWdTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Ryb3BTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXRTb3J0YWJsZSgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGxqc0xhbmd1YWdlID0gdGhpcy5wYXJlbnRFbGVtZW50Lmxhbmd1YWdlO1xuICAgIH1cbiAgICBnZXRUZXh0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgcmV0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wQXJlYS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIGxldCBlbCA9IHRoaXMuX2Ryb3BBcmVhLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByZXQgKz0gZWwuaW5uZXJUZXh0LnJlcGxhY2UoL1xceEEwL2csICcgJyk7XG4gICAgICAgICAgICB3aGlsZSAoZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldCArPSBlbC5pbm5lclRleHQucmVwbGFjZSgvXFx4QTAvZywgJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBEdXJzdGVuZmVsZCBzaHVmZmxlXG4gICAgc2h1ZmZsZUFycmF5KGFycmF5KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IHRlbXAgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U291cmNlQmxvY2tzID0gKGRhdGEsIHRvb2x0aXBzKSA9PiB7XG4gICAgICAgIC8vIHNodWZmbGUgc291cmNlIGJsb2NrcyBpZiByYW5kb21pemVcbiAgICAgICAgaWYgKHRoaXMucmFuZG9taXplKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxEYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNodWZmbGVBcnJheShkYXRhKTtcbiAgICAgICAgICAgIHdoaWxlIChKU09OLnN0cmluZ2lmeShkYXRhKSA9PSBvcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNodWZmbGVBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlZFNvdXJjZUJsb2NrcyA9IGRhdGE7XG4gICAgICAgIHRoaXMuc3RvcmVkU291cmNlQmxvY2tFeHBsYW5hdGlvbnMgPSB0b29sdGlwcztcbiAgICAgICAgdGhpcy5fcmVzZXRJbnB1dCgpO1xuICAgIH07XG4gICAgLy8gVE9ETzogbm90IGVmZmljaWVudCBlbm91Z2guIHNob3VsZCBub3QgbmVlZCB0byBjcmVhdGUgbmV3IGVsZW1lbnRzOyBzaW1wbHkgc29ydGluZyB0aGVtIHNob3VsZCBiZSBnb29kLlxuICAgIF9yZXNldElucHV0ID0gKCkgPT4ge1xuICAgICAgICAvLyBjbGVhcmluZyBwcmV2aW91cyBibG9ja3NcbiAgICAgICAgd2hpbGUgKHRoaXMuX2RyYWdBcmVhLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdBcmVhLnJlbW92ZUNoaWxkKHRoaXMuX2RyYWdBcmVhLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLl9kcm9wQXJlYS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5yZW1vdmVDaGlsZCh0aGlzLl9kcm9wQXJlYS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgbmV3IGJsb2Nrc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RvcmVkU291cmNlQmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0FyZWEuYXBwZW5kQ2hpbGQobmV3QmxvY2spO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVkU291cmNlQmxvY2tzW2ldID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGVyZScpO1xuICAgICAgICAgICAgICAgIG5ld0Jsb2NrLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGxqc0xhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrLmlubmVySFRNTCA9IGNvcmUuaGlnaGxpZ2h0KHRoaXMuc3RvcmVkU291cmNlQmxvY2tzW2ldLCB7IGxhbmd1YWdlOiB0aGlzLmhsanNMYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdCbG9jay5pbm5lclRleHQgPSB0aGlzLnN0b3JlZFNvdXJjZUJsb2Nrc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdCbG9jay5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICBuZXdCbG9jay5jbGFzc0xpc3QuYWRkKCdwYXJzb25zLWJsb2NrJyk7XG4gICAgICAgICAgICBuZXdCbG9jay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQmxvY2tDbGlja2VkKG5ld0Jsb2NrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9vbkJsb2NrQ2xpY2tlZCA9IChibG9jaykgPT4ge1xuICAgICAgICBpZiAoYmxvY2sucGFyZW50RWxlbWVudCA9PSB0aGlzLl9kcmFnQXJlYSkge1xuICAgICAgICAgICAgbGV0IGVuZFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMucmV1c2FibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja0NvcHkgPSBibG9jay5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmxvY2tDb3B5Lm9uY2xpY2sgPSAoKSA9PiB0aGlzLl9vbkJsb2NrQ2xpY2tlZChibG9ja0NvcHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BBcmVhLmFwcGVuZENoaWxkKGJsb2NrQ29weSk7XG4gICAgICAgICAgICAgICAgZW5kUG9zaXRpb24gPSB0aGlzLl9nZXRCbG9ja1Bvc2l0aW9uKGJsb2NrQ29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5hcHBlbmRDaGlsZChibG9jayk7XG4gICAgICAgICAgICAgICAgZW5kUG9zaXRpb24gPSB0aGlzLl9nZXRCbG9ja1Bvc2l0aW9uKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgJ2V2ZW50LXR5cGUnOiAncGFyc29ucy1pbnB1dCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogWy0xLCBlbmRQb3NpdGlvbl0sXG4gICAgICAgICAgICAgICAgYW5zd2VyOiB0aGlzLl9nZXRUZXh0QXJyYXkoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQubG9nRXZlbnQoaW5wdXRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0QmxvY2tQb3NpdGlvbihibG9jayk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXVzYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BBcmVhLnJlbW92ZUNoaWxkKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdBcmVhLmFwcGVuZENoaWxkKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgJ2V2ZW50LXR5cGUnOiAncGFyc29ucy1pbnB1dCcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3N0YXJ0UG9zaXRpb24sIC0xXSxcbiAgICAgICAgICAgICAgICBhbnN3ZXI6IHRoaXMuX2dldFRleHRBcnJheSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5sb2dFdmVudChpbnB1dEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX2luaXRTb3J0YWJsZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmV1c2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTb3J0YWJsZSA9IG5ldyBTb3J0YWJsZSh0aGlzLl9kcmFnQXJlYSwge1xuICAgICAgICAgICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzaGFyZWQnLFxuICAgICAgICAgICAgICAgICAgICBwdWxsOiAnY2xvbmUnLFxuICAgICAgICAgICAgICAgICAgICBwdXQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IDE1MCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6ICcucGFyc29ucy1ibG9jaycsXG4gICAgICAgICAgICAgICAgb25DbG9uZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Jsb2NrID0gZXZlbnQuY2xvbmU7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrLm9uY2xpY2sgPSAoKSA9PiB0aGlzLl9vbkJsb2NrQ2xpY2tlZChuZXdCbG9jayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU29ydGFibGUgPSBuZXcgU29ydGFibGUodGhpcy5fZHJvcEFyZWEsIHtcbiAgICAgICAgICAgICAgICBncm91cDogJ3NoYXJlZCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAxNTAsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiAnLnBhcnNvbnMtYmxvY2snLFxuICAgICAgICAgICAgICAgIG9uQWRkOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdldmVudC10eXBlJzogJ3BhcnNvbnMtaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbLTEsIHRoaXMuX2dldEJsb2NrUG9zaXRpb24oZXZlbnQuaXRlbSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyOiB0aGlzLl9nZXRUZXh0QXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LmxvZ0V2ZW50KGlucHV0RXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdGFydDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZQb3NpdGlvbiA9IHRoaXMuX2dldEJsb2NrUG9zaXRpb24oZXZlbnQuaXRlbSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGlvbiA9ICdtb3ZlJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBwZXJib3VuZCA9IHRoaXMuX2Ryb3BBcmVhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJib3VuZCA9IHRoaXMuX2Ryb3BBcmVhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpZW50WSA+IGxvd2VyYm91bmQgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRZIDwgdXBwZXJib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGV2ZW50Lml0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9zaXRpb24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9zaXRpb24gPSB0aGlzLl9nZXRCbG9ja1Bvc2l0aW9uKGV2ZW50Lml0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQtdHlwZSc6ICdwYXJzb25zLWlucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFt0aGlzLl9wcmV2UG9zaXRpb24sIGVuZHBvc2l0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlcjogdGhpcy5fZ2V0VGV4dEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5sb2dFdmVudChpbnB1dEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnU29ydGFibGUgPSBuZXcgU29ydGFibGUodGhpcy5fZHJhZ0FyZWEsIHtcbiAgICAgICAgICAgICAgICBncm91cDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2hhcmVkJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVsbDogJ2Nsb25lJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHV0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc29ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAxNTAsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiAnLnBhcnNvbnMtYmxvY2snLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU29ydGFibGUgPSBuZXcgU29ydGFibGUodGhpcy5fZHJvcEFyZWEsIHtcbiAgICAgICAgICAgICAgICBncm91cDogJ3NoYXJlZCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAxNTAsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiAnLnBhcnNvbnMtYmxvY2snLFxuICAgICAgICAgICAgICAgIG9uQWRkOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdldmVudC10eXBlJzogJ3BhcnNvbnMtaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbLTEsIHRoaXMuX2dldEJsb2NrUG9zaXRpb24oZXZlbnQuaXRlbSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyOiB0aGlzLl9nZXRUZXh0QXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LmxvZ0V2ZW50KGlucHV0RXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdGFydDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZQb3NpdGlvbiA9IHRoaXMuX2dldEJsb2NrUG9zaXRpb24oZXZlbnQuaXRlbSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRwb3NpdGlvbiA9IHRoaXMuX2dldEJsb2NrUG9zaXRpb24oZXZlbnQuaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGVuZHBvc2l0aW9uID09IC0xID8gJ3JlbW92ZScgOiAnbW92ZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQtdHlwZSc6ICdwYXJzb25zLWlucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFt0aGlzLl9wcmV2UG9zaXRpb24sIGVuZHBvc2l0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlcjogdGhpcy5fZ2V0VGV4dEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5sb2dFdmVudChpbnB1dEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZVRlc3RTdGF0dXMgPSAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wQXJlYS5jbGFzc0xpc3QuY29udGFpbnMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kcm9wQXJlYS5jbGFzc0xpc3QuY29udGFpbnMoJ1Bhc3MnKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJvcEFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnUGFzcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2Ryb3BBcmVhLmNsYXNzTGlzdC5jb250YWlucygnRmFpbCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdGYWlsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZHJvcEFyZWEuY2xhc3NMaXN0LmNvbnRhaW5zKCdFcnJvcicpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5jbGFzc0xpc3QucmVtb3ZlKCdFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Ryb3BBcmVhLmNsYXNzTGlzdC5hZGQocmVzdWx0KTtcbiAgICB9O1xuICAgIF9nZXRCbG9ja1Bvc2l0aW9uID0gKGJsb2NrKSA9PiB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IC0xO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9kcm9wQXJlYTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyArK3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW3Bvc2l0aW9uXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIF9nZXRUZXh0QXJyYXkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BBcmVhLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgbGV0IGVsID0gdGhpcy5fZHJvcEFyZWEuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGFuc3dlci5wdXNoKGVsLmlubmVyVGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGFuc3dlci5wdXNoKGVsLmlubmVyVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9O1xuICAgIGhpZ2hsaWdodEVycm9yID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BBcmVhLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgbGV0IGVsID0gdGhpcy5fZHJvcEFyZWEuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGNvdW50ICs9IGVsLmlubmVyVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY291bnQgPj0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBibG9jayBjb250YWlucyB0aGUgc3ltYm9sIHdpdGggZXJyb3JcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmOTliMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gZWwuaW5uZXJUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBibG9jayBjb250YWlucyB0aGUgc3ltYm9sIHdpdGggZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZmY5OWIzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZW1vdmVGb3JtYXQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wQXJlYS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIGxldCBlbCA9IHRoaXMuX2Ryb3BBcmVhLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgd2hpbGUgKGVsLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXNldElucHV0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZXVzYWJsZSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Ryb3BBcmVhLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5yZW1vdmVDaGlsZCh0aGlzLl9kcm9wQXJlYS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0SW5wdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVE9ETzogbm90IHVzZWQgZm9yIG5vdywgbm90IHN1cmUgaWYgaXMgd29ya2luZyBjb3JyZWN0bHlcbiAgICByZXN0b3JlQW5zd2VyKHR5cGUsIGFuc3dlcikge1xuICAgICAgICBpZiAodHlwZSAhPSAncGFyc29ucycgfHwgIUFycmF5LmlzQXJyYXkoYW5zd2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Ryb3BBcmVhLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuc3dlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbnN3ZXJbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wQXJlYS5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgICAgICAgICAgICAgbmV3QmxvY2suaW5uZXJUZXh0ID0gYW5zd2VyW2ldO1xuICAgICAgICAgICAgICAgIG5ld0Jsb2NrLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgICAgICBuZXdCbG9jay5jbGFzc0xpc3QuYWRkKCdwYXJzb25zLWJsb2NrJyk7XG4gICAgICAgICAgICAgICAgbmV3QmxvY2sub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpY2tpbmcgdGhlIG5ldyBibG9jayBnZW5lcmF0ZWQgYnkgY2xpY2tpbmcgYW4gZXh0ZW5kYWJsZSBibG9jayB0byByZW1vdmUgdGhhdCBibG9ja1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZXhwYW5kYWJsZSBuZXcgYmxvY2sgb25jbGljaycpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gdGhpcy5fZ2V0QmxvY2tQb3NpdGlvbihuZXdCbG9jayk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKG5ld0Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LnRlbXBvcmFyeUlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V2ZW50LXR5cGUnOiAncGFyc29ucy1pbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBSZWdleEV2ZW50LlBhcnNvbnNJbnB1dEFjdGlvbi5SRU1PVkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtlbmRQb3NpdGlvbiwgLTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlcjogdGhpcy5fZ2V0VGV4dEFycmF5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NvZGVDaGFuZ2VkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEluZGVudCA9IChpbmRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5jb250ZXh0QmVmb3JlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKS5zbGljZSgwLCAtMikpO1xuICAgICAgICB0aGlzLl9kcm9wQXJlYS5zdHlsZS5wYWRkaW5nTGVmdCA9IGZvbnRTaXplICogaW5kZW50ICsgJ3B4JztcbiAgICB9O1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgdmFyIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfTtcblx0cmV0dXJuIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuLyohXG4gKiBRdWlsbCBFZGl0b3IgdjEuMy43XG4gKiBodHRwczovL3F1aWxsanMuY29tL1xuICogQ29weXJpZ2h0IChjKSAyMDE0LCBKYXNvbiBDaGVuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIHNhbGVzZm9yY2UuY29tXG4gKi9cblxudmFyIHF1aWxsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMDkpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGFpbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBmb3JtYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGxlYWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIHNjcm9sbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgaW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbnZhciBibG9ja18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG52YXIgZW1iZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIHRleHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBzdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgc3RvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBQYXJjaG1lbnQgPSB7XG4gICAgU2NvcGU6IFJlZ2lzdHJ5LlNjb3BlLFxuICAgIGNyZWF0ZTogUmVnaXN0cnkuY3JlYXRlLFxuICAgIGZpbmQ6IFJlZ2lzdHJ5LmZpbmQsXG4gICAgcXVlcnk6IFJlZ2lzdHJ5LnF1ZXJ5LFxuICAgIHJlZ2lzdGVyOiBSZWdpc3RyeS5yZWdpc3RlcixcbiAgICBDb250YWluZXI6IGNvbnRhaW5lcl8xLmRlZmF1bHQsXG4gICAgRm9ybWF0OiBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIExlYWY6IGxlYWZfMS5kZWZhdWx0LFxuICAgIEVtYmVkOiBlbWJlZF8xLmRlZmF1bHQsXG4gICAgU2Nyb2xsOiBzY3JvbGxfMS5kZWZhdWx0LFxuICAgIEJsb2NrOiBibG9ja18xLmRlZmF1bHQsXG4gICAgSW5saW5lOiBpbmxpbmVfMS5kZWZhdWx0LFxuICAgIFRleHQ6IHRleHRfMS5kZWZhdWx0LFxuICAgIEF0dHJpYnV0b3I6IHtcbiAgICAgICAgQXR0cmlidXRlOiBhdHRyaWJ1dG9yXzEuZGVmYXVsdCxcbiAgICAgICAgQ2xhc3M6IGNsYXNzXzEuZGVmYXVsdCxcbiAgICAgICAgU3R5bGU6IHN0eWxlXzEuZGVmYXVsdCxcbiAgICAgICAgU3RvcmU6IHN0b3JlXzEuZGVmYXVsdCxcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBhcmNobWVudDtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFyY2htZW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcmNobWVudEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcmNobWVudEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWVzc2FnZSA9ICdbUGFyY2htZW50XSAnICsgbWVzc2FnZTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcmNobWVudEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5QYXJjaG1lbnRFcnJvciA9IFBhcmNobWVudEVycm9yO1xudmFyIGF0dHJpYnV0ZXMgPSB7fTtcbnZhciBjbGFzc2VzID0ge307XG52YXIgdGFncyA9IHt9O1xudmFyIHR5cGVzID0ge307XG5leHBvcnRzLkRBVEFfS0VZID0gJ19fYmxvdCc7XG52YXIgU2NvcGU7XG4oZnVuY3Rpb24gKFNjb3BlKSB7XG4gICAgU2NvcGVbU2NvcGVbXCJUWVBFXCJdID0gM10gPSBcIlRZUEVcIjtcbiAgICBTY29wZVtTY29wZVtcIkxFVkVMXCJdID0gMTJdID0gXCJMRVZFTFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQVRUUklCVVRFXCJdID0gMTNdID0gXCJBVFRSSUJVVEVcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT1RcIl0gPSAxNF0gPSBcIkJMT1RcIjtcbiAgICBTY29wZVtTY29wZVtcIklOTElORVwiXSA9IDddID0gXCJJTkxJTkVcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT0NLXCJdID0gMTFdID0gXCJCTE9DS1wiO1xuICAgIFNjb3BlW1Njb3BlW1wiQkxPQ0tfQkxPVFwiXSA9IDEwXSA9IFwiQkxPQ0tfQkxPVFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiSU5MSU5FX0JMT1RcIl0gPSA2XSA9IFwiSU5MSU5FX0JMT1RcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT0NLX0FUVFJJQlVURVwiXSA9IDldID0gXCJCTE9DS19BVFRSSUJVVEVcIjtcbiAgICBTY29wZVtTY29wZVtcIklOTElORV9BVFRSSUJVVEVcIl0gPSA1XSA9IFwiSU5MSU5FX0FUVFJJQlVURVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQU5ZXCJdID0gMTVdID0gXCJBTllcIjtcbn0pKFNjb3BlID0gZXhwb3J0cy5TY29wZSB8fCAoZXhwb3J0cy5TY29wZSA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGUoaW5wdXQsIHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoID0gcXVlcnkoaW5wdXQpO1xuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgXCIgKyBpbnB1dCArIFwiIGJsb3RcIik7XG4gICAgfVxuICAgIHZhciBCbG90Q2xhc3MgPSBtYXRjaDtcbiAgICB2YXIgbm9kZSA9IFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnB1dCBpbnN0YW5jZW9mIE5vZGUgfHwgaW5wdXRbJ25vZGVUeXBlJ10gPT09IE5vZGUuVEVYVF9OT0RFID8gaW5wdXQgOiBCbG90Q2xhc3MuY3JlYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IEJsb3RDbGFzcyhub2RlLCB2YWx1ZSk7XG59XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmZ1bmN0aW9uIGZpbmQobm9kZSwgYnViYmxlKSB7XG4gICAgaWYgKGJ1YmJsZSA9PT0gdm9pZCAwKSB7IGJ1YmJsZSA9IGZhbHNlOyB9XG4gICAgaWYgKG5vZGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChub2RlW2V4cG9ydHMuREFUQV9LRVldICE9IG51bGwpXG4gICAgICAgIHJldHVybiBub2RlW2V4cG9ydHMuREFUQV9LRVldLmJsb3Q7XG4gICAgaWYgKGJ1YmJsZSlcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5wYXJlbnROb2RlLCBidWJibGUpO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5maW5kID0gZmluZDtcbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCBzY29wZSkge1xuICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gU2NvcGUuQU5ZOyB9XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hdGNoID0gdHlwZXNbcXVlcnldIHx8IGF0dHJpYnV0ZXNbcXVlcnldO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgfVxuICAgIGVsc2UgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgVGV4dCB8fCBxdWVyeVsnbm9kZVR5cGUnXSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgbWF0Y2ggPSB0eXBlc1sndGV4dCddO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcXVlcnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChxdWVyeSAmIFNjb3BlLkxFVkVMICYgU2NvcGUuQkxPQ0spIHtcbiAgICAgICAgICAgIG1hdGNoID0gdHlwZXNbJ2Jsb2NrJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocXVlcnkgJiBTY29wZS5MRVZFTCAmIFNjb3BlLklOTElORSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0eXBlc1snaW5saW5lJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB2YXIgbmFtZXMgPSAocXVlcnkuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBmb3IgKHZhciBpIGluIG5hbWVzKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGNsYXNzZXNbbmFtZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gbWF0Y2ggfHwgdGFnc1txdWVyeS50YWdOYW1lXTtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoc2NvcGUgJiBTY29wZS5MRVZFTCAmIG1hdGNoLnNjb3BlICYmIHNjb3BlICYgU2NvcGUuVFlQRSAmIG1hdGNoLnNjb3BlKVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICB2YXIgRGVmaW5pdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBEZWZpbml0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoRGVmaW5pdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gRGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXIoZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgRGVmaW5pdGlvbiA9IERlZmluaXRpb25zWzBdO1xuICAgIGlmICh0eXBlb2YgRGVmaW5pdGlvbi5ibG90TmFtZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIERlZmluaXRpb24uYXR0ck5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcignSW52YWxpZCBkZWZpbml0aW9uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKERlZmluaXRpb24uYmxvdE5hbWUgPT09ICdhYnN0cmFjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYWJzdHJhY3QgY2xhc3MnKTtcbiAgICB9XG4gICAgdHlwZXNbRGVmaW5pdGlvbi5ibG90TmFtZSB8fCBEZWZpbml0aW9uLmF0dHJOYW1lXSA9IERlZmluaXRpb247XG4gICAgaWYgKHR5cGVvZiBEZWZpbml0aW9uLmtleU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbRGVmaW5pdGlvbi5rZXlOYW1lXSA9IERlZmluaXRpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoRGVmaW5pdGlvbi5jbGFzc05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xhc3Nlc1tEZWZpbml0aW9uLmNsYXNzTmFtZV0gPSBEZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZWZpbml0aW9uLnRhZ05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoRGVmaW5pdGlvbi50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIERlZmluaXRpb24udGFnTmFtZSA9IERlZmluaXRpb24udGFnTmFtZS5tYXAoZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERlZmluaXRpb24udGFnTmFtZSA9IERlZmluaXRpb24udGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZ05hbWVzID0gQXJyYXkuaXNBcnJheShEZWZpbml0aW9uLnRhZ05hbWUpID8gRGVmaW5pdGlvbi50YWdOYW1lIDogW0RlZmluaXRpb24udGFnTmFtZV07XG4gICAgICAgICAgICB0YWdOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnc1t0YWddID09IG51bGwgfHwgRGVmaW5pdGlvbi5jbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSBEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEZWZpbml0aW9uO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGlmZiA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xudmFyIGVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBvcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5cbnZhciBOVUxMX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7ICAvLyBQbGFjZWhvbGRlciBjaGFyIGZvciBlbWJlZCBpbiBkaWZmKClcblxuXG52YXIgRGVsdGEgPSBmdW5jdGlvbiAob3BzKSB7XG4gIC8vIEFzc3VtZSB3ZSBhcmUgZ2l2ZW4gYSB3ZWxsIGZvcm1lZCBvcHNcbiAgaWYgKEFycmF5LmlzQXJyYXkob3BzKSkge1xuICAgIHRoaXMub3BzID0gb3BzO1xuICB9IGVsc2UgaWYgKG9wcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkob3BzLm9wcykpIHtcbiAgICB0aGlzLm9wcyA9IG9wcy5vcHM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHMgPSBbXTtcbiAgfVxufTtcblxuXG5EZWx0YS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5ld09wID0ge307XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG5ld09wLmluc2VydCA9IHRleHQ7XG4gIGlmIChhdHRyaWJ1dGVzICE9IG51bGwgJiYgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7XG4gIHJldHVybiB0aGlzLnB1c2goeyAnZGVsZXRlJzogbGVuZ3RoIH0pO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uIChsZW5ndGgsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIG5ld09wID0geyByZXRhaW46IGxlbmd0aCB9O1xuICBpZiAoYXR0cmlidXRlcyAhPSBudWxsICYmIHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHVzaChuZXdPcCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChuZXdPcCkge1xuICB2YXIgaW5kZXggPSB0aGlzLm9wcy5sZW5ndGg7XG4gIHZhciBsYXN0T3AgPSB0aGlzLm9wc1tpbmRleCAtIDFdO1xuICBuZXdPcCA9IGV4dGVuZCh0cnVlLCB7fSwgbmV3T3ApO1xuICBpZiAodHlwZW9mIGxhc3RPcCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIG5ld09wWydkZWxldGUnXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3RPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyAnZGVsZXRlJzogbGFzdE9wWydkZWxldGUnXSArIG5ld09wWydkZWxldGUnXSB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFNpbmNlIGl0IGRvZXMgbm90IG1hdHRlciBpZiB3ZSBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyIGRlbGV0aW5nIGF0IHRoZSBzYW1lIGluZGV4LFxuICAgIC8vIGFsd2F5cyBwcmVmZXIgdG8gaW5zZXJ0IGZpcnN0XG4gICAgaWYgKHR5cGVvZiBsYXN0T3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJyAmJiBuZXdPcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgaW5kZXggLT0gMTtcbiAgICAgIGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gICAgICBpZiAodHlwZW9mIGxhc3RPcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5vcHMudW5zaGlmdChuZXdPcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXF1YWwobmV3T3AuYXR0cmlidXRlcywgbGFzdE9wLmF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIG5ld09wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IGluc2VydDogbGFzdE9wLmluc2VydCArIG5ld09wLmluc2VydCB9O1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld09wLnJldGFpbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3RPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IHJldGFpbjogbGFzdE9wLnJldGFpbiArIG5ld09wLnJldGFpbiB9O1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluZGV4ID09PSB0aGlzLm9wcy5sZW5ndGgpIHtcbiAgICB0aGlzLm9wcy5wdXNoKG5ld09wKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wcy5zcGxpY2UoaW5kZXgsIDAsIG5ld09wKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jaG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGFzdE9wID0gdGhpcy5vcHNbdGhpcy5vcHMubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0T3AgJiYgbGFzdE9wLnJldGFpbiAmJiAhbGFzdE9wLmF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLm9wcy5wb3AoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gIHJldHVybiB0aGlzLm9wcy5maWx0ZXIocHJlZGljYXRlKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICB0aGlzLm9wcy5mb3JFYWNoKHByZWRpY2F0ZSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICByZXR1cm4gdGhpcy5vcHMubWFwKHByZWRpY2F0ZSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucGFydGl0aW9uID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICB2YXIgcGFzc2VkID0gW10sIGZhaWxlZCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICB2YXIgdGFyZ2V0ID0gcHJlZGljYXRlKG9wKSA/IHBhc3NlZCA6IGZhaWxlZDtcbiAgICB0YXJnZXQucHVzaChvcCk7XG4gIH0pO1xuICByZXR1cm4gW3Bhc3NlZCwgZmFpbGVkXTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBpbml0aWFsKSB7XG4gIHJldHVybiB0aGlzLm9wcy5yZWR1Y2UocHJlZGljYXRlLCBpbml0aWFsKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jaGFuZ2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBlbGVtKSB7XG4gICAgaWYgKGVsZW0uaW5zZXJ0KSB7XG4gICAgICByZXR1cm4gbGVuZ3RoICsgb3AubGVuZ3RoKGVsZW0pO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZWxldGUpIHtcbiAgICAgIHJldHVybiBsZW5ndGggLSBlbGVtLmRlbGV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfSwgMCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgZWxlbSkge1xuICAgIHJldHVybiBsZW5ndGggKyBvcC5sZW5ndGgoZWxlbSk7XG4gIH0sIDApO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicpIGVuZCA9IEluZmluaXR5O1xuICB2YXIgb3BzID0gW107XG4gIHZhciBpdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBlbmQgJiYgaXRlci5oYXNOZXh0KCkpIHtcbiAgICB2YXIgbmV4dE9wO1xuICAgIGlmIChpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBuZXh0T3AgPSBpdGVyLm5leHQoc3RhcnQgLSBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRPcCA9IGl0ZXIubmV4dChlbmQgLSBpbmRleCk7XG4gICAgICBvcHMucHVzaChuZXh0T3ApO1xuICAgIH1cbiAgICBpbmRleCArPSBvcC5sZW5ndGgobmV4dE9wKTtcbiAgfVxuICByZXR1cm4gbmV3IERlbHRhKG9wcyk7XG59O1xuXG5cbkRlbHRhLnByb3RvdHlwZS5jb21wb3NlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciB0aGlzSXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIG90aGVySXRlciA9IG9wLml0ZXJhdG9yKG90aGVyLm9wcyk7XG4gIHZhciBvcHMgPSBbXTtcbiAgdmFyIGZpcnN0T3RoZXIgPSBvdGhlckl0ZXIucGVlaygpO1xuICBpZiAoZmlyc3RPdGhlciAhPSBudWxsICYmIHR5cGVvZiBmaXJzdE90aGVyLnJldGFpbiA9PT0gJ251bWJlcicgJiYgZmlyc3RPdGhlci5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RMZWZ0ID0gZmlyc3RPdGhlci5yZXRhaW47XG4gICAgd2hpbGUgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnICYmIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSA8PSBmaXJzdExlZnQpIHtcbiAgICAgIGZpcnN0TGVmdCAtPSB0aGlzSXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICBvcHMucHVzaCh0aGlzSXRlci5uZXh0KCkpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQgPiAwKSB7XG4gICAgICBvdGhlckl0ZXIubmV4dChmaXJzdE90aGVyLnJldGFpbiAtIGZpcnN0TGVmdCk7XG4gICAgfVxuICB9XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YShvcHMpO1xuICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIGRlbHRhLnB1c2godGhpc0l0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgdmFyIG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBvdGhlck9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIG5ld09wID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBuZXdPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3T3AuaW5zZXJ0ID0gdGhpc09wLmluc2VydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVzZXJ2ZSBudWxsIHdoZW4gY29tcG9zaW5nIHdpdGggYSByZXRhaW4sIG90aGVyd2lzZSByZW1vdmUgaXQgZm9yIGluc2VydHNcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBvcC5hdHRyaWJ1dGVzLmNvbXBvc2UodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcywgdHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICBkZWx0YS5wdXNoKG5ld09wKTtcblxuICAgICAgICAvLyBPcHRpbWl6YXRpb24gaWYgcmVzdCBvZiBvdGhlciBpcyBqdXN0IHJldGFpblxuICAgICAgICBpZiAoIW90aGVySXRlci5oYXNOZXh0KCkgJiYgZXF1YWwoZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXSwgbmV3T3ApKSB7XG4gICAgICAgICAgdmFyIHJlc3QgPSBuZXcgRGVsdGEodGhpc0l0ZXIucmVzdCgpKTtcbiAgICAgICAgICByZXR1cm4gZGVsdGEuY29uY2F0KHJlc3QpLmNob3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBPdGhlciBvcCBzaG91bGQgYmUgZGVsZXRlLCB3ZSBjb3VsZCBiZSBhbiBpbnNlcnQgb3IgcmV0YWluXG4gICAgICAvLyBJbnNlcnQgKyBkZWxldGUgY2FuY2VscyBvdXRcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG90aGVyT3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhLmNob3AoKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhKHRoaXMub3BzLnNsaWNlKCkpO1xuICBpZiAob3RoZXIub3BzLmxlbmd0aCA+IDApIHtcbiAgICBkZWx0YS5wdXNoKG90aGVyLm9wc1swXSk7XG4gICAgZGVsdGEub3BzID0gZGVsdGEub3BzLmNvbmNhdChvdGhlci5vcHMuc2xpY2UoMSkpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG90aGVyLCBpbmRleCkge1xuICBpZiAodGhpcy5vcHMgPT09IG90aGVyLm9wcykge1xuICAgIHJldHVybiBuZXcgRGVsdGEoKTtcbiAgfVxuICB2YXIgc3RyaW5ncyA9IFt0aGlzLCBvdGhlcl0ubWFwKGZ1bmN0aW9uIChkZWx0YSkge1xuICAgIHJldHVybiBkZWx0YS5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0IDogTlVMTF9DSEFSQUNURVI7XG4gICAgICB9XG4gICAgICB2YXIgcHJlcCA9IChkZWx0YSA9PT0gb3RoZXIpID8gJ29uJyA6ICd3aXRoJztcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGlmZigpIGNhbGxlZCAnICsgcHJlcCArICcgbm9uLWRvY3VtZW50Jyk7XG4gICAgfSkuam9pbignJyk7XG4gIH0pO1xuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgdmFyIGRpZmZSZXN1bHQgPSBkaWZmKHN0cmluZ3NbMF0sIHN0cmluZ3NbMV0sIGluZGV4KTtcbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb3RoZXJJdGVyID0gb3AuaXRlcmF0b3Iob3RoZXIub3BzKTtcbiAgZGlmZlJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29tcG9uZW50WzFdLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG9wTGVuZ3RoID0gMDtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50WzBdKSB7XG4gICAgICAgIGNhc2UgZGlmZi5JTlNFUlQ6XG4gICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbihvdGhlckl0ZXIucGVla0xlbmd0aCgpLCBsZW5ndGgpO1xuICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQob3BMZW5ndGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBkaWZmLkRFTEVURTpcbiAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKGxlbmd0aCwgdGhpc0l0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICB0aGlzSXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICBkZWx0YVsnZGVsZXRlJ10ob3BMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGRpZmYuRVFVQUw6XG4gICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCksIGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHRoaXNPcCA9IHRoaXNJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgIHZhciBvdGhlck9wID0gb3RoZXJJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgIGlmIChlcXVhbCh0aGlzT3AuaW5zZXJ0LCBvdGhlck9wLmluc2VydCkpIHtcbiAgICAgICAgICAgIGRlbHRhLnJldGFpbihvcExlbmd0aCwgb3AuYXR0cmlidXRlcy5kaWZmKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKVsnZGVsZXRlJ10ob3BMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlbmd0aCAtPSBvcExlbmd0aDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVsdGEuY2hvcCgpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmVhY2hMaW5lID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbmV3bGluZSkge1xuICBuZXdsaW5lID0gbmV3bGluZSB8fCAnXFxuJztcbiAgdmFyIGl0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBsaW5lID0gbmV3IERlbHRhKCk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgaWYgKGl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpIHJldHVybjtcbiAgICB2YXIgdGhpc09wID0gaXRlci5wZWVrKCk7XG4gICAgdmFyIHN0YXJ0ID0gb3AubGVuZ3RoKHRoaXNPcCkgLSBpdGVyLnBlZWtMZW5ndGgoKTtcbiAgICB2YXIgaW5kZXggPSB0eXBlb2YgdGhpc09wLmluc2VydCA9PT0gJ3N0cmluZycgP1xuICAgICAgdGhpc09wLmluc2VydC5pbmRleE9mKG5ld2xpbmUsIHN0YXJ0KSAtIHN0YXJ0IDogLTE7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dChpbmRleCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJlZGljYXRlKGxpbmUsIGl0ZXIubmV4dCgxKS5hdHRyaWJ1dGVzIHx8IHt9LCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgICAgbGluZSA9IG5ldyBEZWx0YSgpO1xuICAgIH1cbiAgfVxuICBpZiAobGluZS5sZW5ndGgoKSA+IDApIHtcbiAgICBwcmVkaWNhdGUobGluZSwge30sIGkpO1xuICB9XG59O1xuXG5EZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG90aGVyLCBwcmlvcml0eSkge1xuICBwcmlvcml0eSA9ICEhcHJpb3JpdHk7XG4gIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9zaXRpb24ob3RoZXIsIHByaW9yaXR5KTtcbiAgfVxuICB2YXIgdGhpc0l0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBvdGhlckl0ZXIgPSBvcC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSB8fCBvdGhlckl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgaWYgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnICYmIChwcmlvcml0eSB8fCBvdGhlckl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpKSB7XG4gICAgICBkZWx0YS5yZXRhaW4ob3AubGVuZ3RoKHRoaXNJdGVyLm5leHQoKSkpO1xuICAgIH0gZWxzZSBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgIHZhciB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICBpZiAodGhpc09wWydkZWxldGUnXSkge1xuICAgICAgICAvLyBPdXIgZGVsZXRlIGVpdGhlciBtYWtlcyB0aGVpciBkZWxldGUgcmVkdW5kYW50IG9yIHJlbW92ZXMgdGhlaXIgcmV0YWluXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvdGhlck9wWydkZWxldGUnXSkge1xuICAgICAgICBkZWx0YS5wdXNoKG90aGVyT3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgcmV0YWluIGVpdGhlciB0aGVpciByZXRhaW4gb3IgaW5zZXJ0XG4gICAgICAgIGRlbHRhLnJldGFpbihsZW5ndGgsIG9wLmF0dHJpYnV0ZXMudHJhbnNmb3JtKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHByaW9yaXR5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YS5jaG9wKCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHByaW9yaXR5KSB7XG4gIHByaW9yaXR5ID0gISFwcmlvcml0eTtcbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSAmJiBvZmZzZXQgPD0gaW5kZXgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpc0l0ZXIucGVla0xlbmd0aCgpO1xuICAgIHZhciBuZXh0VHlwZSA9IHRoaXNJdGVyLnBlZWtUeXBlKCk7XG4gICAgdGhpc0l0ZXIubmV4dCgpO1xuICAgIGlmIChuZXh0VHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIGluZGV4IC09IE1hdGgubWluKGxlbmd0aCwgaW5kZXggLSBvZmZzZXQpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChuZXh0VHlwZSA9PT0gJ2luc2VydCcgJiYgKG9mZnNldCA8IGluZGV4IHx8ICFwcmlvcml0eSkpIHtcbiAgICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGVsdGE7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuXHRpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xuXHR9XG5cblx0cmV0dXJuIHRvU3RyLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNJc1Byb3RvdHlwZU9mID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gb2JqKSB7IC8qKi8gfVxuXG5cdHJldHVybiB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG59O1xuXG4vLyBJZiBuYW1lIGlzICdfX3Byb3RvX18nLCBhbmQgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIGF2YWlsYWJsZSwgZGVmaW5lIF9fcHJvdG9fXyBhcyBhbiBvd24gcHJvcGVydHkgb24gdGFyZ2V0XG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMpIHtcblx0aWYgKGRlZmluZVByb3BlcnR5ICYmIG9wdGlvbnMubmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMubmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBvcHRpb25zLm5ld1ZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR0YXJnZXRbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnMubmV3VmFsdWU7XG5cdH1cbn07XG5cbi8vIFJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBfX3Byb3RvX18gaWYgJ19fcHJvdG9fXycgaXMgbm90IGFuIG93biBwcm9wZXJ0eVxudmFyIGdldFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBuYW1lKSB7XG5cdGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdGlmICghaGFzT3duLmNhbGwob2JqLCBuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9IGVsc2UgaWYgKGdPUEQpIHtcblx0XHRcdC8vIEluIGVhcmx5IHZlcnNpb25zIG9mIG5vZGUsIG9ialsnX19wcm90b19fJ10gaXMgYnVnZ3kgd2hlbiBvYmogaGFzXG5cdFx0XHQvLyBfX3Byb3RvX18gYXMgYW4gb3duIHByb3BlcnR5LiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkgd29ya3MuXG5cdFx0XHRyZXR1cm4gZ09QRChvYmosIG5hbWUpLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvYmpbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lO1xuXHR2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXHR2YXIgaSA9IDE7XG5cdHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR2YXIgZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdib29sZWFuJykge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXHRpZiAodGFyZ2V0ID09IG51bGwgfHwgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0c3JjID0gZ2V0UHJvcGVydHkodGFyZ2V0LCBuYW1lKTtcblx0XHRcdFx0Y29weSA9IGdldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUpO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKHRhcmdldCAhPT0gY29weSkge1xuXHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHRzZXRQcm9wZXJ0eSh0YXJnZXQsIHsgbmFtZTogbmFtZSwgbmV3VmFsdWU6IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSkgfSk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHNldFByb3BlcnR5KHRhcmdldCwgeyBuYW1lOiBuYW1lLCBuZXdWYWx1ZTogY29weSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5CbG9ja0VtYmVkID0gZXhwb3J0cy5idWJibGVGb3JtYXRzID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYnJlYWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9icmVhazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVhayk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBORVdMSU5FX0xFTkdUSCA9IDE7XG5cbnZhciBCbG9ja0VtYmVkID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEJsb2NrRW1iZWQsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEJsb2NrRW1iZWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrRW1iZWQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCbG9ja0VtYmVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2tFbWJlZCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJsb2NrRW1iZWQsIFt7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgX2dldChCbG9ja0VtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrRW1iZWQucHJvdG90eXBlKSwgJ2F0dGFjaCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0b3JlKHRoaXMuZG9tTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWx0YSgpIHtcbiAgICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGhpcy52YWx1ZSgpLCAoMCwgX2V4dGVuZDIuZGVmYXVsdCkodGhpcy5mb3JtYXRzKCksIHRoaXMuYXR0cmlidXRlcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DS19BVFRSSUJVVEUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5hdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZShCbG9jay5ibG90TmFtZSk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShibG9jaywgaW5kZXggPT09IDAgPyB0aGlzIDogdGhpcy5uZXh0KTtcbiAgICAgICAgYmxvY2suaW5zZXJ0QXQoMCwgdmFsdWUuc2xpY2UoMCwgLTEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoQmxvY2tFbWJlZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja0VtYmVkLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9ja0VtYmVkO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuQmxvY2tFbWJlZC5zY29wZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQkxPVDtcbi8vIEl0IGlzIGltcG9ydGFudCBmb3IgY3Vyc29yIGJlaGF2aW9yIEJsb2NrRW1iZWRzIHVzZSB0YWdzIHRoYXQgYXJlIGJsb2NrIGxldmVsIGVsZW1lbnRzXG5cblxudmFyIEJsb2NrID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQmxvY2spIHtcbiAgX2luaGVyaXRzKEJsb2NrLCBfUGFyY2htZW50JEJsb2NrKTtcblxuICBmdW5jdGlvbiBCbG9jayhkb21Ob2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrKTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jaykpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgX3RoaXMyLmNhY2hlID0ge307XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCbG9jaywgW3tcbiAgICBrZXk6ICdkZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgaWYgKHRoaXMuY2FjaGUuZGVsdGEgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlLmRlbHRhID0gdGhpcy5kZXNjZW5kYW50cyhfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYpLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGxlYWYpIHtcbiAgICAgICAgICBpZiAobGVhZi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KGxlYWYudmFsdWUoKSwgYnViYmxlRm9ybWF0cyhsZWFmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSkuaW5zZXJ0KCdcXG4nLCBidWJibGVGb3JtYXRzKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmRlbHRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnZGVsZXRlQXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykpIHtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdmb3JtYXRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIE1hdGgubWluKGxlbmd0aCwgdGhpcy5sZW5ndGgoKSAtIGluZGV4IC0gMSksIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoZGVmICE9IG51bGwpIHJldHVybiBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHRleHQgPSBsaW5lcy5zaGlmdCgpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCgpIC0gMSB8fCB0aGlzLmNoaWxkcmVuLnRhaWwgPT0gbnVsbCkge1xuICAgICAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBNYXRoLm1pbihpbmRleCwgdGhpcy5sZW5ndGgoKSAtIDEpLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRhaWwuaW5zZXJ0QXQodGhpcy5jaGlsZHJlbi50YWlsLmxlbmd0aCgpLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICB2YXIgYmxvY2sgPSB0aGlzO1xuICAgICAgbGluZXMucmVkdWNlKGZ1bmN0aW9uIChpbmRleCwgbGluZSkge1xuICAgICAgICBibG9jayA9IGJsb2NrLnNwbGl0KGluZGV4LCB0cnVlKTtcbiAgICAgICAgYmxvY2suaW5zZXJ0QXQoMCwgbGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICAgIH0sIGluZGV4ICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEJlZm9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5jaGlsZHJlbi5oZWFkO1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnaW5zZXJ0QmVmb3JlJywgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuICAgICAgaWYgKGhlYWQgaW5zdGFuY2VvZiBfYnJlYWsyLmRlZmF1bHQpIHtcbiAgICAgICAgaGVhZC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlLmxlbmd0aCA9IF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2xlbmd0aCcsIHRoaXMpLmNhbGwodGhpcykgKyBORVdMSU5FX0xFTkdUSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb3ZlQ2hpbGRyZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlQ2hpbGRyZW4odGFyZ2V0LCByZWYpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ21vdmVDaGlsZHJlbicsIHRoaXMpLmNhbGwodGhpcywgdGFyZ2V0LCByZWYpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGluZGV4KSB7XG4gICAgICByZXR1cm4gX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAncGF0aCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUNoaWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ3JlbW92ZUNoaWxkJywgdGhpcykuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3BsaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdChpbmRleCkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvcmNlICYmIChpbmRleCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCgpIC0gTkVXTElORV9MRU5HVEgpKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dCk7XG4gICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dCA9IF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ3NwbGl0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgZm9yY2UpO1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9jaztcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5CbG9jayk7XG5cbkJsb2NrLmJsb3ROYW1lID0gJ2Jsb2NrJztcbkJsb2NrLnRhZ05hbWUgPSAnUCc7XG5CbG9jay5kZWZhdWx0Q2hpbGQgPSAnYnJlYWsnO1xuQmxvY2suYWxsb3dlZENoaWxkcmVuID0gW19pbmxpbmUyLmRlZmF1bHQsIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQsIF90ZXh0Mi5kZWZhdWx0XTtcblxuZnVuY3Rpb24gYnViYmxlRm9ybWF0cyhibG90KSB7XG4gIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm4gZm9ybWF0cztcbiAgaWYgKHR5cGVvZiBibG90LmZvcm1hdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGZvcm1hdHMsIGJsb3QuZm9ybWF0cygpKTtcbiAgfVxuICBpZiAoYmxvdC5wYXJlbnQgPT0gbnVsbCB8fCBibG90LnBhcmVudC5ibG90TmFtZSA9PSAnc2Nyb2xsJyB8fCBibG90LnBhcmVudC5zdGF0aWNzLnNjb3BlICE9PSBibG90LnN0YXRpY3Muc2NvcGUpIHtcbiAgICByZXR1cm4gZm9ybWF0cztcbiAgfVxuICByZXR1cm4gYnViYmxlRm9ybWF0cyhibG90LnBhcmVudCwgZm9ybWF0cyk7XG59XG5cbmV4cG9ydHMuYnViYmxlRm9ybWF0cyA9IGJ1YmJsZUZvcm1hdHM7XG5leHBvcnRzLkJsb2NrRW1iZWQgPSBCbG9ja0VtYmVkO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2s7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLm92ZXJsb2FkID0gZXhwb3J0cy5leHBhbmRDb25maWcgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX2VkaXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX2VkaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lZGl0b3IpO1xuXG52YXIgX2VtaXR0ZXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIzKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfc2VsZWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdGlvbik7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIF90aGVtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX3RoZW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW1lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbCcpO1xuXG52YXIgUXVpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhRdWlsbCwgbnVsbCwgW3tcbiAgICBrZXk6ICdkZWJ1ZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYnVnKGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgbGltaXQgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIF9sb2dnZXIyLmRlZmF1bHQubGV2ZWwobGltaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLl9fcXVpbGwgfHwgX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbXBvcnQobmFtZSkge1xuICAgICAgaWYgKHRoaXMuaW1wb3J0c1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnLmVycm9yKCdDYW5ub3QgaW1wb3J0ICcgKyBuYW1lICsgJy4gQXJlIHlvdSBzdXJlIGl0IHdhcyByZWdpc3RlcmVkPycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0c1tuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHBhdGgsIHRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXRoLmF0dHJOYW1lIHx8IHBhdGguYmxvdE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyByZWdpc3RlcihCbG90IHwgQXR0cmlidXRvciwgb3ZlcndyaXRlKVxuICAgICAgICAgIHRoaXMucmVnaXN0ZXIoJ2Zvcm1hdHMvJyArIG5hbWUsIHBhdGgsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMocGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5yZWdpc3RlcihrZXksIHBhdGhba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1twYXRoXSAhPSBudWxsICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKCdPdmVyd3JpdGluZyAnICsgcGF0aCArICcgd2l0aCcsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXBvcnRzW3BhdGhdID0gdGFyZ2V0O1xuICAgICAgICBpZiAoKHBhdGguc3RhcnRzV2l0aCgnYmxvdHMvJykgfHwgcGF0aC5zdGFydHNXaXRoKCdmb3JtYXRzLycpKSAmJiB0YXJnZXQuYmxvdE5hbWUgIT09ICdhYnN0cmFjdCcpIHtcbiAgICAgICAgICBfcGFyY2htZW50Mi5kZWZhdWx0LnJlZ2lzdGVyKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKCdtb2R1bGVzJykgJiYgdHlwZW9mIHRhcmdldC5yZWdpc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRhcmdldC5yZWdpc3RlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gUXVpbGwoY29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpbGwpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gZXhwYW5kQ29uZmlnKGNvbnRhaW5lciwgb3B0aW9ucyk7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVidWcuZXJyb3IoJ0ludmFsaWQgUXVpbGwgY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgUXVpbGwuZGVidWcodGhpcy5vcHRpb25zLmRlYnVnKTtcbiAgICB9XG4gICAgdmFyIGh0bWwgPSB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwudHJpbSgpO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuY29udGFpbmVyLl9fcXVpbGwgPSB0aGlzO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkQ29udGFpbmVyKCdxbC1lZGl0b3InKTtcbiAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtYmxhbmsnKTtcbiAgICB0aGlzLnJvb3Quc2V0QXR0cmlidXRlKCdkYXRhLWdyYW1tJywgZmFsc2UpO1xuICAgIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyID0gdGhpcy5vcHRpb25zLnNjcm9sbGluZ0NvbnRhaW5lciB8fCB0aGlzLnJvb3Q7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IF9lbWl0dGVyNC5kZWZhdWx0KCk7XG4gICAgdGhpcy5zY3JvbGwgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnJvb3QsIHtcbiAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgIHdoaXRlbGlzdDogdGhpcy5vcHRpb25zLmZvcm1hdHNcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IG5ldyBfZWRpdG9yMi5kZWZhdWx0KHRoaXMuc2Nyb2xsKTtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBfc2VsZWN0aW9uMi5kZWZhdWx0KHRoaXMuc2Nyb2xsLCB0aGlzLmVtaXR0ZXIpO1xuICAgIHRoaXMudGhlbWUgPSBuZXcgdGhpcy5vcHRpb25zLnRoZW1lKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5rZXlib2FyZCA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdrZXlib2FyZCcpO1xuICAgIHRoaXMuY2xpcGJvYXJkID0gdGhpcy50aGVtZS5hZGRNb2R1bGUoJ2NsaXBib2FyZCcpO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdoaXN0b3J5Jyk7XG4gICAgdGhpcy50aGVtZS5pbml0KCk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSkge1xuICAgICAgICBfdGhpczIucm9vdC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1ibGFuaycsIF90aGlzMi5lZGl0b3IuaXNCbGFuaygpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9VUERBVEUsIGZ1bmN0aW9uIChzb3VyY2UsIG11dGF0aW9ucykge1xuICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLnNlbGVjdGlvbi5sYXN0UmFuZ2U7XG4gICAgICB2YXIgaW5kZXggPSByYW5nZSAmJiByYW5nZS5sZW5ndGggPT09IDAgPyByYW5nZS5pbmRleCA6IHVuZGVmaW5lZDtcbiAgICAgIG1vZGlmeS5jYWxsKF90aGlzMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVkaXRvci51cGRhdGUobnVsbCwgbXV0YXRpb25zLCBpbmRleCk7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH0pO1xuICAgIHZhciBjb250ZW50cyA9IHRoaXMuY2xpcGJvYXJkLmNvbnZlcnQoJzxkaXYgY2xhc3M9XFwncWwtZWRpdG9yXFwnIHN0eWxlPVwid2hpdGUtc3BhY2U6IG5vcm1hbDtcIj4nICsgaHRtbCArICc8cD48YnI+PC9wPjwvZGl2PicpO1xuICAgIHRoaXMuc2V0Q29udGVudHMoY29udGVudHMpO1xuICAgIHRoaXMuaGlzdG9yeS5jbGVhcigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMucm9vdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInLCB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVpbGwsIFt7XG4gICAga2V5OiAnYWRkQ29udGFpbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdmFyIHJlZk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIHJlZk5vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdibHVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVUZXh0KGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZCwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMlswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDJbMV07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQyWzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmVkaXRvci5kZWxldGVUZXh0KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgLTEgKiBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGUoZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLnNjcm9sbC5lbmFibGUoZW5hYmxlZCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKCdxbC1kaXNhYmxlZCcsICFlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmZvY3VzKCk7XG4gICAgICB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICB0aGlzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzNC5nZXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykpIHtcbiAgICAgICAgICBjaGFuZ2UgPSBfdGhpczQuZWRpdG9yLmZvcm1hdExpbmUocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF90aGlzNC5zZWxlY3Rpb24uZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZSA9IF90aGlzNC5lZGl0b3IuZm9ybWF0VGV4dChyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM0LnNldFNlbGVjdGlvbihyYW5nZSwgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQzID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ0ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMywgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkNFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDRbMV07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkNFsyXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDRbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuZWRpdG9yLmZvcm1hdExpbmUoaW5kZXgsIGxlbmd0aCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGV4dChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ1ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ2ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkNSwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkNlswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDZbMV07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkNlsyXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDZbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuZWRpdG9yLmZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCb3VuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZHMoaW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIHZhciBib3VuZHMgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBib3VuZHMgPSB0aGlzLnNlbGVjdGlvbi5nZXRCb3VuZHMoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZHMgPSB0aGlzLnNlbGVjdGlvbi5nZXRCb3VuZHMoaW5kZXguaW5kZXgsIGluZGV4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGFpbmVyQm91bmRzID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3R0b206IGJvdW5kcy5ib3R0b20gLSBjb250YWluZXJCb3VuZHMudG9wLFxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0IC0gY29udGFpbmVyQm91bmRzLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBib3VuZHMucmlnaHQgLSBjb250YWluZXJCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBib3VuZHMudG9wIC0gY29udGFpbmVyQm91bmRzLnRvcCxcbiAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb250ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnRzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5nZXRMZW5ndGgoKSAtIGluZGV4O1xuXG4gICAgICB2YXIgX292ZXJsb2FkNyA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkOCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDcsIDIpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDhbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQ4WzFdO1xuXG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRGb3JtYXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Rm9ybWF0KGluZGV4LmluZGV4LCBpbmRleC5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoYmxvdCkge1xuICAgICAgcmV0dXJuIGJsb3Qub2Zmc2V0KHRoaXMuc2Nyb2xsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGVhZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlYWYoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5sZWFmKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZShpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmUoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZXMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoaW5kZXguaW5kZXgsIGluZGV4Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW1lLm1vZHVsZXNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgdmFyIGZvY3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvY3VzKSB0aGlzLmZvY3VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpOyAvLyBNYWtlIHN1cmUgd2UgYWNjZXNzIGdldFJhbmdlIHdpdGggZWRpdG9yIGluIGNvbnNpc3RlbnQgc3RhdGVcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5nZXRMZW5ndGgoKSAtIGluZGV4O1xuXG4gICAgICB2YXIgX292ZXJsb2FkOSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTAgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQ5LCAyKTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxMFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDEwWzFdO1xuXG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0VGV4dChpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNGb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmhhc0ZvY3VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0RW1iZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogUXVpbGwuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuZWRpdG9yLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgdmFsdWUpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRleHQoaW5kZXgsIHRleHQsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9vdmVybG9hZDExID0gb3ZlcmxvYWQoaW5kZXgsIDAsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTIgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxMSwgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTJbMF07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkMTJbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQxMlszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5lZGl0b3IuaW5zZXJ0VGV4dChpbmRleCwgdGV4dCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNFbmFibGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWRpc2FibGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vZmYuYXBwbHkodGhpcy5lbWl0dGVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub25jZS5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGFzdGVIVE1MJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFzdGVIVE1MKGluZGV4LCBodG1sLCBzb3VyY2UpIHtcbiAgICAgIHRoaXMuY2xpcGJvYXJkLmRhbmdlcm91c2x5UGFzdGVIVE1MKGluZGV4LCBodG1sLCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZvcm1hdChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTMgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTQgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxMywgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTRbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxNFsxXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDE0WzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM5LmVkaXRvci5yZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY3JvbGxJbnRvVmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldENvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGVudHMoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KGRlbHRhKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IF90aGlzMTAuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBkZWxldGVkID0gX3RoaXMxMC5lZGl0b3IuZGVsZXRlVGV4dCgwLCBsZW5ndGgpO1xuICAgICAgICB2YXIgYXBwbGllZCA9IF90aGlzMTAuZWRpdG9yLmFwcGx5RGVsdGEoZGVsdGEpO1xuICAgICAgICB2YXIgbGFzdE9wID0gYXBwbGllZC5vcHNbYXBwbGllZC5vcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0T3AgIT0gbnVsbCAmJiB0eXBlb2YgbGFzdE9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgbGFzdE9wLmluc2VydFtsYXN0T3AuaW5zZXJ0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgICAgIF90aGlzMTAuZWRpdG9yLmRlbGV0ZVRleHQoX3RoaXMxMC5nZXRMZW5ndGgoKSAtIDEsIDEpO1xuICAgICAgICAgIGFwcGxpZWQuZGVsZXRlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBkZWxldGVkLmNvbXBvc2UoYXBwbGllZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFNlbGVjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG51bGwsIGxlbmd0aCB8fCBRdWlsbC5zb3VyY2VzLkFQSSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX292ZXJsb2FkMTUgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICAgIHZhciBfb3ZlcmxvYWQxNiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDE1LCA0KTtcblxuICAgICAgICBpbmRleCA9IF9vdmVybG9hZDE2WzBdO1xuICAgICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxNlsxXTtcbiAgICAgICAgc291cmNlID0gX292ZXJsb2FkMTZbM107XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UobmV3IF9zZWxlY3Rpb24uUmFuZ2UoaW5kZXgsIGxlbmd0aCksIHNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHQodGV4dCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0ZXh0KTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvbnRlbnRzKGRlbHRhLCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUjtcblxuICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuc2Nyb2xsLnVwZGF0ZShzb3VyY2UpOyAvLyBXaWxsIHVwZGF0ZSBzZWxlY3Rpb24gYmVmb3JlIHNlbGVjdGlvbi51cGRhdGUoKSBkb2VzIGlmIHRleHQgY2hhbmdlc1xuICAgICAgdGhpcy5zZWxlY3Rpb24udXBkYXRlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUNvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ29udGVudHMoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIF90aGlzMTEuZWRpdG9yLmFwcGx5RGVsdGEoZGVsdGEsIHNvdXJjZSk7XG4gICAgICB9LCBzb3VyY2UsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlsbDtcbn0oKTtcblxuUXVpbGwuREVGQVVMVFMgPSB7XG4gIGJvdW5kczogbnVsbCxcbiAgZm9ybWF0czogbnVsbCxcbiAgbW9kdWxlczoge30sXG4gIHBsYWNlaG9sZGVyOiAnJyxcbiAgcmVhZE9ubHk6IGZhbHNlLFxuICBzY3JvbGxpbmdDb250YWluZXI6IG51bGwsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdGhlbWU6ICdkZWZhdWx0J1xufTtcblF1aWxsLmV2ZW50cyA9IF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cztcblF1aWxsLnNvdXJjZXMgPSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5RdWlsbC52ZXJzaW9uID0gIFwiMS4zLjdcIjtcblxuUXVpbGwuaW1wb3J0cyA9IHtcbiAgJ2RlbHRhJzogX3F1aWxsRGVsdGEyLmRlZmF1bHQsXG4gICdwYXJjaG1lbnQnOiBfcGFyY2htZW50Mi5kZWZhdWx0LFxuICAnY29yZS9tb2R1bGUnOiBfbW9kdWxlMi5kZWZhdWx0LFxuICAnY29yZS90aGVtZSc6IF90aGVtZTIuZGVmYXVsdFxufTtcblxuZnVuY3Rpb24gZXhwYW5kQ29uZmlnKGNvbnRhaW5lciwgdXNlckNvbmZpZykge1xuICB1c2VyQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBtb2R1bGVzOiB7XG4gICAgICBjbGlwYm9hcmQ6IHRydWUsXG4gICAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICAgIGhpc3Rvcnk6IHRydWVcbiAgICB9XG4gIH0sIHVzZXJDb25maWcpO1xuICBpZiAoIXVzZXJDb25maWcudGhlbWUgfHwgdXNlckNvbmZpZy50aGVtZSA9PT0gUXVpbGwuREVGQVVMVFMudGhlbWUpIHtcbiAgICB1c2VyQ29uZmlnLnRoZW1lID0gX3RoZW1lMi5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIHVzZXJDb25maWcudGhlbWUgPSBRdWlsbC5pbXBvcnQoJ3RoZW1lcy8nICsgdXNlckNvbmZpZy50aGVtZSk7XG4gICAgaWYgKHVzZXJDb25maWcudGhlbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRoZW1lICcgKyB1c2VyQ29uZmlnLnRoZW1lICsgJy4gRGlkIHlvdSByZWdpc3RlciBpdD8nKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRoZW1lQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCB1c2VyQ29uZmlnLnRoZW1lLkRFRkFVTFRTKTtcbiAgW3RoZW1lQ29uZmlnLCB1c2VyQ29uZmlnXS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBjb25maWcubW9kdWxlcyA9IGNvbmZpZy5tb2R1bGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGNvbmZpZy5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIGlmIChjb25maWcubW9kdWxlc1ttb2R1bGVdID09PSB0cnVlKSB7XG4gICAgICAgIGNvbmZpZy5tb2R1bGVzW21vZHVsZV0gPSB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHZhciBtb2R1bGVOYW1lcyA9IE9iamVjdC5rZXlzKHRoZW1lQ29uZmlnLm1vZHVsZXMpLmNvbmNhdChPYmplY3Qua2V5cyh1c2VyQ29uZmlnLm1vZHVsZXMpKTtcbiAgdmFyIG1vZHVsZUNvbmZpZyA9IG1vZHVsZU5hbWVzLnJlZHVjZShmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZUNsYXNzID0gUXVpbGwuaW1wb3J0KCdtb2R1bGVzLycgKyBuYW1lKTtcbiAgICBpZiAobW9kdWxlQ2xhc3MgPT0gbnVsbCkge1xuICAgICAgZGVidWcuZXJyb3IoJ0Nhbm5vdCBsb2FkICcgKyBuYW1lICsgJyBtb2R1bGUuIEFyZSB5b3Ugc3VyZSB5b3UgcmVnaXN0ZXJlZCBpdD8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnW25hbWVdID0gbW9kdWxlQ2xhc3MuREVGQVVMVFMgfHwge307XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH0sIHt9KTtcbiAgLy8gU3BlY2lhbCBjYXNlIHRvb2xiYXIgc2hvcnRoYW5kXG4gIGlmICh1c2VyQ29uZmlnLm1vZHVsZXMgIT0gbnVsbCAmJiB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhciAmJiB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXIgPSB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyXG4gICAgfTtcbiAgfVxuICB1c2VyQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBRdWlsbC5ERUZBVUxUUywgeyBtb2R1bGVzOiBtb2R1bGVDb25maWcgfSwgdGhlbWVDb25maWcsIHVzZXJDb25maWcpO1xuICBbJ2JvdW5kcycsICdjb250YWluZXInLCAnc2Nyb2xsaW5nQ29udGFpbmVyJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB1c2VyQ29uZmlnW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHVzZXJDb25maWdba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgdXNlckNvbmZpZy5tb2R1bGVzID0gT2JqZWN0LmtleXModXNlckNvbmZpZy5tb2R1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgIGlmICh1c2VyQ29uZmlnLm1vZHVsZXNbbmFtZV0pIHtcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IHVzZXJDb25maWcubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSwge30pO1xuICByZXR1cm4gdXNlckNvbmZpZztcbn1cblxuLy8gSGFuZGxlIHNlbGVjdGlvbiBwcmVzZXJ2YXRpb24gYW5kIFRFWFRfQ0hBTkdFIGVtaXNzaW9uXG4vLyBjb21tb24gdG8gbW9kaWZpY2F0aW9uIEFQSXNcbmZ1bmN0aW9uIG1vZGlmeShtb2RpZmllciwgc291cmNlLCBpbmRleCwgc2hpZnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgIXRoaXMuaXNFbmFibGVkKCkgJiYgc291cmNlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHtcbiAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG4gIH1cbiAgdmFyIHJhbmdlID0gaW5kZXggPT0gbnVsbCA/IG51bGwgOiB0aGlzLmdldFNlbGVjdGlvbigpO1xuICB2YXIgb2xkRGVsdGEgPSB0aGlzLmVkaXRvci5kZWx0YTtcbiAgdmFyIGNoYW5nZSA9IG1vZGlmaWVyKCk7XG4gIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgaWYgKGluZGV4ID09PSB0cnVlKSBpbmRleCA9IHJhbmdlLmluZGV4O1xuICAgIGlmIChzaGlmdCA9PSBudWxsKSB7XG4gICAgICByYW5nZSA9IHNoaWZ0UmFuZ2UocmFuZ2UsIGNoYW5nZSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICByYW5nZSA9IHNoaWZ0UmFuZ2UocmFuZ2UsIGluZGV4LCBzaGlmdCwgc291cmNlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UsIF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgfVxuICBpZiAoY2hhbmdlLmxlbmd0aCgpID4gMCkge1xuICAgIHZhciBfZW1pdHRlcjtcblxuICAgIHZhciBhcmdzID0gW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSwgY2hhbmdlLCBvbGREZWx0YSwgc291cmNlXTtcbiAgICAoX2VtaXR0ZXIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX2VtaXR0ZXIsIFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRV0uY29uY2F0KGFyZ3MpKTtcbiAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCkge1xuICAgICAgdmFyIF9lbWl0dGVyMjtcblxuICAgICAgKF9lbWl0dGVyMiA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlcjIsIGFyZ3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlO1xufVxuXG5mdW5jdGlvbiBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIGlmICh0eXBlb2YgaW5kZXguaW5kZXggPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmRleC5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gQWxsb3cgZm9yIHRocm93YXdheSBlbmQgKHVzZWQgYnkgaW5zZXJ0VGV4dC9pbnNlcnRFbWJlZClcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHNvdXJjZSA9IHZhbHVlLCB2YWx1ZSA9IG5hbWUsIG5hbWUgPSBsZW5ndGgsIGxlbmd0aCA9IGluZGV4Lmxlbmd0aCwgaW5kZXggPSBpbmRleC5pbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gaW5kZXgubGVuZ3RoLCBpbmRleCA9IGluZGV4LmluZGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHNvdXJjZSA9IHZhbHVlLCB2YWx1ZSA9IG5hbWUsIG5hbWUgPSBsZW5ndGgsIGxlbmd0aCA9IDA7XG4gIH1cbiAgLy8gSGFuZGxlIGZvcm1hdCBiZWluZyBvYmplY3QsIHR3byBmb3JtYXQgbmFtZS92YWx1ZSBzdHJpbmdzIG9yIGV4Y2x1ZGVkXG4gIGlmICgodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3JtYXRzID0gbmFtZTtcbiAgICBzb3VyY2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0c1tuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSBuYW1lO1xuICAgIH1cbiAgfVxuICAvLyBIYW5kbGUgb3B0aW9uYWwgc291cmNlXG4gIHNvdXJjZSA9IHNvdXJjZSB8fCBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcbiAgcmV0dXJuIFtpbmRleCwgbGVuZ3RoLCBmb3JtYXRzLCBzb3VyY2VdO1xufVxuXG5mdW5jdGlvbiBzaGlmdFJhbmdlKHJhbmdlLCBpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgc3RhcnQgPSB2b2lkIDAsXG4gICAgICBlbmQgPSB2b2lkIDA7XG4gIGlmIChpbmRleCBpbnN0YW5jZW9mIF9xdWlsbERlbHRhMi5kZWZhdWx0KSB7XG4gICAgdmFyIF9tYXAgPSBbcmFuZ2UuaW5kZXgsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIGluZGV4LnRyYW5zZm9ybVBvc2l0aW9uKHBvcywgc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMik7XG5cbiAgICBzdGFydCA9IF9tYXAyWzBdO1xuICAgIGVuZCA9IF9tYXAyWzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBfbWFwMyA9IFtyYW5nZS5pbmRleCwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGhdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBpZiAocG9zIDwgaW5kZXggfHwgcG9zID09PSBpbmRleCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUikgcmV0dXJuIHBvcztcbiAgICAgIGlmIChsZW5ndGggPj0gMCkge1xuICAgICAgICByZXR1cm4gcG9zICsgbGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGluZGV4LCBwb3MgKyBsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF9tYXA0ID0gX3NsaWNlZFRvQXJyYXkoX21hcDMsIDIpO1xuXG4gICAgc3RhcnQgPSBfbWFwNFswXTtcbiAgICBlbmQgPSBfbWFwNFsxXTtcbiAgfVxuICByZXR1cm4gbmV3IF9zZWxlY3Rpb24uUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbn1cblxuZXhwb3J0cy5leHBhbmRDb25maWcgPSBleHBhbmRDb25maWc7XG5leHBvcnRzLm92ZXJsb2FkID0gb3ZlcmxvYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWlsbDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSW5saW5lID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkSW5saW5lKSB7XG4gIF9pbmhlcml0cyhJbmxpbmUsIF9QYXJjaG1lbnQkSW5saW5lKTtcblxuICBmdW5jdGlvbiBJbmxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKElubGluZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElubGluZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElubGluZSwgW3tcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoSW5saW5lLmNvbXBhcmUodGhpcy5zdGF0aWNzLmJsb3ROYW1lLCBuYW1lKSA8IDAgJiYgX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT1QpKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBibG90LndyYXAobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KElubGluZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmxpbmUucHJvdG90eXBlKSwgJ2Zvcm1hdEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KElubGluZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmxpbmUucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIElubGluZSAmJiBJbmxpbmUuY29tcGFyZSh0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIHRoaXMucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUpID4gMCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQuaXNvbGF0ZSh0aGlzLm9mZnNldCgpLCB0aGlzLmxlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5tb3ZlQ2hpbGRyZW4ocGFyZW50KTtcbiAgICAgICAgcGFyZW50LndyYXAodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjb21wYXJlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShzZWxmLCBvdGhlcikge1xuICAgICAgdmFyIHNlbGZJbmRleCA9IElubGluZS5vcmRlci5pbmRleE9mKHNlbGYpO1xuICAgICAgdmFyIG90aGVySW5kZXggPSBJbmxpbmUub3JkZXIuaW5kZXhPZihvdGhlcik7XG4gICAgICBpZiAoc2VsZkluZGV4ID49IDAgfHwgb3RoZXJJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmSW5kZXggLSBvdGhlckluZGV4O1xuICAgICAgfSBlbHNlIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmxpbmU7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuSW5saW5lKTtcblxuSW5saW5lLmFsbG93ZWRDaGlsZHJlbiA9IFtJbmxpbmUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQsIF90ZXh0Mi5kZWZhdWx0XTtcbi8vIExvd2VyIGluZGV4IG1lYW5zIGRlZXBlciBpbiB0aGUgRE9NIHRyZWUsIHNpbmNlIG5vdCBmb3VuZCAoLTEpIGlzIGZvciBlbWJlZHNcbklubGluZS5vcmRlciA9IFsnY3Vyc29yJywgJ2lubGluZScsIC8vIE11c3QgYmUgbG93ZXJcbid1bmRlcmxpbmUnLCAnc3RyaWtlJywgJ2l0YWxpYycsICdib2xkJywgJ3NjcmlwdCcsICdsaW5rJywgJ2NvZGUnIC8vIE11c3QgYmUgaGlnaGVyXG5dO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmxpbmU7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVGV4dEJsb3QgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRUZXh0KSB7XG4gIF9pbmhlcml0cyhUZXh0QmxvdCwgX1BhcmNobWVudCRUZXh0KTtcblxuICBmdW5jdGlvbiBUZXh0QmxvdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEJsb3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0QmxvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRCbG90KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gVGV4dEJsb3Q7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuVGV4dCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRCbG90O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDpldmVudHMnKTtcblxudmFyIEVWRU5UUyA9IFsnc2VsZWN0aW9uY2hhbmdlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ2NsaWNrJ107XG5cbkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5xbC1jb250YWluZXInKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gVE9ETyB1c2UgV2Vha01hcFxuICAgICAgaWYgKG5vZGUuX19xdWlsbCAmJiBub2RlLl9fcXVpbGwuZW1pdHRlcikge1xuICAgICAgICB2YXIgX25vZGUkX19xdWlsbCRlbWl0dGVyO1xuXG4gICAgICAgIChfbm9kZSRfX3F1aWxsJGVtaXR0ZXIgPSBub2RlLl9fcXVpbGwuZW1pdHRlcikuaGFuZGxlRE9NLmFwcGx5KF9ub2RlJF9fcXVpbGwkZW1pdHRlciwgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbnZhciBFbWl0dGVyID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEVtaXR0ZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVtaXR0ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWl0dGVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICBfdGhpcy5vbignZXJyb3InLCBkZWJ1Zy5lcnJvcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAga2V5OiAnZW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgICBkZWJ1Zy5sb2cuYXBwbHkoZGVidWcsIGFyZ3VtZW50cyk7XG4gICAgICBfZ2V0KEVtaXR0ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1pdHRlci5wcm90b3R5cGUpLCAnZW1pdCcsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRE9NKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXI7XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gbm9kZSB8fCBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaXN0ZW5ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5ET00oZXZlbnROYW1lLCBub2RlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKHsgbm9kZTogbm9kZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1pdHRlcjtcbn0oX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdCk7XG5cbkVtaXR0ZXIuZXZlbnRzID0ge1xuICBFRElUT1JfQ0hBTkdFOiAnZWRpdG9yLWNoYW5nZScsXG4gIFNDUk9MTF9CRUZPUkVfVVBEQVRFOiAnc2Nyb2xsLWJlZm9yZS11cGRhdGUnLFxuICBTQ1JPTExfT1BUSU1JWkU6ICdzY3JvbGwtb3B0aW1pemUnLFxuICBTQ1JPTExfVVBEQVRFOiAnc2Nyb2xsLXVwZGF0ZScsXG4gIFNFTEVDVElPTl9DSEFOR0U6ICdzZWxlY3Rpb24tY2hhbmdlJyxcbiAgVEVYVF9DSEFOR0U6ICd0ZXh0LWNoYW5nZSdcbn07XG5FbWl0dGVyLnNvdXJjZXMgPSB7XG4gIEFQSTogJ2FwaScsXG4gIFNJTEVOVDogJ3NpbGVudCcsXG4gIFVTRVI6ICd1c2VyJ1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZShxdWlsbCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZSk7XG5cbiAgdGhpcy5xdWlsbCA9IHF1aWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuTW9kdWxlLkRFRkFVTFRTID0ge307XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsZTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgbGV2ZWxzID0gWydlcnJvcicsICd3YXJuJywgJ2xvZycsICdpbmZvJ107XG52YXIgbGV2ZWwgPSAnd2Fybic7XG5cbmZ1bmN0aW9uIGRlYnVnKG1ldGhvZCkge1xuICBpZiAobGV2ZWxzLmluZGV4T2YobWV0aG9kKSA8PSBsZXZlbHMuaW5kZXhPZihsZXZlbCkpIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpW21ldGhvZF0uYXBwbHkoX2NvbnNvbGUsIGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxufVxuXG5mdW5jdGlvbiBuYW1lc3BhY2UobnMpIHtcbiAgcmV0dXJuIGxldmVscy5yZWR1Y2UoZnVuY3Rpb24gKGxvZ2dlciwgbWV0aG9kKSB7XG4gICAgbG9nZ2VyW21ldGhvZF0gPSBkZWJ1Zy5iaW5kKGNvbnNvbGUsIG1ldGhvZCwgbnMpO1xuICAgIHJldHVybiBsb2dnZXI7XG4gIH0sIHt9KTtcbn1cblxuZGVidWcubGV2ZWwgPSBuYW1lc3BhY2UubGV2ZWwgPSBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzcGFjZTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBdHRyaWJ1dG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0b3IoYXR0ck5hbWUsIGtleU5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgICAgICB0aGlzLmtleU5hbWUgPSBrZXlOYW1lO1xuICAgICAgICB2YXIgYXR0cmlidXRlQml0ID0gUmVnaXN0cnkuU2NvcGUuVFlQRSAmIFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIHR5cGUgYml0cywgZm9yY2UgYXR0cmlidXRlIGJpdFxuICAgICAgICAgICAgdGhpcy5zY29wZSA9IChvcHRpb25zLnNjb3BlICYgUmVnaXN0cnkuU2NvcGUuTEVWRUwpIHwgYXR0cmlidXRlQml0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aGl0ZWxpc3QgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMud2hpdGVsaXN0ID0gb3B0aW9ucy53aGl0ZWxpc3Q7XG4gICAgfVxuICAgIEF0dHJpYnV0b3Iua2V5cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXS5tYXAuY2FsbChub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUuY2FuQWRkID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IFJlZ2lzdHJ5LnF1ZXJ5KG5vZGUsIFJlZ2lzdHJ5LlNjb3BlLkJMT1QgJiAodGhpcy5zY29wZSB8IFJlZ2lzdHJ5LlNjb3BlLlRZUEUpKTtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLndoaXRlbGlzdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGl0ZWxpc3QuaW5kZXhPZih2YWx1ZS5yZXBsYWNlKC9bXCInXS9nLCAnJykpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGl0ZWxpc3QuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBBdHRyaWJ1dG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJpYnV0b3I7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkNvZGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29kZSA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhDb2RlLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBDb2RlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2RlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBDb2RlO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuQ29kZS5ibG90TmFtZSA9ICdjb2RlJztcbkNvZGUudGFnTmFtZSA9ICdDT0RFJztcblxudmFyIENvZGVCbG9jayA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKENvZGVCbG9jaywgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBDb2RlQmxvY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvZGVCbG9jayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvZGVCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jaykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvZGVCbG9jaywgW3tcbiAgICBrZXk6ICdkZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgdHJ1ZVxuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dC5zcGxpdCgnXFxuJykucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgZnJhZykge1xuICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KGZyYWcpLmluc2VydCgnXFxuJywgX3RoaXMzLmZvcm1hdHMoKSk7XG4gICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIHZhbHVlKSByZXR1cm47XG5cbiAgICAgIHZhciBfZGVzY2VuZGFudCA9IHRoaXMuZGVzY2VuZGFudChfdGV4dDIuZGVmYXVsdCwgdGhpcy5sZW5ndGgoKSAtIDEpLFxuICAgICAgICAgIF9kZXNjZW5kYW50MiA9IF9zbGljZWRUb0FycmF5KF9kZXNjZW5kYW50LCAxKSxcbiAgICAgICAgICB0ZXh0ID0gX2Rlc2NlbmRhbnQyWzBdO1xuXG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHRleHQuZGVsZXRlQXQodGV4dC5sZW5ndGgoKSAtIDEsIDEpO1xuICAgICAgfVxuICAgICAgX2dldChDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSA9PSBudWxsIHx8IG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiB2YWx1ZSA9PT0gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV4dE5ld2xpbmUgPSB0aGlzLm5ld2xpbmVJbmRleChpbmRleCk7XG4gICAgICBpZiAobmV4dE5ld2xpbmUgPCAwIHx8IG5leHROZXdsaW5lID49IGluZGV4ICsgbGVuZ3RoKSByZXR1cm47XG4gICAgICB2YXIgcHJldk5ld2xpbmUgPSB0aGlzLm5ld2xpbmVJbmRleChpbmRleCwgdHJ1ZSkgKyAxO1xuICAgICAgdmFyIGlzb2xhdGVMZW5ndGggPSBuZXh0TmV3bGluZSAtIHByZXZOZXdsaW5lICsgMTtcbiAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKHByZXZOZXdsaW5lLCBpc29sYXRlTGVuZ3RoKTtcbiAgICAgIHZhciBuZXh0ID0gYmxvdC5uZXh0O1xuICAgICAgYmxvdC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBDb2RlQmxvY2spIHtcbiAgICAgICAgbmV4dC5mb3JtYXRBdCgwLCBpbmRleCAtIHByZXZOZXdsaW5lICsgbGVuZ3RoIC0gaXNvbGF0ZUxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmIChkZWYgIT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2Rlc2NlbmRhbnQzID0gdGhpcy5kZXNjZW5kYW50KF90ZXh0Mi5kZWZhdWx0LCBpbmRleCksXG4gICAgICAgICAgX2Rlc2NlbmRhbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX2Rlc2NlbmRhbnQzLCAyKSxcbiAgICAgICAgICB0ZXh0ID0gX2Rlc2NlbmRhbnQ0WzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9kZXNjZW5kYW50NFsxXTtcblxuICAgICAgdGV4dC5pbnNlcnRBdChvZmZzZXQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgIGlmICghdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmV3bGluZUluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3bGluZUluZGV4KHNlYXJjaEluZGV4KSB7XG4gICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LnNsaWNlKHNlYXJjaEluZGV4KS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA+IC0xID8gc2VhcmNoSW5kZXggKyBvZmZzZXQgOiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQuc2xpY2UoMCwgc2VhcmNoSW5kZXgpLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIGlmICghdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKCd0ZXh0JywgJ1xcbicpKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoQ29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jay5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQ7XG4gICAgICBpZiAobmV4dCAhPSBudWxsICYmIG5leHQucHJldiA9PT0gdGhpcyAmJiBuZXh0LnN0YXRpY3MuYmxvdE5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpID09PSBuZXh0LnN0YXRpY3MuZm9ybWF0cyhuZXh0LmRvbU5vZGUpKSB7XG4gICAgICAgIG5leHQub3B0aW1pemUoY29udGV4dCk7XG4gICAgICAgIG5leHQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICBuZXh0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhcmdldCkge1xuICAgICAgX2dldChDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrLnByb3RvdHlwZSksICdyZXBsYWNlJywgdGhpcykuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnKicpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUpO1xuICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSB7XG4gICAgICAgICAgYmxvdC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG90LnVud3JhcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGRvbU5vZGUgPSBfZ2V0KENvZGVCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jayksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRvbU5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29kZUJsb2NrO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5Db2RlQmxvY2suYmxvdE5hbWUgPSAnY29kZS1ibG9jayc7XG5Db2RlQmxvY2sudGFnTmFtZSA9ICdQUkUnO1xuQ29kZUJsb2NrLlRBQiA9ICcgICc7XG5cbmV4cG9ydHMuQ29kZSA9IENvZGU7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2RlQmxvY2s7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX29wID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3ApO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfY3Vyc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBfY3Vyc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2N1cnNvcik7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9icmVhayA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX2JyZWFrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JyZWFrKTtcblxudmFyIF9jbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF9kZWVwRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQVNDSUkgPSAvXlsgLX5dKiQvO1xuXG52YXIgRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFZGl0b3Ioc2Nyb2xsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvcik7XG5cbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB0aGlzLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVkaXRvciwgW3tcbiAgICBrZXk6ICdhcHBseURlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlEZWx0YShkZWx0YSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnN1bWVOZXh0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICB2YXIgc2Nyb2xsTGVuZ3RoID0gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgICB0aGlzLnNjcm9sbC5iYXRjaFN0YXJ0KCk7XG4gICAgICBkZWx0YSA9IG5vcm1hbGl6ZURlbHRhKGRlbHRhKTtcbiAgICAgIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIG9wKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBvcC5yZXRhaW4gfHwgb3AuZGVsZXRlIHx8IG9wLmluc2VydC5sZW5ndGggfHwgMTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBvcC5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gb3AuaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xcbicpICYmIGNvbnN1bWVOZXh0TmV3bGluZSkge1xuICAgICAgICAgICAgICBjb25zdW1lTmV4dE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHNjcm9sbExlbmd0aCAmJiAhdGV4dC5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgICAgY29uc3VtZU5leHROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNjcm9sbC5pbnNlcnRBdChpbmRleCwgdGV4dCk7XG5cbiAgICAgICAgICAgIHZhciBfc2Nyb2xsJGxpbmUgPSBfdGhpcy5zY3JvbGwubGluZShpbmRleCksXG4gICAgICAgICAgICAgICAgX3Njcm9sbCRsaW5lMiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZSwgMiksXG4gICAgICAgICAgICAgICAgbGluZSA9IF9zY3JvbGwkbGluZTJbMF0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsaW5lMlsxXTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoe30sICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykobGluZSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgaW5zdGFuY2VvZiBfYmxvY2syLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgdmFyIF9saW5lJGRlc2NlbmRhbnQgPSBsaW5lLmRlc2NlbmRhbnQoX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmLCBvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgX2xpbmUkZGVzY2VuZGFudDIgPSBfc2xpY2VkVG9BcnJheShfbGluZSRkZXNjZW5kYW50LCAxKSxcbiAgICAgICAgICAgICAgICAgIGxlYWYgPSBfbGluZSRkZXNjZW5kYW50MlswXTtcblxuICAgICAgICAgICAgICBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGZvcm1hdHMsICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykobGVhZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlcyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYoZm9ybWF0cywgYXR0cmlidXRlcykgfHwge307XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wLmluc2VydCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0LmtleXMob3AuaW5zZXJ0KVswXTsgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGtleVxuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIGtleSwgb3AuaW5zZXJ0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxMZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBfdGhpcy5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5kZXggKyBsZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICAgIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIG9wKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3AuZGVsZXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIF90aGlzLnNjcm9sbC5kZWxldGVBdChpbmRleCwgb3AuZGVsZXRlKTtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgKG9wLnJldGFpbiB8fCBvcC5pbnNlcnQubGVuZ3RoIHx8IDEpO1xuICAgICAgfSwgMCk7XG4gICAgICB0aGlzLnNjcm9sbC5iYXRjaEVuZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRlbHRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB0aGlzLnNjcm9sbC5kZWxldGVBdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmRlbGV0ZShsZW5ndGgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRMaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB0aGlzLnNjcm9sbC51cGRhdGUoKTtcbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBpZiAoX3RoaXMyLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhX3RoaXMyLnNjcm9sbC53aGl0ZWxpc3RbZm9ybWF0XSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGluZXMgPSBfdGhpczIuc2Nyb2xsLmxpbmVzKGluZGV4LCBNYXRoLm1heChsZW5ndGgsIDEpKTtcbiAgICAgICAgdmFyIGxlbmd0aFJlbWFpbmluZyA9IGxlbmd0aDtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGgoKTtcbiAgICAgICAgICBpZiAoIShsaW5lIGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICBsaW5lLmZvcm1hdChmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2RlSW5kZXggPSBpbmRleCAtIGxpbmUub2Zmc2V0KF90aGlzMi5zY3JvbGwpO1xuICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGggPSBsaW5lLm5ld2xpbmVJbmRleChjb2RlSW5kZXggKyBsZW5ndGhSZW1haW5pbmcpIC0gY29kZUluZGV4ICsgMTtcbiAgICAgICAgICAgIGxpbmUuZm9ybWF0QXQoY29kZUluZGV4LCBjb2RlTGVuZ3RoLCBmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aFJlbWFpbmluZyAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zY3JvbGwub3B0aW1pemUoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLnJldGFpbihsZW5ndGgsICgwLCBfY2xvbmUyLmRlZmF1bHQpKGZvcm1hdHMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIF90aGlzMy5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5yZXRhaW4obGVuZ3RoLCAoMCwgX2Nsb25lMi5kZWZhdWx0KShmb3JtYXRzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldENvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmVzKCkucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgbGluZSkge1xuICAgICAgICByZXR1cm4gZGVsdGEuY29uY2F0KGxpbmUuZGVsdGEoKSk7XG4gICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KGluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgbGluZXMgPSBbXSxcbiAgICAgICAgICBsZWF2ZXMgPSBbXTtcbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zY3JvbGwucGF0aChpbmRleCkuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIHZhciBfcGF0aCA9IF9zbGljZWRUb0FycmF5KHBhdGgsIDEpLFxuICAgICAgICAgICAgICBibG90ID0gX3BhdGhbMF07XG5cbiAgICAgICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIF9ibG9jazIuZGVmYXVsdCkge1xuICAgICAgICAgICAgbGluZXMucHVzaChibG90KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYpIHtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKGJsb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcyA9IHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBsZWF2ZXMgPSB0aGlzLnNjcm9sbC5kZXNjZW5kYW50cyhfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIGZvcm1hdHNBcnIgPSBbbGluZXMsIGxlYXZlc10ubWFwKGZ1bmN0aW9uIChibG90cykge1xuICAgICAgICBpZiAoYmxvdHMubGVuZ3RoID09PSAwKSByZXR1cm4ge307XG4gICAgICAgIHZhciBmb3JtYXRzID0gKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKShibG90cy5zaGlmdCgpKTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgYmxvdCA9IGJsb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkgcmV0dXJuIGZvcm1hdHM7XG4gICAgICAgICAgZm9ybWF0cyA9IGNvbWJpbmVGb3JtYXRzKCgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykoYmxvdCksIGZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZDIuZGVmYXVsdC5hcHBseShfZXh0ZW5kMi5kZWZhdWx0LCBmb3JtYXRzQXJyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoKS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJztcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wLmluc2VydDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEVtYmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSkge1xuICAgICAgdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIGVtYmVkLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5pbnNlcnQoX2RlZmluZVByb3BlcnR5KHt9LCBlbWJlZCwgdmFsdWUpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRleHQoaW5kZXgsIHRleHQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICAgIHRoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCB0ZXh0KTtcbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBfdGhpczQuc2Nyb2xsLmZvcm1hdEF0KGluZGV4LCB0ZXh0Lmxlbmd0aCwgZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5pbnNlcnQodGV4dCwgKDAsIF9jbG9uZTIuZGVmYXVsdCkoZm9ybWF0cykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0JsYW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCbGFuaygpIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbC5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcy5zY3JvbGwuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGJsb2NrID0gdGhpcy5zY3JvbGwuY2hpbGRyZW4uaGVhZDtcbiAgICAgIGlmIChibG9jay5zdGF0aWNzLmJsb3ROYW1lICE9PSBfYmxvY2syLmRlZmF1bHQuYmxvdE5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gYmxvY2suY2hpbGRyZW4uaGVhZCBpbnN0YW5jZW9mIF9icmVhazIuZGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfc2Nyb2xsJGxpbmUzID0gdGhpcy5zY3JvbGwubGluZShpbmRleCArIGxlbmd0aCksXG4gICAgICAgICAgX3Njcm9sbCRsaW5lNCA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZTMsIDIpLFxuICAgICAgICAgIGxpbmUgPSBfc2Nyb2xsJGxpbmU0WzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGluZTRbMV07XG5cbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSAwLFxuICAgICAgICAgIHN1ZmZpeCA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xuICAgICAgaWYgKGxpbmUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIShsaW5lIGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpKSB7XG4gICAgICAgICAgc3VmZml4TGVuZ3RoID0gbGluZS5sZW5ndGgoKSAtIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXhMZW5ndGggPSBsaW5lLm5ld2xpbmVJbmRleChvZmZzZXQpIC0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggPSBsaW5lLmRlbHRhKCkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdWZmaXhMZW5ndGggLSAxKS5pbnNlcnQoJ1xcbicpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoICsgc3VmZml4TGVuZ3RoKTtcbiAgICAgIHZhciBkaWZmID0gY29udGVudHMuZGlmZihuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQodGV4dCkuY29uY2F0KHN1ZmZpeCkpO1xuICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5jb25jYXQoZGlmZik7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseURlbHRhKGRlbHRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoY2hhbmdlKSB7XG4gICAgICB2YXIgbXV0YXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBjdXJzb3JJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgb2xkRGVsdGEgPSB0aGlzLmRlbHRhO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEgJiYgbXV0YXRpb25zWzBdLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbnNbMF0udGFyZ2V0LmRhdGEubWF0Y2goQVNDSUkpICYmIF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChtdXRhdGlvbnNbMF0udGFyZ2V0KSkge1xuICAgICAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGNoYXJhY3RlciBjaGFuZ2VzXG4gICAgICAgIHZhciB0ZXh0QmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChtdXRhdGlvbnNbMF0udGFyZ2V0KTtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKHRleHRCbG90KTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGV4dEJsb3Qub2Zmc2V0KHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gbXV0YXRpb25zWzBdLm9sZFZhbHVlLnJlcGxhY2UoX2N1cnNvcjIuZGVmYXVsdC5DT05URU5UUywgJycpO1xuICAgICAgICB2YXIgb2xkVGV4dCA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydChvbGRWYWx1ZSk7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHRCbG90LnZhbHVlKCkpO1xuICAgICAgICB2YXIgZGlmZkRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5jb25jYXQob2xkVGV4dC5kaWZmKG5ld1RleHQsIGN1cnNvckluZGV4KSk7XG4gICAgICAgIGNoYW5nZSA9IGRpZmZEZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBvcCkge1xuICAgICAgICAgIGlmIChvcC5pbnNlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQob3AuaW5zZXJ0LCBmb3JtYXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhLnB1c2gob3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICAgICAgICB0aGlzLmRlbHRhID0gb2xkRGVsdGEuY29tcG9zZShjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2UgfHwgISgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShvbGREZWx0YS5jb21wb3NlKGNoYW5nZSksIHRoaXMuZGVsdGEpKSB7XG4gICAgICAgICAgY2hhbmdlID0gb2xkRGVsdGEuZGlmZih0aGlzLmRlbHRhLCBjdXJzb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkaXRvcjtcbn0oKTtcblxuZnVuY3Rpb24gY29tYmluZUZvcm1hdHMoZm9ybWF0cywgY29tYmluZWQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbWJpbmVkKS5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgbmFtZSkge1xuICAgIGlmIChmb3JtYXRzW25hbWVdID09IG51bGwpIHJldHVybiBtZXJnZWQ7XG4gICAgaWYgKGNvbWJpbmVkW25hbWVdID09PSBmb3JtYXRzW25hbWVdKSB7XG4gICAgICBtZXJnZWRbbmFtZV0gPSBjb21iaW5lZFtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29tYmluZWRbbmFtZV0pKSB7XG4gICAgICBpZiAoY29tYmluZWRbbmFtZV0uaW5kZXhPZihmb3JtYXRzW25hbWVdKSA8IDApIHtcbiAgICAgICAgbWVyZ2VkW25hbWVdID0gY29tYmluZWRbbmFtZV0uY29uY2F0KFtmb3JtYXRzW25hbWVdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlZFtuYW1lXSA9IFtjb21iaW5lZFtuYW1lXSwgZm9ybWF0c1tuYW1lXV07XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRGVsdGEoZGVsdGEpIHtcbiAgcmV0dXJuIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG9wKSB7XG4gICAgaWYgKG9wLmluc2VydCA9PT0gMSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoMCwgX2Nsb25lMi5kZWZhdWx0KShvcC5hdHRyaWJ1dGVzKTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzWydpbWFnZSddO1xuICAgICAgcmV0dXJuIGRlbHRhLmluc2VydCh7IGltYWdlOiBvcC5hdHRyaWJ1dGVzLmltYWdlIH0sIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAob3AuYXR0cmlidXRlcyAhPSBudWxsICYmIChvcC5hdHRyaWJ1dGVzLmxpc3QgPT09IHRydWUgfHwgb3AuYXR0cmlidXRlcy5idWxsZXQgPT09IHRydWUpKSB7XG4gICAgICBvcCA9ICgwLCBfY2xvbmUyLmRlZmF1bHQpKG9wKTtcbiAgICAgIGlmIChvcC5hdHRyaWJ1dGVzLmxpc3QpIHtcbiAgICAgICAgb3AuYXR0cmlidXRlcy5saXN0ID0gJ29yZGVyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3AuYXR0cmlidXRlcy5saXN0ID0gJ2J1bGxldCc7XG4gICAgICAgIGRlbGV0ZSBvcC5hdHRyaWJ1dGVzLmJ1bGxldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdGV4dCA9IG9wLmluc2VydC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQsIG9wLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsdGEucHVzaChvcCk7XG4gIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuUmFuZ2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2Nsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG52YXIgX2RlZXBFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2VtaXR0ZXIzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIzKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6c2VsZWN0aW9uJyk7XG5cbnZhciBSYW5nZSA9IGZ1bmN0aW9uIFJhbmdlKGluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xufTtcblxudmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uKHNjcm9sbCwgZW1pdHRlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uKTtcblxuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5zY3JvbGwgPSBzY3JvbGw7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuc2Nyb2xsLmRvbU5vZGU7XG4gICAgdGhpcy5jdXJzb3IgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSgnY3Vyc29yJywgdGhpcyk7XG4gICAgLy8gc2F2ZWRSYW5nZSBpcyBsYXN0IG5vbi1udWxsIHJhbmdlXG4gICAgdGhpcy5sYXN0UmFuZ2UgPSB0aGlzLnNhdmVkUmFuZ2UgPSBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgdGhpcy5oYW5kbGVDb21wb3NpdGlvbigpO1xuICAgIHRoaXMuaGFuZGxlRHJhZ2dpbmcoKTtcbiAgICB0aGlzLmVtaXR0ZXIubGlzdGVuRE9NKCdzZWxlY3Rpb25jaGFuZ2UnLCBkb2N1bWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5tb3VzZURvd24pIHtcbiAgICAgICAgc2V0VGltZW91dChfdGhpcy51cGRhdGUuYmluZChfdGhpcywgX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCBmdW5jdGlvbiAodHlwZSwgZGVsdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UgJiYgZGVsdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfQkVGT1JFX1VQREFURSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5oYXNGb2N1cygpKSByZXR1cm47XG4gICAgICB2YXIgbmF0aXZlID0gX3RoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIGlmIChuYXRpdmUgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKG5hdGl2ZS5zdGFydC5ub2RlID09PSBfdGhpcy5jdXJzb3IudGV4dE5vZGUpIHJldHVybjsgLy8gY3Vyc29yLnJlc3RvcmUoKSB3aWxsIGhhbmRsZVxuICAgICAgLy8gVE9ETyB1bmNsZWFyIGlmIHRoaXMgaGFzIG5lZ2F0aXZlIHNpZGUgZWZmZWN0c1xuICAgICAgX3RoaXMuZW1pdHRlci5vbmNlKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuc2V0TmF0aXZlUmFuZ2UobmF0aXZlLnN0YXJ0Lm5vZGUsIG5hdGl2ZS5zdGFydC5vZmZzZXQsIG5hdGl2ZS5lbmQubm9kZSwgbmF0aXZlLmVuZC5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7fVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0LnJhbmdlKSB7XG4gICAgICAgIHZhciBfY29udGV4dCRyYW5nZSA9IGNvbnRleHQucmFuZ2UsXG4gICAgICAgICAgICBzdGFydE5vZGUgPSBfY29udGV4dCRyYW5nZS5zdGFydE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IF9jb250ZXh0JHJhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kTm9kZSA9IF9jb250ZXh0JHJhbmdlLmVuZE5vZGUsXG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBfY29udGV4dCRyYW5nZS5lbmRPZmZzZXQ7XG5cbiAgICAgICAgX3RoaXMuc2V0TmF0aXZlUmFuZ2Uoc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZShfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uLCBbe1xuICAgIGtleTogJ2hhbmRsZUNvbXBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jb21wb3NpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzMi5jdXJzb3IucGFyZW50KSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLmN1cnNvci5yZXN0b3JlKCk7XG4gICAgICAgICAgaWYgKCFyYW5nZSkgcmV0dXJuO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnNldE5hdGl2ZVJhbmdlKHJhbmdlLnN0YXJ0Tm9kZSwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHJhbmdlLmVuZE5vZGUsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZURyYWdnaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ2dpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnbW91c2Vkb3duJywgZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnbW91c2V1cCcsIGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBfdGhpczMudXBkYXRlKF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9jdXMoKSkgcmV0dXJuO1xuICAgICAgdGhpcy5yb290LmZvY3VzKCk7XG4gICAgICB0aGlzLnNldFJhbmdlKHRoaXMuc2F2ZWRSYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KF9mb3JtYXQsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgIXRoaXMuc2Nyb2xsLndoaXRlbGlzdFtfZm9ybWF0XSkgcmV0dXJuO1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICB2YXIgbmF0aXZlUmFuZ2UgPSB0aGlzLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICBpZiAobmF0aXZlUmFuZ2UgPT0gbnVsbCB8fCAhbmF0aXZlUmFuZ2UubmF0aXZlLmNvbGxhcHNlZCB8fCBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KF9mb3JtYXQsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spKSByZXR1cm47XG4gICAgICBpZiAobmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSAhPT0gdGhpcy5jdXJzb3IudGV4dE5vZGUpIHtcbiAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIC8vIFRPRE8gR2l2ZSBibG90IGFiaWxpdHkgdG8gbm90IHNwbGl0XG4gICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gYmxvdC5zcGxpdChuYXRpdmVSYW5nZS5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgIGJsb3QucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmN1cnNvciwgYWZ0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb3QuaW5zZXJ0QmVmb3JlKHRoaXMuY3Vyc29yLCBuYXRpdmVSYW5nZS5zdGFydC5ub2RlKTsgLy8gU2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yLmF0dGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3IuZm9ybWF0KF9mb3JtYXQsIHZhbHVlKTtcbiAgICAgIHRoaXMuc2Nyb2xsLm9wdGltaXplKCk7XG4gICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlKHRoaXMuY3Vyc29yLnRleHROb2RlLCB0aGlzLmN1cnNvci50ZXh0Tm9kZS5kYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEJvdW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kcyhpbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc2Nyb2xsTGVuZ3RoIC0gMSk7XG4gICAgICBsZW5ndGggPSBNYXRoLm1pbihpbmRleCArIGxlbmd0aCwgc2Nyb2xsTGVuZ3RoIC0gMSkgLSBpbmRleDtcbiAgICAgIHZhciBub2RlID0gdm9pZCAwLFxuICAgICAgICAgIF9zY3JvbGwkbGVhZiA9IHRoaXMuc2Nyb2xsLmxlYWYoaW5kZXgpLFxuICAgICAgICAgIF9zY3JvbGwkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxlYWYsIDIpLFxuICAgICAgICAgIGxlYWYgPSBfc2Nyb2xsJGxlYWYyWzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGVhZjJbMV07XG4gICAgICBpZiAobGVhZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIHRydWUpO1xuXG4gICAgICB2YXIgX2xlYWYkcG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb24sIDIpO1xuXG4gICAgICBub2RlID0gX2xlYWYkcG9zaXRpb24yWzBdO1xuICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb24yWzFdO1xuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX3Njcm9sbCRsZWFmMyA9IHRoaXMuc2Nyb2xsLmxlYWYoaW5kZXggKyBsZW5ndGgpO1xuXG4gICAgICAgIHZhciBfc2Nyb2xsJGxlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsZWFmMywgMik7XG5cbiAgICAgICAgbGVhZiA9IF9zY3JvbGwkbGVhZjRbMF07XG4gICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGVhZjRbMV07XG5cbiAgICAgICAgaWYgKGxlYWYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uMyA9IGxlYWYucG9zaXRpb24ob2Zmc2V0LCB0cnVlKTtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb240ID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb24zLCAyKTtcblxuICAgICAgICBub2RlID0gX2xlYWYkcG9zaXRpb240WzBdO1xuICAgICAgICBvZmZzZXQgPSBfbGVhZiRwb3NpdGlvbjRbMV07XG5cbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzaWRlID0gJ2xlZnQnO1xuICAgICAgICB2YXIgcmVjdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCAtIDEpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICBzaWRlID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3QgPSBsZWFmLmRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKG9mZnNldCA+IDApIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm90dG9tOiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgICAgbGVmdDogcmVjdFtzaWRlXSxcbiAgICAgICAgICByaWdodDogcmVjdFtzaWRlXSxcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TmF0aXZlUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSYW5nZSgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBuYXRpdmVSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgaWYgKG5hdGl2ZVJhbmdlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3JtYWxpemVOYXRpdmUobmF0aXZlUmFuZ2UpO1xuICAgICAgZGVidWcuaW5mbygnZ2V0TmF0aXZlUmFuZ2UnLCByYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gdGhpcy5nZXROYXRpdmVSYW5nZSgpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQgPT0gbnVsbCkgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubm9ybWFsaXplZFRvUmFuZ2Uobm9ybWFsaXplZCk7XG4gICAgICByZXR1cm4gW3JhbmdlLCBub3JtYWxpemVkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNGb2N1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemVkVG9SYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZWRUb1JhbmdlKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IFtbcmFuZ2Uuc3RhcnQubm9kZSwgcmFuZ2Uuc3RhcnQub2Zmc2V0XV07XG4gICAgICBpZiAoIXJhbmdlLm5hdGl2ZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goW3JhbmdlLmVuZC5ub2RlLCByYW5nZS5lbmQub2Zmc2V0XSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXhlcyA9IHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcG9zaXRpb24gPSBfc2xpY2VkVG9BcnJheShwb3NpdGlvbiwgMiksXG4gICAgICAgICAgICBub2RlID0gX3Bvc2l0aW9uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3Bvc2l0aW9uWzFdO1xuXG4gICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUsIHRydWUpO1xuICAgICAgICB2YXIgaW5kZXggPSBibG90Lm9mZnNldChfdGhpczQuc2Nyb2xsKTtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyBibG90Lmxlbmd0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbmRleCArIGJsb3QuaW5kZXgobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGluZGV4ZXMpKSwgdGhpcy5zY3JvbGwubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFtlbmRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5kZXhlcykpKTtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemVOYXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVOYXRpdmUobmF0aXZlUmFuZ2UpIHtcbiAgICAgIGlmICghY29udGFpbnModGhpcy5yb290LCBuYXRpdmVSYW5nZS5zdGFydENvbnRhaW5lcikgfHwgIW5hdGl2ZVJhbmdlLmNvbGxhcHNlZCAmJiAhY29udGFpbnModGhpcy5yb290LCBuYXRpdmVSYW5nZS5lbmRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICBzdGFydDogeyBub2RlOiBuYXRpdmVSYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiBuYXRpdmVSYW5nZS5zdGFydE9mZnNldCB9LFxuICAgICAgICBlbmQ6IHsgbm9kZTogbmF0aXZlUmFuZ2UuZW5kQ29udGFpbmVyLCBvZmZzZXQ6IG5hdGl2ZVJhbmdlLmVuZE9mZnNldCB9LFxuICAgICAgICBuYXRpdmU6IG5hdGl2ZVJhbmdlXG4gICAgICB9O1xuICAgICAgW3JhbmdlLnN0YXJ0LCByYW5nZS5lbmRdLmZvckVhY2goZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBub2RlID0gcG9zaXRpb24ubm9kZSxcbiAgICAgICAgICAgIG9mZnNldCA9IHBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCEobm9kZSBpbnN0YW5jZW9mIFRleHQpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGUgaW5zdGFuY2VvZiBUZXh0ID8gbm9kZS5kYXRhLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24ubm9kZSA9IG5vZGUsIHBvc2l0aW9uLm9mZnNldCA9IG9mZnNldDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JhbmdlVG9OYXRpdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZVRvTmF0aXZlKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ZXMgPSByYW5nZS5jb2xsYXBzZWQgPyBbcmFuZ2UuaW5kZXhdIDogW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF07XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCwgaSkge1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKHNjcm9sbExlbmd0aCAtIDEsIGluZGV4KTtcbiAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgICBfc2Nyb2xsJGxlYWY1ID0gX3RoaXM1LnNjcm9sbC5sZWFmKGluZGV4KSxcbiAgICAgICAgICAgIF9zY3JvbGwkbGVhZjYgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxlYWY1LCAyKSxcbiAgICAgICAgICAgIGxlYWYgPSBfc2Nyb2xsJGxlYWY2WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsZWFmNlsxXTtcbiAgICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uNSA9IGxlYWYucG9zaXRpb24ob2Zmc2V0LCBpICE9PSAwKTtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb242ID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb241LCAyKTtcblxuICAgICAgICBub2RlID0gX2xlYWYkcG9zaXRpb242WzBdO1xuICAgICAgICBvZmZzZXQgPSBfbGVhZiRwb3NpdGlvbjZbMV07XG5cbiAgICAgICAgYXJncy5wdXNoKG5vZGUsIG9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2Nyb2xsSW50b1ZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhzY3JvbGxpbmdDb250YWluZXIpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMubGFzdFJhbmdlO1xuICAgICAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgIGlmIChib3VuZHMgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGxpbWl0ID0gdGhpcy5zY3JvbGwubGVuZ3RoKCkgLSAxO1xuXG4gICAgICB2YXIgX3Njcm9sbCRsaW5lID0gdGhpcy5zY3JvbGwubGluZShNYXRoLm1pbihyYW5nZS5pbmRleCwgbGltaXQpKSxcbiAgICAgICAgICBfc2Nyb2xsJGxpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbCRsaW5lLCAxKSxcbiAgICAgICAgICBmaXJzdCA9IF9zY3JvbGwkbGluZTJbMF07XG5cbiAgICAgIHZhciBsYXN0ID0gZmlyc3Q7XG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3Njcm9sbCRsaW5lMyA9IHRoaXMuc2Nyb2xsLmxpbmUoTWF0aC5taW4ocmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGgsIGxpbWl0KSk7XG5cbiAgICAgICAgdmFyIF9zY3JvbGwkbGluZTQgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxpbmUzLCAxKTtcblxuICAgICAgICBsYXN0ID0gX3Njcm9sbCRsaW5lNFswXTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCA9PSBudWxsIHx8IGxhc3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHNjcm9sbEJvdW5kcyA9IHNjcm9sbGluZ0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChib3VuZHMudG9wIDwgc2Nyb2xsQm91bmRzLnRvcCkge1xuICAgICAgICBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wIC09IHNjcm9sbEJvdW5kcy50b3AgLSBib3VuZHMudG9wO1xuICAgICAgfSBlbHNlIGlmIChib3VuZHMuYm90dG9tID4gc2Nyb2xsQm91bmRzLmJvdHRvbSkge1xuICAgICAgICBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wICs9IGJvdW5kcy5ib3R0b20gLSBzY3JvbGxCb3VuZHMuYm90dG9tO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE5hdGl2ZVJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmF0aXZlUmFuZ2Uoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgICAgdmFyIGVuZE5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0YXJ0Tm9kZTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHN0YXJ0T2Zmc2V0O1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgZGVidWcuaW5mbygnc2V0TmF0aXZlUmFuZ2UnLCBzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgaWYgKHN0YXJ0Tm9kZSAhPSBudWxsICYmICh0aGlzLnJvb3QucGFyZW50Tm9kZSA9PSBudWxsIHx8IHN0YXJ0Tm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgZW5kTm9kZS5wYXJlbnROb2RlID09IG51bGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB0aGlzLnJvb3QuZm9jdXMoKTtcbiAgICAgICAgdmFyIG5hdGl2ZSA9ICh0aGlzLmdldE5hdGl2ZVJhbmdlKCkgfHwge30pLm5hdGl2ZTtcbiAgICAgICAgaWYgKG5hdGl2ZSA9PSBudWxsIHx8IGZvcmNlIHx8IHN0YXJ0Tm9kZSAhPT0gbmF0aXZlLnN0YXJ0Q29udGFpbmVyIHx8IHN0YXJ0T2Zmc2V0ICE9PSBuYXRpdmUuc3RhcnRPZmZzZXQgfHwgZW5kTm9kZSAhPT0gbmF0aXZlLmVuZENvbnRhaW5lciB8fCBlbmRPZmZzZXQgIT09IG5hdGl2ZS5lbmRPZmZzZXQpIHtcblxuICAgICAgICAgIGlmIChzdGFydE5vZGUudGFnTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gW10uaW5kZXhPZi5jYWxsKHN0YXJ0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZE5vZGUudGFnTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IFtdLmluZGV4T2YuY2FsbChlbmROb2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcywgZW5kTm9kZSk7XG4gICAgICAgICAgICBlbmROb2RlID0gZW5kTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMucm9vdC5ibHVyKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTsgLy8gcm9vdC5ibHVyKCkgbm90IGVub3VnaCBvbiBJRTExK1RyYXZpcytTYXVjZUxhYnMgKGJ1dCBub3QgbG9jYWwgVk1zKVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFJhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgaWYgKHR5cGVvZiBmb3JjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gZm9yY2U7XG4gICAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWJ1Zy5pbmZvKCdzZXRSYW5nZScsIHJhbmdlKTtcbiAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5yYW5nZVRvTmF0aXZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZS5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykuY29uY2F0KFtmb3JjZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0TmF0aXZlUmFuZ2UobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZShzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUjtcblxuICAgICAgdmFyIG9sZFJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG5cbiAgICAgIHZhciBfZ2V0UmFuZ2UgPSB0aGlzLmdldFJhbmdlKCksXG4gICAgICAgICAgX2dldFJhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9nZXRSYW5nZSwgMiksXG4gICAgICAgICAgbGFzdFJhbmdlID0gX2dldFJhbmdlMlswXSxcbiAgICAgICAgICBuYXRpdmVSYW5nZSA9IF9nZXRSYW5nZTJbMV07XG5cbiAgICAgIHRoaXMubGFzdFJhbmdlID0gbGFzdFJhbmdlO1xuICAgICAgaWYgKHRoaXMubGFzdFJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zYXZlZFJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoISgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShvbGRSYW5nZSwgdGhpcy5sYXN0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBfZW1pdHRlcjtcblxuICAgICAgICBpZiAoIXRoaXMuY29tcG9zaW5nICYmIG5hdGl2ZVJhbmdlICE9IG51bGwgJiYgbmF0aXZlUmFuZ2UubmF0aXZlLmNvbGxhcHNlZCAmJiBuYXRpdmVSYW5nZS5zdGFydC5ub2RlICE9PSB0aGlzLmN1cnNvci50ZXh0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSwgKDAsIF9jbG9uZTIuZGVmYXVsdCkodGhpcy5sYXN0UmFuZ2UpLCAoMCwgX2Nsb25lMi5kZWZhdWx0KShvbGRSYW5nZSksIHNvdXJjZV07XG4gICAgICAgIChfZW1pdHRlciA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlciwgW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFXS5jb25jYXQoYXJncykpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCkge1xuICAgICAgICAgIHZhciBfZW1pdHRlcjI7XG5cbiAgICAgICAgICAoX2VtaXR0ZXIyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF9lbWl0dGVyMiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGRlc2NlbmRhbnQpIHtcbiAgdHJ5IHtcbiAgICAvLyBGaXJlZm94IGluc2VydHMgaW5hY2Nlc3NpYmxlIG5vZGVzIGFyb3VuZCB2aWRlbyBlbGVtZW50c1xuICAgIGRlc2NlbmRhbnQucGFyZW50Tm9kZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRTExIGhhcyBidWcgd2l0aCBUZXh0IG5vZGVzXG4gIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzgwODc0L25vZGUtY29udGFpbnMtaXMtaW5jb3JyZWN0XG4gIGlmIChkZXNjZW5kYW50IGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGRlc2NlbmRhbnQgPSBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhcmVudC5jb250YWlucyhkZXNjZW5kYW50KTtcbn1cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VsZWN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJyZWFrID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEJyZWFrLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBmdW5jdGlvbiBCcmVhaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJlYWspO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCcmVhay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJyZWFrKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnJlYWssIFt7XG4gICAga2V5OiAnaW5zZXJ0SW50bycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEludG8ocGFyZW50LCByZWYpIHtcbiAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIF9nZXQoQnJlYWsucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJlYWsucHJvdG90eXBlKSwgJ2luc2VydEludG8nLCB0aGlzKS5jYWxsKHRoaXMsIHBhcmVudCwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmVhaztcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkJyZWFrLmJsb3ROYW1lID0gJ2JyZWFrJztcbkJyZWFrLnRhZ05hbWUgPSAnQlInO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCcmVhaztcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsaW5rZWRfbGlzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgc2hhZG93XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQ29udGFpbmVyQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFpbmVyQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWluZXJCbG90KGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9tTm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShvdGhlcik7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmF0dGFjaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IGxpbmtlZF9saXN0XzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyBOZWVkIHRvIGJlIHJldmVyc2VkIGZvciBpZiBET00gbm9kZXMgYWxyZWFkeSBpbiBvcmRlclxuICAgICAgICBbXS5zbGljZVxuICAgICAgICAgICAgLmNhbGwodGhpcy5kb21Ob2RlLmNoaWxkTm9kZXMpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBtYWtlQmxvdChub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIF90aGlzLmNoaWxkcmVuLmhlYWQgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUmVnaXN0cnkuUGFyY2htZW50RXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkLmRlbGV0ZUF0KG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZXNjZW5kYW50ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBpbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgpLCBjaGlsZCA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgaWYgKChjcml0ZXJpYS5ibG90TmFtZSA9PSBudWxsICYmIGNyaXRlcmlhKGNoaWxkKSkgfHxcbiAgICAgICAgICAgIChjcml0ZXJpYS5ibG90TmFtZSAhPSBudWxsICYmIGNoaWxkIGluc3RhbmNlb2YgY3JpdGVyaWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NoaWxkLCBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NlbmRhbnQoY3JpdGVyaWEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIC0xXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZGVzY2VuZGFudHMgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSBOdW1iZXIuTUFYX1ZBTFVFOyB9XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgICB2YXIgbGVuZ3RoTGVmdCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpKSB8fFxuICAgICAgICAgICAgICAgIChjcml0ZXJpYS5ibG90TmFtZSAhPSBudWxsICYmIGNoaWxkIGluc3RhbmNlb2YgY3JpdGVyaWEpKSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZGFudHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXJCbG90KSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZGFudHMgPSBkZXNjZW5kYW50cy5jb25jYXQoY2hpbGQuZGVzY2VuZGFudHMoY3JpdGVyaWEsIGluZGV4LCBsZW5ndGhMZWZ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW5ndGhMZWZ0IC09IGxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuZGV0YWNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGQuZm9ybWF0QXQob2Zmc2V0LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgpLCBjaGlsZCA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5pbnNlcnRBdChvZmZzZXQsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJsb3QgPSBkZWYgPT0gbnVsbCA/IFJlZ2lzdHJ5LmNyZWF0ZSgndGV4dCcsIHZhbHVlKSA6IFJlZ2lzdHJ5LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYmxvdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZEJsb3QsIHJlZkJsb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGljcy5hbGxvd2VkQ2hpbGRyZW4gIT0gbnVsbCAmJlxuICAgICAgICAgICAgIXRoaXMuc3RhdGljcy5hbGxvd2VkQ2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRCbG90IGluc3RhbmNlb2YgY2hpbGQ7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5LlBhcmNobWVudEVycm9yKFwiQ2Fubm90IGluc2VydCBcIiArIGNoaWxkQmxvdC5zdGF0aWNzLmJsb3ROYW1lICsgXCIgaW50byBcIiArIHRoaXMuc3RhdGljcy5ibG90TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRCbG90Lmluc2VydEludG8odGhpcywgcmVmQmxvdCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vICsgY2hpbGQubGVuZ3RoKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUubW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldFBhcmVudCwgcmVmTm9kZSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB0YXJnZXRQYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gUmVnaXN0cnkuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkgeyBpbmNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgsIGluY2x1c2l2ZSksIGNoaWxkID0gX2FbMF0sIG9mZnNldCA9IF9hWzFdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbW3RoaXMsIGluZGV4XV07XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lckJsb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbi5jb25jYXQoY2hpbGQucGF0aChvZmZzZXQsIGluY2x1c2l2ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnB1c2goW2NoaWxkLCBvZmZzZXRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnJlbW92ZShjaGlsZCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgdGFyZ2V0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlcGxhY2UuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5kZXgsIGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCFmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYWZ0ZXIsIHRoaXMubmV4dCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCB0aGlzLmxlbmd0aCgpLCBmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNwbGl0KG9mZnNldCwgZm9yY2UpO1xuICAgICAgICAgICAgYWZ0ZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVDaGlsZHJlbih0aGlzLnBhcmVudCwgdGhpcy5uZXh0KTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBhZGRlZE5vZGVzLnB1c2guYXBwbHkoYWRkZWROb2RlcywgbXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2guYXBwbHkocmVtb3ZlZE5vZGVzLCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG5vZGUgaGFzIGFjdHVhbGx5IGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgLy8gT25lIGV4Y2VwdGlvbiBpcyBDaHJvbWUgZG9lcyBub3QgaW1tZWRpYXRlbHkgcmVtb3ZlIElGUkFNRXNcbiAgICAgICAgICAgIC8vIGZyb20gRE9NIGJ1dCBNdXRhdGlvblJlY29yZCBpcyBjb3JyZWN0IGluIGl0cyByZXBvcnRlZCByZW1vdmFsXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lICE9PSAnSUZSQU1FJyAmJlxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChub2RlKTtcbiAgICAgICAgICAgIGlmIChibG90ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT09IF90aGlzLmRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICBibG90LmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkZWROb2Rlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSA9PSBfdGhpcy5kb21Ob2RlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZWZCbG90ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZCbG90ID0gUmVnaXN0cnkuZmluZChub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG90ID0gbWFrZUJsb3Qobm9kZSk7XG4gICAgICAgICAgICBpZiAoYmxvdC5uZXh0ICE9IHJlZkJsb3QgfHwgYmxvdC5uZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBibG90LnBhcmVudC5yZW1vdmVDaGlsZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmluc2VydEJlZm9yZShibG90LCByZWZCbG90IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhaW5lckJsb3Q7XG59KHNoYWRvd18xLmRlZmF1bHQpKTtcbmZ1bmN0aW9uIG1ha2VCbG90KG5vZGUpIHtcbiAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobm9kZSk7XG4gICAgaWYgKGJsb3QgPT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZShSZWdpc3RyeS5TY29wZS5JTkxJTkUpO1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJsb3QuZG9tTm9kZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG90LmF0dGFjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBibG90O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFpbmVyQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIHN0b3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbnZhciBjb250YWluZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGb3JtYXRCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JtYXRCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1hdEJsb3QoZG9tTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb21Ob2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzID0gbmV3IHN0b3JlXzEuZGVmYXVsdChfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGb3JtYXRCbG90LmZvcm1hdHMgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudGFnTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUpO1xuICAgICAgICBpZiAoZm9ybWF0IGluc3RhbmNlb2YgYXR0cmlidXRvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5hdHRyaWJ1dGUoZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiAobmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lIHx8IHRoaXMuZm9ybWF0cygpW25hbWVdICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUuZm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCk7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdHNbdGhpcy5zdGF0aWNzLmJsb3ROYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IF9zdXBlci5wcm90b3R5cGUucmVwbGFjZVdpdGguY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5jb3B5KHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBfc3VwZXIucHJvdG90eXBlLndyYXAuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgRm9ybWF0QmxvdCAmJiB3cmFwcGVyLnN0YXRpY3Muc2NvcGUgPT09IHRoaXMuc3RhdGljcy5zY29wZSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLm1vdmUod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ybWF0QmxvdDtcbn0oY29udGFpbmVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0QmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRvd18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIExlYWZCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWFmQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFmQmxvdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMZWFmQmxvdC52YWx1ZSA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5kb21Ob2RlID09PSBub2RlIHx8XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IFtdLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudC5kb21Ob2RlLmNoaWxkTm9kZXMsIHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnBhcmVudC5kb21Ob2RlLCBvZmZzZXRdO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LCBfYVt0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSkgfHwgdHJ1ZSwgX2E7XG4gICAgfTtcbiAgICBMZWFmQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLklOTElORV9CTE9UO1xuICAgIHJldHVybiBMZWFmQmxvdDtcbn0oc2hhZG93XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGVhZkJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBleHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cbnZhciBsaWIgPSB7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb21wb3NlOiBmdW5jdGlvbiAoYSwgYiwga2VlcE51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIGEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIGIgPSB7fTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gZXh0ZW5kKHRydWUsIHt9LCBiKTtcbiAgICAgIGlmICgha2VlcE51bGwpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoY29weSwga2V5KSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoYVtrZXldICE9PSB1bmRlZmluZWQgJiYgYltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZGlmZjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JykgYSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0JykgYiA9IHt9O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhhKS5jb25jYXQoT2JqZWN0LmtleXMoYikpLnJlZHVjZShmdW5jdGlvbiAoYXR0cmlidXRlcywga2V5KSB7XG4gICAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYltrZXldID09PSB1bmRlZmluZWQgPyBudWxsIDogYltrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChhLCBiLCBwcmlvcml0eSkge1xuICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JykgcmV0dXJuIGI7XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFwcmlvcml0eSkgcmV0dXJuIGI7ICAvLyBiIHNpbXBseSBvdmVyd3JpdGVzIHVzIHdpdGhvdXQgcHJpb3JpdHlcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYikucmVkdWNlKGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBrZXkpIHtcbiAgICAgICAgaWYgKGFba2V5XSA9PT0gdW5kZWZpbmVkKSBhdHRyaWJ1dGVzW2tleV0gPSBiW2tleV07ICAvLyBudWxsIGlzIGEgdmFsaWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIGl0ZXJhdG9yOiBmdW5jdGlvbiAob3BzKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihvcHMpO1xuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKG9wKSB7XG4gICAgaWYgKHR5cGVvZiBvcFsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gb3BbJ2RlbGV0ZSddO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBvcC5yZXRhaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJyA/IG9wLmluc2VydC5sZW5ndGggOiAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBJdGVyYXRvcihvcHMpIHtcbiAgdGhpcy5vcHMgPSBvcHM7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLm9mZnNldCA9IDA7XG59XG5JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVla0xlbmd0aCgpIDwgSW5maW5pdHk7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IEluZmluaXR5O1xuICB2YXIgbmV4dE9wID0gdGhpcy5vcHNbdGhpcy5pbmRleF07XG4gIGlmIChuZXh0T3ApIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdmFyIG9wTGVuZ3RoID0gbGliLmxlbmd0aChuZXh0T3ApO1xuICAgIGlmIChsZW5ndGggPj0gb3BMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIGxlbmd0aCA9IG9wTGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV4dE9wWydkZWxldGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7ICdkZWxldGUnOiBsZW5ndGggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldE9wID0ge307XG4gICAgICBpZiAobmV4dE9wLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0T3AuYXR0cmlidXRlcyA9IG5leHRPcC5hdHRyaWJ1dGVzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBuZXh0T3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXRPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXRPcC5pbnNlcnQgPSBuZXh0T3AuaW5zZXJ0LnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvZmZzZXQgc2hvdWxkID09PSAwLCBsZW5ndGggc2hvdWxkID09PSAxXG4gICAgICAgIHJldE9wLmluc2VydCA9IG5leHRPcC5pbnNlcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0T3A7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHJldGFpbjogSW5maW5pdHkgfTtcbiAgfVxufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHNbdGhpcy5pbmRleF0pIHtcbiAgICAvLyBTaG91bGQgbmV2ZXIgcmV0dXJuIDAgaWYgb3VyIGluZGV4IGlzIGJlaW5nIG1hbmFnZWQgY29ycmVjdGx5XG4gICAgcmV0dXJuIGxpYi5sZW5ndGgodGhpcy5vcHNbdGhpcy5pbmRleF0pIC0gdGhpcy5vZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucGVla1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wc1t0aGlzLmluZGV4XSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHNbdGhpcy5pbmRleF1bJ2RlbGV0ZSddID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdkZWxldGUnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3BzW3RoaXMuaW5kZXhdLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAncmV0YWluJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdpbnNlcnQnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3JldGFpbic7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhhc05leHQoKSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmICh0aGlzLm9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLm9wcy5zbGljZSh0aGlzLmluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB2YXIgbmV4dCA9IHRoaXMubmV4dCgpO1xuICAgIHZhciByZXN0ID0gdGhpcy5vcHMuc2xpY2UodGhpcy5pbmRleCk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHJldHVybiBbbmV4dF0uY29uY2F0KHJlc3QpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbGliO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgICAgIC8vIE5vZGUuanMgPj0gNC41LjBcbiAgICAgICAgY2hpbGQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbGRlciBOb2RlLmpzIHZlcnNpb25zXG4gICAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgRXJyb3IpKSB7XG4gICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcbiAgICAgICAgdmFyIHZhbHVlQ2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLnNldChrZXlDaGlsZCwgdmFsdWVDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLmFkZChlbnRyeUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgLy8gbGlrZSBhIG51bWJlciBvciBzdHJpbmcuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmICFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gYWxsUHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG52YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX2NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWluZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIGlzTGluZShibG90KSB7XG4gIHJldHVybiBibG90IGluc3RhbmNlb2YgX2Jsb2NrMi5kZWZhdWx0IHx8IGJsb3QgaW5zdGFuY2VvZiBfYmxvY2suQmxvY2tFbWJlZDtcbn1cblxudmFyIFNjcm9sbCA9IGZ1bmN0aW9uIChfUGFyY2htZW50JFNjcm9sbCkge1xuICBfaW5oZXJpdHMoU2Nyb2xsLCBfUGFyY2htZW50JFNjcm9sbCk7XG5cbiAgZnVuY3Rpb24gU2Nyb2xsKGRvbU5vZGUsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGwpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNjcm9sbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbCkpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgX3RoaXMuZW1pdHRlciA9IGNvbmZpZy5lbWl0dGVyO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy53aGl0ZWxpc3QpKSB7XG4gICAgICBfdGhpcy53aGl0ZWxpc3QgPSBjb25maWcud2hpdGVsaXN0LnJlZHVjZShmdW5jdGlvbiAod2hpdGVsaXN0LCBmb3JtYXQpIHtcbiAgICAgICAgd2hpdGVsaXN0W2Zvcm1hdF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gd2hpdGVsaXN0O1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvLyBTb21lIHJlYXNvbiBmaXhlcyBjb21wb3NpdGlvbiBpc3N1ZXMgd2l0aCBjaGFyYWN0ZXIgbGFuZ3VhZ2VzIGluIFdpbmRvd3MvQ2hyb21lLCBTYWZhcmlcbiAgICBfdGhpcy5kb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICBfdGhpcy5vcHRpbWl6ZSgpO1xuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY3JvbGwsIFt7XG4gICAga2V5OiAnYmF0Y2hTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XG4gICAgICB0aGlzLmJhdGNoID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdiYXRjaEVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhdGNoRW5kKCkge1xuICAgICAgdGhpcy5iYXRjaCA9IGZhbHNlO1xuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF9saW5lID0gdGhpcy5saW5lKGluZGV4KSxcbiAgICAgICAgICBfbGluZTIgPSBfc2xpY2VkVG9BcnJheShfbGluZSwgMiksXG4gICAgICAgICAgZmlyc3QgPSBfbGluZTJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX2xpbmUyWzFdO1xuXG4gICAgICB2YXIgX2xpbmUzID0gdGhpcy5saW5lKGluZGV4ICsgbGVuZ3RoKSxcbiAgICAgICAgICBfbGluZTQgPSBfc2xpY2VkVG9BcnJheShfbGluZTMsIDEpLFxuICAgICAgICAgIGxhc3QgPSBfbGluZTRbMF07XG5cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnZGVsZXRlQXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgaWYgKGxhc3QgIT0gbnVsbCAmJiBmaXJzdCAhPT0gbGFzdCAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIF9ibG9jay5CbG9ja0VtYmVkIHx8IGxhc3QgaW5zdGFuY2VvZiBfYmxvY2suQmxvY2tFbWJlZCkge1xuICAgICAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgbmV3bGluZUluZGV4ID0gZmlyc3QubmV3bGluZUluZGV4KGZpcnN0Lmxlbmd0aCgpLCB0cnVlKTtcbiAgICAgICAgICBpZiAobmV3bGluZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmlyc3Quc3BsaXQobmV3bGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3QgaW5zdGFuY2VvZiBfY29kZTIuZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBfbmV3bGluZUluZGV4ID0gbGFzdC5uZXdsaW5lSW5kZXgoMCk7XG4gICAgICAgICAgaWYgKF9uZXdsaW5lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgbGFzdC5zcGxpdChfbmV3bGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBsYXN0LmNoaWxkcmVuLmhlYWQgaW5zdGFuY2VvZiBfYnJlYWsyLmRlZmF1bHQgPyBudWxsIDogbGFzdC5jaGlsZHJlbi5oZWFkO1xuICAgICAgICBmaXJzdC5tb3ZlQ2hpbGRyZW4obGFzdCwgcmVmKTtcbiAgICAgICAgZmlyc3QucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdmFyIGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGVuYWJsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMud2hpdGVsaXN0ICE9IG51bGwgJiYgIXRoaXMud2hpdGVsaXN0W2Zvcm1hdF0pIHJldHVybjtcbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnZm9ybWF0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmIChkZWYgIT0gbnVsbCAmJiB0aGlzLndoaXRlbGlzdCAhPSBudWxsICYmICF0aGlzLndoaXRlbGlzdFt2YWx1ZV0pIHJldHVybjtcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIGlmIChkZWYgPT0gbnVsbCB8fCBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KHZhbHVlLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgICAgICAgIGlmIChkZWYgPT0gbnVsbCAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBibG90Lmluc2VydEF0KDAsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbWJlZCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZW1iZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QmVmb3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZikge1xuICAgICAgaWYgKGJsb3Quc3RhdGljcy5zY29wZSA9PT0gX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVfQkxPVCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgICAgICBibG90ID0gd3JhcHBlcjtcbiAgICAgIH1cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnaW5zZXJ0QmVmb3JlJywgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlYWYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKGluZGV4KS5wb3AoKSB8fCBbbnVsbCwgLTFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZShpbmRleCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGVzY2VuZGFudChpc0xpbmUsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgdmFyIGdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmxvdCwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgbGluZXMgPSBbXSxcbiAgICAgICAgICAgIGxlbmd0aExlZnQgPSBsZW5ndGg7XG4gICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgIGlmIChpc0xpbmUoY2hpbGQpKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGxpbmVzID0gbGluZXMuY29uY2F0KGdldExpbmVzKGNoaWxkLCBpbmRleCwgbGVuZ3RoTGVmdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGhMZWZ0IC09IGxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gZ2V0TGluZXModGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIHZhciBtdXRhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5iYXRjaCA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGluZGV4KSB7XG4gICAgICByZXR1cm4gX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdwYXRoJywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCkuc2xpY2UoMSk7IC8vIEV4Y2x1ZGUgc2VsZlxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoID09PSB0cnVlKSByZXR1cm47XG4gICAgICB2YXIgc291cmNlID0gX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSO1xuICAgICAgaWYgKHR5cGVvZiBtdXRhdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IG11dGF0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtdXRhdGlvbnMpKSB7XG4gICAgICAgIG11dGF0aW9ucyA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX0JFRk9SRV9VUERBVEUsIHNvdXJjZSwgbXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAndXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBtdXRhdGlvbnMuY29uY2F0KFtdKSk7IC8vIHBhc3MgY29weVxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBzb3VyY2UsIG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcm9sbDtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5TY3JvbGwpO1xuXG5TY3JvbGwuYmxvdE5hbWUgPSAnc2Nyb2xsJztcblNjcm9sbC5jbGFzc05hbWUgPSAncWwtZWRpdG9yJztcblNjcm9sbC50YWdOYW1lID0gJ0RJVic7XG5TY3JvbGwuZGVmYXVsdENoaWxkID0gJ2Jsb2NrJztcblNjcm9sbC5hbGxvd2VkQ2hpbGRyZW4gPSBbX2Jsb2NrMi5kZWZhdWx0LCBfYmxvY2suQmxvY2tFbWJlZCwgX2NvbnRhaW5lcjIuZGVmYXVsdF07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbDtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNIT1JUS0VZID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX2Nsb25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lKTtcblxudmFyIF9kZWVwRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIF9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDprZXlib2FyZCcpO1xuXG52YXIgU0hPUlRLRVkgPSAvTWFjL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gJ21ldGFLZXknIDogJ2N0cmxLZXknO1xuXG52YXIgS2V5Ym9hcmQgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoS2V5Ym9hcmQsIF9Nb2R1bGUpO1xuXG4gIF9jcmVhdGVDbGFzcyhLZXlib2FyZCwgbnVsbCwgW3tcbiAgICBrZXk6ICdtYXRjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKGV2dCwgYmluZGluZykge1xuICAgICAgYmluZGluZyA9IG5vcm1hbGl6ZShiaW5kaW5nKTtcbiAgICAgIGlmIChbJ2FsdEtleScsICdjdHJsS2V5JywgJ21ldGFLZXknLCAnc2hpZnRLZXknXS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhYmluZGluZ1trZXldICE9PSBldnRba2V5XSAmJiBiaW5kaW5nW2tleV0gIT09IG51bGw7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZGluZy5rZXkgPT09IChldnQud2hpY2ggfHwgZXZ0LmtleUNvZGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEtleWJvYXJkKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWJvYXJkKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChLZXlib2FyZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEtleWJvYXJkKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYmluZGluZ3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfdGhpcy5vcHRpb25zLmJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSA9PT0gJ2xpc3QgYXV0b2ZpbGwnICYmIHF1aWxsLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhcXVpbGwuc2Nyb2xsLndoaXRlbGlzdFsnbGlzdCddKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmJpbmRpbmdzW25hbWVdKSB7XG4gICAgICAgIF90aGlzLmFkZEJpbmRpbmcoX3RoaXMub3B0aW9ucy5iaW5kaW5nc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUiwgc2hpZnRLZXk6IG51bGwgfSwgaGFuZGxlRW50ZXIpO1xuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsIG1ldGFLZXk6IG51bGwsIGN0cmxLZXk6IG51bGwsIGFsdEtleTogbnVsbCB9LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgaWYgKC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgLy8gTmVlZCB0byBoYW5kbGUgZGVsZXRlIGFuZCBiYWNrc3BhY2UgZm9yIEZpcmVmb3ggaW4gdGhlIGdlbmVyYWwgY2FzZSAjMTE3MVxuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UgfSwgeyBjb2xsYXBzZWQ6IHRydWUgfSwgaGFuZGxlQmFja3NwYWNlKTtcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuREVMRVRFIH0sIHsgY29sbGFwc2VkOiB0cnVlIH0sIGhhbmRsZURlbGV0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFIH0sIHsgY29sbGFwc2VkOiB0cnVlLCBwcmVmaXg6IC9eLj8kLyB9LCBoYW5kbGVCYWNrc3BhY2UpO1xuICAgICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5ERUxFVEUgfSwgeyBjb2xsYXBzZWQ6IHRydWUsIHN1ZmZpeDogL14uPyQvIH0sIGhhbmRsZURlbGV0ZSk7XG4gICAgfVxuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFIH0sIHsgY29sbGFwc2VkOiBmYWxzZSB9LCBoYW5kbGVEZWxldGVSYW5nZSk7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5ERUxFVEUgfSwgeyBjb2xsYXBzZWQ6IGZhbHNlIH0sIGhhbmRsZURlbGV0ZVJhbmdlKTtcbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSwgYWx0S2V5OiBudWxsLCBjdHJsS2V5OiBudWxsLCBtZXRhS2V5OiBudWxsLCBzaGlmdEtleTogbnVsbCB9LCB7IGNvbGxhcHNlZDogdHJ1ZSwgb2Zmc2V0OiAwIH0sIGhhbmRsZUJhY2tzcGFjZSk7XG4gICAgX3RoaXMubGlzdGVuKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEtleWJvYXJkLCBbe1xuICAgIGtleTogJ2FkZEJpbmRpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCaW5kaW5nKGtleSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB2YXIgYmluZGluZyA9IG5vcm1hbGl6ZShrZXkpO1xuICAgICAgaWYgKGJpbmRpbmcgPT0gbnVsbCB8fCBiaW5kaW5nLmtleSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Zy53YXJuKCdBdHRlbXB0ZWQgdG8gYWRkIGludmFsaWQga2V5Ym9hcmQgYmluZGluZycsIGJpbmRpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRleHQgPSB7IGhhbmRsZXI6IGNvbnRleHQgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyID0geyBoYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgICB9XG4gICAgICBiaW5kaW5nID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKGJpbmRpbmcsIGNvbnRleHQsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5iaW5kaW5nc1tiaW5kaW5nLmtleV0gPSB0aGlzLmJpbmRpbmdzW2JpbmRpbmcua2V5XSB8fCBbXTtcbiAgICAgIHRoaXMuYmluZGluZ3NbYmluZGluZy5rZXldLnB1c2goYmluZGluZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgdmFyIHdoaWNoID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSAoX3RoaXMyLmJpbmRpbmdzW3doaWNoXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIEtleWJvYXJkLm1hdGNoKGV2dCwgYmluZGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmluZGluZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwgfHwgIV90aGlzMi5xdWlsbC5oYXNGb2N1cygpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lID0gX3RoaXMyLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUsIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMlswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lMlsxXTtcblxuICAgICAgICB2YXIgX3F1aWxsJGdldExlYWYgPSBfdGhpczIucXVpbGwuZ2V0TGVhZihyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGVhZjIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGVhZiwgMiksXG4gICAgICAgICAgICBsZWFmU3RhcnQgPSBfcXVpbGwkZ2V0TGVhZjJbMF0sXG4gICAgICAgICAgICBvZmZzZXRTdGFydCA9IF9xdWlsbCRnZXRMZWFmMlsxXTtcblxuICAgICAgICB2YXIgX3JlZiA9IHJhbmdlLmxlbmd0aCA9PT0gMCA/IFtsZWFmU3RhcnQsIG9mZnNldFN0YXJ0XSA6IF90aGlzMi5xdWlsbC5nZXRMZWFmKHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoKSxcbiAgICAgICAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBsZWFmRW5kID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBvZmZzZXRFbmQgPSBfcmVmMlsxXTtcblxuICAgICAgICB2YXIgcHJlZml4VGV4dCA9IGxlYWZTdGFydCBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuVGV4dCA/IGxlYWZTdGFydC52YWx1ZSgpLnNsaWNlKDAsIG9mZnNldFN0YXJ0KSA6ICcnO1xuICAgICAgICB2YXIgc3VmZml4VGV4dCA9IGxlYWZFbmQgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LlRleHQgPyBsZWFmRW5kLnZhbHVlKCkuc2xpY2Uob2Zmc2V0RW5kKSA6ICcnO1xuICAgICAgICB2YXIgY3VyQ29udGV4dCA9IHtcbiAgICAgICAgICBjb2xsYXBzZWQ6IHJhbmdlLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICBlbXB0eTogcmFuZ2UubGVuZ3RoID09PSAwICYmIGxpbmUubGVuZ3RoKCkgPD0gMSxcbiAgICAgICAgICBmb3JtYXQ6IF90aGlzMi5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHByZWZpeDogcHJlZml4VGV4dCxcbiAgICAgICAgICBzdWZmaXg6IHN1ZmZpeFRleHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByZXZlbnRlZCA9IGJpbmRpbmdzLnNvbWUoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICBpZiAoYmluZGluZy5jb2xsYXBzZWQgIT0gbnVsbCAmJiBiaW5kaW5nLmNvbGxhcHNlZCAhPT0gY3VyQ29udGV4dC5jb2xsYXBzZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5lbXB0eSAhPSBudWxsICYmIGJpbmRpbmcuZW1wdHkgIT09IGN1ckNvbnRleHQuZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5vZmZzZXQgIT0gbnVsbCAmJiBiaW5kaW5nLm9mZnNldCAhPT0gY3VyQ29udGV4dC5vZmZzZXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIC8vIGFueSBmb3JtYXQgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGJpbmRpbmcuZm9ybWF0LmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSA9PSBudWxsO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihiaW5kaW5nLmZvcm1hdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBhbGwgZm9ybWF0cyBtdXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGJpbmRpbmcuZm9ybWF0KS5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IHRydWUpIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSAhPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IGZhbHNlKSByZXR1cm4gY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0gPT0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShiaW5kaW5nLmZvcm1hdFtuYW1lXSwgY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0pO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmluZGluZy5wcmVmaXggIT0gbnVsbCAmJiAhYmluZGluZy5wcmVmaXgudGVzdChjdXJDb250ZXh0LnByZWZpeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZGluZy5zdWZmaXggIT0gbnVsbCAmJiAhYmluZGluZy5zdWZmaXgudGVzdChjdXJDb250ZXh0LnN1ZmZpeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gYmluZGluZy5oYW5kbGVyLmNhbGwoX3RoaXMyLCByYW5nZSwgY3VyQ29udGV4dCkgIT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlib2FyZDtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbktleWJvYXJkLmtleXMgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIEVTQ0FQRTogMjcsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIFJJR0hUOiAzOSxcbiAgRE9XTjogNDAsXG4gIERFTEVURTogNDZcbn07XG5cbktleWJvYXJkLkRFRkFVTFRTID0ge1xuICBiaW5kaW5nczoge1xuICAgICdib2xkJzogbWFrZUZvcm1hdEhhbmRsZXIoJ2JvbGQnKSxcbiAgICAnaXRhbGljJzogbWFrZUZvcm1hdEhhbmRsZXIoJ2l0YWxpYycpLFxuICAgICd1bmRlcmxpbmUnOiBtYWtlRm9ybWF0SGFuZGxlcigndW5kZXJsaW5lJyksXG4gICAgJ2luZGVudCc6IHtcbiAgICAgIC8vIGhpZ2hsaWdodCB0YWIgb3IgdGFiIGF0IGJlZ2lubmluZyBvZiBsaXN0LCBpbmRlbnQgb3IgYmxvY2txdW90ZVxuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJywgJ2luZGVudCcsICdsaXN0J10sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNvbGxhcHNlZCAmJiBjb250ZXh0Lm9mZnNldCAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCAnKzEnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdvdXRkZW50Jzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2Jsb2NrcXVvdGUnLCAnaW5kZW50JywgJ2xpc3QnXSxcbiAgICAgIC8vIGhpZ2hsaWdodCB0YWIgb3IgdGFiIGF0IGJlZ2lubmluZyBvZiBsaXN0LCBpbmRlbnQgb3IgYmxvY2txdW90ZVxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5jb2xsYXBzZWQgJiYgY29udGV4dC5vZmZzZXQgIT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgJy0xJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAnb3V0ZGVudCBiYWNrc3BhY2UnOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgc2hpZnRLZXk6IG51bGwsXG4gICAgICBtZXRhS2V5OiBudWxsLFxuICAgICAgY3RybEtleTogbnVsbCxcbiAgICAgIGFsdEtleTogbnVsbCxcbiAgICAgIGZvcm1hdDogWydpbmRlbnQnLCAnbGlzdCddLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5mb3JtYXQuaW5kZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgJy0xJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5mb3JtYXQubGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRlbnQgY29kZS1ibG9jayc6IG1ha2VDb2RlQmxvY2tIYW5kbGVyKHRydWUpLFxuICAgICdvdXRkZW50IGNvZGUtYmxvY2snOiBtYWtlQ29kZUJsb2NrSGFuZGxlcihmYWxzZSksXG4gICAgJ3JlbW92ZSB0YWInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgICAgc2hpZnRLZXk6IHRydWUsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBwcmVmaXg6IC9cXHQkLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLmluZGV4IC0gMSwgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAndGFiJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCgnXFx0Jyk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdsaXN0IGVtcHR5IGVudGVyJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2xpc3QnXSxcbiAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgaWYgKGNvbnRleHQuZm9ybWF0LmluZGVudCkge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdjaGVja2xpc3QgZW50ZXInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IHsgbGlzdDogJ2NoZWNrZWQnIH0sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUzLCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTRbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTRbMV07XG5cbiAgICAgICAgdmFyIGZvcm1hdHMgPSAoMCwgX2V4dGVuZDIuZGVmYXVsdCkoe30sIGxpbmUuZm9ybWF0cygpLCB7IGxpc3Q6ICdjaGVja2VkJyB9KTtcbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5pbnNlcnQoJ1xcbicsIGZvcm1hdHMpLnJldGFpbihsaW5lLmxlbmd0aCgpIC0gb2Zmc2V0IC0gMSkucmV0YWluKDEsIHsgbGlzdDogJ3VuY2hlY2tlZCcgfSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdoZWFkZXIgZW50ZXInOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnaGVhZGVyJ10sXG4gICAgICBzdWZmaXg6IC9eJC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZTUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExpbmU2ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmU1LCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTZbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTZbMV07XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5pbnNlcnQoJ1xcbicsIGNvbnRleHQuZm9ybWF0KS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIG9mZnNldCAtIDEpLnJldGFpbigxLCB7IGhlYWRlcjogbnVsbCB9KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xpc3QgYXV0b2ZpbGwnOiB7XG4gICAgICBrZXk6ICcgJyxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogeyBsaXN0OiBmYWxzZSB9LFxuICAgICAgcHJlZml4OiAvXlxccyo/KFxcZCtcXC58LXxcXCp8XFxbID9cXF18XFxbeFxcXSkkLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRleHQucHJlZml4Lmxlbmd0aDtcblxuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmU3ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lOCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lNywgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmU4WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmU4WzFdO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPiBsZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAoY29udGV4dC5wcmVmaXgudHJpbSgpKSB7XG4gICAgICAgICAgY2FzZSAnW10nOmNhc2UgJ1sgXSc6XG4gICAgICAgICAgICB2YWx1ZSA9ICd1bmNoZWNrZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnW3hdJzpcbiAgICAgICAgICAgIHZhbHVlID0gJ2NoZWNrZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnLSc6Y2FzZSAnKic6XG4gICAgICAgICAgICB2YWx1ZSA9ICdidWxsZXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbHVlID0gJ29yZGVyZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0VGV4dChyYW5nZS5pbmRleCwgJyAnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXggLSBvZmZzZXQpLmRlbGV0ZShsZW5ndGggKyAxKS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIDIgLSBvZmZzZXQpLnJldGFpbigxLCB7IGxpc3Q6IHZhbHVlIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCAtIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlIGV4aXQnOiB7XG4gICAgICBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnY29kZS1ibG9jayddLFxuICAgICAgcHJlZml4OiAvXFxuXFxuJC8sXG4gICAgICBzdWZmaXg6IC9eXFxzKyQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmU5ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lMTAgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTksIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMTBbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTEwWzFdO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCArIGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAyKS5yZXRhaW4oMSwgeyAnY29kZS1ibG9jayc6IG51bGwgfSkuZGVsZXRlKDEpO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdlbWJlZCBsZWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuTEVGVCwgZmFsc2UpLFxuICAgICdlbWJlZCBsZWZ0IHNoaWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuTEVGVCwgdHJ1ZSksXG4gICAgJ2VtYmVkIHJpZ2h0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuUklHSFQsIGZhbHNlKSxcbiAgICAnZW1iZWQgcmlnaHQgc2hpZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoS2V5Ym9hcmQua2V5cy5SSUdIVCwgdHJ1ZSlcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFrZUVtYmVkQXJyb3dIYW5kbGVyKGtleSwgc2hpZnRLZXkpIHtcbiAgdmFyIF9yZWYzO1xuXG4gIHZhciB3aGVyZSA9IGtleSA9PT0gS2V5Ym9hcmQua2V5cy5MRUZUID8gJ3ByZWZpeCcgOiAnc3VmZml4JztcbiAgcmV0dXJuIF9yZWYzID0ge1xuICAgIGtleToga2V5LFxuICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICBhbHRLZXk6IG51bGxcbiAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCB3aGVyZSwgL14kLyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ2hhbmRsZXInLCBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXg7XG4gICAgaWYgKGtleSA9PT0gS2V5Ym9hcmQua2V5cy5SSUdIVCkge1xuICAgICAgaW5kZXggKz0gcmFuZ2UubGVuZ3RoICsgMTtcbiAgICB9XG5cbiAgICB2YXIgX3F1aWxsJGdldExlYWYzID0gdGhpcy5xdWlsbC5nZXRMZWFmKGluZGV4KSxcbiAgICAgICAgX3F1aWxsJGdldExlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExlYWYzLCAxKSxcbiAgICAgICAgbGVhZiA9IF9xdWlsbCRnZXRMZWFmNFswXTtcblxuICAgIGlmICghKGxlYWYgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGtleSA9PT0gS2V5Ym9hcmQua2V5cy5MRUZUKSB7XG4gICAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSAxLCByYW5nZS5sZW5ndGggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pLCBfcmVmMztcbn1cblxuZnVuY3Rpb24gaGFuZGxlQmFja3NwYWNlKHJhbmdlLCBjb250ZXh0KSB7XG4gIGlmIChyYW5nZS5pbmRleCA9PT0gMCB8fCB0aGlzLnF1aWxsLmdldExlbmd0aCgpIDw9IDEpIHJldHVybjtcblxuICB2YXIgX3F1aWxsJGdldExpbmUxMSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICBfcXVpbGwkZ2V0TGluZTEyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxMSwgMSksXG4gICAgICBsaW5lID0gX3F1aWxsJGdldExpbmUxMlswXTtcblxuICB2YXIgZm9ybWF0cyA9IHt9O1xuICBpZiAoY29udGV4dC5vZmZzZXQgPT09IDApIHtcbiAgICB2YXIgX3F1aWxsJGdldExpbmUxMyA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCAtIDEpLFxuICAgICAgICBfcXVpbGwkZ2V0TGluZTE0ID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmUxMywgMSksXG4gICAgICAgIHByZXYgPSBfcXVpbGwkZ2V0TGluZTE0WzBdO1xuXG4gICAgaWYgKHByZXYgIT0gbnVsbCAmJiBwcmV2Lmxlbmd0aCgpID4gMSkge1xuICAgICAgdmFyIGN1ckZvcm1hdHMgPSBsaW5lLmZvcm1hdHMoKTtcbiAgICAgIHZhciBwcmV2Rm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlLmluZGV4IC0gMSwgMSk7XG4gICAgICBmb3JtYXRzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihjdXJGb3JtYXRzLCBwcmV2Rm9ybWF0cykgfHwge307XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBhc3RyYWwgc3ltYm9sc1xuICB2YXIgbGVuZ3RoID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0kLy50ZXN0KGNvbnRleHQucHJlZml4KSA/IDIgOiAxO1xuICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UuaW5kZXggLSBsZW5ndGgsIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5xdWlsbC5mb3JtYXRMaW5lKHJhbmdlLmluZGV4IC0gbGVuZ3RoLCBsZW5ndGgsIGZvcm1hdHMsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICB9XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRGVsZXRlKHJhbmdlLCBjb250ZXh0KSB7XG4gIC8vIENoZWNrIGZvciBhc3RyYWwgc3ltYm9sc1xuICB2YXIgbGVuZ3RoID0gL15bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdLy50ZXN0KGNvbnRleHQuc3VmZml4KSA/IDIgOiAxO1xuICBpZiAocmFuZ2UuaW5kZXggPj0gdGhpcy5xdWlsbC5nZXRMZW5ndGgoKSAtIGxlbmd0aCkgcmV0dXJuO1xuICB2YXIgZm9ybWF0cyA9IHt9LFxuICAgICAgbmV4dExlbmd0aCA9IDA7XG5cbiAgdmFyIF9xdWlsbCRnZXRMaW5lMTUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgX3F1aWxsJGdldExpbmUxNiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTUsIDEpLFxuICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMTZbMF07XG5cbiAgaWYgKGNvbnRleHQub2Zmc2V0ID49IGxpbmUubGVuZ3RoKCkgLSAxKSB7XG4gICAgdmFyIF9xdWlsbCRnZXRMaW5lMTcgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXggKyAxKSxcbiAgICAgICAgX3F1aWxsJGdldExpbmUxOCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTcsIDEpLFxuICAgICAgICBuZXh0ID0gX3F1aWxsJGdldExpbmUxOFswXTtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICB2YXIgY3VyRm9ybWF0cyA9IGxpbmUuZm9ybWF0cygpO1xuICAgICAgdmFyIG5leHRGb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UuaW5kZXgsIDEpO1xuICAgICAgZm9ybWF0cyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYoY3VyRm9ybWF0cywgbmV4dEZvcm1hdHMpIHx8IHt9O1xuICAgICAgbmV4dExlbmd0aCA9IG5leHQubGVuZ3RoKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucXVpbGwuZGVsZXRlVGV4dChyYW5nZS5pbmRleCwgbGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLmZvcm1hdExpbmUocmFuZ2UuaW5kZXggKyBuZXh0TGVuZ3RoIC0gMSwgbGVuZ3RoLCBmb3JtYXRzLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEZWxldGVSYW5nZShyYW5nZSkge1xuICB2YXIgbGluZXMgPSB0aGlzLnF1aWxsLmdldExpbmVzKHJhbmdlKTtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgZmlyc3RGb3JtYXRzID0gbGluZXNbMF0uZm9ybWF0cygpO1xuICAgIHZhciBsYXN0Rm9ybWF0cyA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmZvcm1hdHMoKTtcbiAgICBmb3JtYXRzID0gX29wMi5kZWZhdWx0LmF0dHJpYnV0ZXMuZGlmZihsYXN0Rm9ybWF0cywgZmlyc3RGb3JtYXRzKSB8fCB7fTtcbiAgfVxuICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucXVpbGwuZm9ybWF0TGluZShyYW5nZS5pbmRleCwgMSwgZm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIH1cbiAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRW50ZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgaWYgKHJhbmdlLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLnNjcm9sbC5kZWxldGVBdChyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTsgLy8gU28gd2UgZG8gbm90IHRyaWdnZXIgdGV4dC1jaGFuZ2VcbiAgfVxuICB2YXIgbGluZUZvcm1hdHMgPSBPYmplY3Qua2V5cyhjb250ZXh0LmZvcm1hdCkucmVkdWNlKGZ1bmN0aW9uIChsaW5lRm9ybWF0cywgZm9ybWF0KSB7XG4gICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoZm9ybWF0LCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSAmJiAhQXJyYXkuaXNBcnJheShjb250ZXh0LmZvcm1hdFtmb3JtYXRdKSkge1xuICAgICAgbGluZUZvcm1hdHNbZm9ybWF0XSA9IGNvbnRleHQuZm9ybWF0W2Zvcm1hdF07XG4gICAgfVxuICAgIHJldHVybiBsaW5lRm9ybWF0cztcbiAgfSwge30pO1xuICB0aGlzLnF1aWxsLmluc2VydFRleHQocmFuZ2UuaW5kZXgsICdcXG4nLCBsaW5lRm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIC8vIEVhcmxpZXIgc2Nyb2xsLmRlbGV0ZUF0IG1pZ2h0IGhhdmUgbWVzc2VkIHVwIG91ciBzZWxlY3Rpb24sXG4gIC8vIHNvIGluc2VydFRleHQncyBidWlsdCBpbiBzZWxlY3Rpb24gcHJlc2VydmF0aW9uIGlzIG5vdCByZWxpYWJsZVxuICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gIHRoaXMucXVpbGwuZm9jdXMoKTtcbiAgT2JqZWN0LmtleXMoY29udGV4dC5mb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobGluZUZvcm1hdHNbbmFtZV0gIT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRleHQuZm9ybWF0W25hbWVdKSkgcmV0dXJuO1xuICAgIGlmIChuYW1lID09PSAnbGluaycpIHJldHVybjtcbiAgICBfdGhpczMucXVpbGwuZm9ybWF0KG5hbWUsIGNvbnRleHQuZm9ybWF0W25hbWVdLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb2RlQmxvY2tIYW5kbGVyKGluZGVudCkge1xuICByZXR1cm4ge1xuICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgc2hpZnRLZXk6ICFpbmRlbnQsXG4gICAgZm9ybWF0OiB7ICdjb2RlLWJsb2NrJzogdHJ1ZSB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgIHZhciBDb2RlQmxvY2sgPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KCdjb2RlLWJsb2NrJyk7XG4gICAgICB2YXIgaW5kZXggPSByYW5nZS5pbmRleCxcbiAgICAgICAgICBsZW5ndGggPSByYW5nZS5sZW5ndGg7XG5cbiAgICAgIHZhciBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQgPSB0aGlzLnF1aWxsLnNjcm9sbC5kZXNjZW5kYW50KENvZGVCbG9jaywgaW5kZXgpLFxuICAgICAgICAgIF9xdWlsbCRzY3JvbGwkZGVzY2VuZDIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkc2Nyb2xsJGRlc2NlbmQsIDIpLFxuICAgICAgICAgIGJsb2NrID0gX3F1aWxsJHNjcm9sbCRkZXNjZW5kMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzFdO1xuXG4gICAgICBpZiAoYmxvY2sgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHNjcm9sbEluZGV4ID0gdGhpcy5xdWlsbC5nZXRJbmRleChibG9jayk7XG4gICAgICB2YXIgc3RhcnQgPSBibG9jay5uZXdsaW5lSW5kZXgob2Zmc2V0LCB0cnVlKSArIDE7XG4gICAgICB2YXIgZW5kID0gYmxvY2submV3bGluZUluZGV4KHNjcm9sbEluZGV4ICsgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgIHZhciBsaW5lcyA9IGJsb2NrLmRvbU5vZGUudGV4dENvbnRlbnQuc2xpY2Uoc3RhcnQsIGVuZCkuc3BsaXQoJ1xcbicpO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgIGJsb2NrLmluc2VydEF0KHN0YXJ0ICsgb2Zmc2V0LCBDb2RlQmxvY2suVEFCKTtcbiAgICAgICAgICBvZmZzZXQgKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChDb2RlQmxvY2suVEFCKSkge1xuICAgICAgICAgIGJsb2NrLmRlbGV0ZUF0KHN0YXJ0ICsgb2Zmc2V0LCBDb2RlQmxvY2suVEFCLmxlbmd0aCk7XG4gICAgICAgICAgb2Zmc2V0IC09IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBpbmRleCAtPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoIC09IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4LCBsZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0SGFuZGxlcihmb3JtYXQpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZvcm1hdFswXS50b1VwcGVyQ2FzZSgpLFxuICAgIHNob3J0S2V5OiB0cnVlLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgIHRoaXMucXVpbGwuZm9ybWF0KGZvcm1hdCwgIWNvbnRleHQuZm9ybWF0W2Zvcm1hdF0sIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGJpbmRpbmcpIHtcbiAgaWYgKHR5cGVvZiBiaW5kaW5nID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYmluZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHsga2V5OiBiaW5kaW5nIH0pO1xuICB9XG4gIGlmICgodHlwZW9mIGJpbmRpbmcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJpbmRpbmcpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBiaW5kaW5nID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkoYmluZGluZywgZmFsc2UpO1xuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZy5rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEtleWJvYXJkLmtleXNbYmluZGluZy5rZXkudG9VcHBlckNhc2UoKV0gIT0gbnVsbCkge1xuICAgICAgYmluZGluZy5rZXkgPSBLZXlib2FyZC5rZXlzW2JpbmRpbmcua2V5LnRvVXBwZXJDYXNlKCldO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZy5rZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBiaW5kaW5nLmtleSA9IGJpbmRpbmcua2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChiaW5kaW5nLnNob3J0S2V5KSB7XG4gICAgYmluZGluZ1tTSE9SVEtFWV0gPSBiaW5kaW5nLnNob3J0S2V5O1xuICAgIGRlbGV0ZSBiaW5kaW5nLnNob3J0S2V5O1xuICB9XG4gIHJldHVybiBiaW5kaW5nO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBLZXlib2FyZDtcbmV4cG9ydHMuU0hPUlRLRVkgPSBTSE9SVEtFWTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ3Vyc29yID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEN1cnNvciwgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnNvciwgbnVsbCwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBDdXJzb3IoZG9tTm9kZSwgc2VsZWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnNvcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ3Vyc29yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yKSkuY2FsbCh0aGlzLCBkb21Ob2RlKSk7XG5cbiAgICBfdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgX3RoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDdXJzb3IuQ09OVEVOVFMpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMudGV4dE5vZGUpO1xuICAgIF90aGlzLl9sZW5ndGggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXJzb3IsIFt7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgLy8gc3VwZXIuZGV0YWNoKCkgd2lsbCBhbHNvIGNsZWFyIGRvbU5vZGUuX19ibG90XG4gICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KEN1cnNvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgd2hpbGUgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5zdGF0aWNzLnNjb3BlICE9PSBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLX0JMT1QpIHtcbiAgICAgICAgaW5kZXggKz0gdGFyZ2V0Lm9mZnNldCh0YXJnZXQucGFyZW50KTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoO1xuICAgICAgICB0YXJnZXQub3B0aW1pemUoKTtcbiAgICAgICAgdGFyZ2V0LmZvcm1hdEF0KGluZGV4LCBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRleHROb2RlKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBfZ2V0KEN1cnNvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgJ2luZGV4JywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy50ZXh0Tm9kZSwgdGhpcy50ZXh0Tm9kZS5kYXRhLmxlbmd0aF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgX2dldChDdXJzb3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Vyc29yLnByb3RvdHlwZSksICdyZW1vdmUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmNvbXBvc2luZyB8fCB0aGlzLnBhcmVudCA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgdGV4dE5vZGUgPSB0aGlzLnRleHROb2RlO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIHZhciByZXN0b3JlVGV4dCA9IHZvaWQgMCxcbiAgICAgICAgICBzdGFydCA9IHZvaWQgMCxcbiAgICAgICAgICBlbmQgPSB2b2lkIDA7XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCAmJiByYW5nZS5zdGFydC5ub2RlID09PSB0ZXh0Tm9kZSAmJiByYW5nZS5lbmQubm9kZSA9PT0gdGV4dE5vZGUpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBbdGV4dE5vZGUsIHJhbmdlLnN0YXJ0Lm9mZnNldCwgcmFuZ2UuZW5kLm9mZnNldF07XG4gICAgICAgIHJlc3RvcmVUZXh0ID0gX3JlZlswXTtcbiAgICAgICAgc3RhcnQgPSBfcmVmWzFdO1xuICAgICAgICBlbmQgPSBfcmVmWzJdO1xuICAgICAgfVxuICAgICAgLy8gTGluayBmb3JtYXQgd2lsbCBpbnNlcnQgdGV4dCBvdXRzaWRlIG9mIGFuY2hvciB0YWdcbiAgICAgIHdoaWxlICh0aGlzLmRvbU5vZGUubGFzdENoaWxkICE9IG51bGwgJiYgdGhpcy5kb21Ob2RlLmxhc3RDaGlsZCAhPT0gdGhpcy50ZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21Ob2RlLmxhc3RDaGlsZCwgdGhpcy5kb21Ob2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHROb2RlLmRhdGEgIT09IEN1cnNvci5DT05URU5UUykge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dE5vZGUuZGF0YS5zcGxpdChDdXJzb3IuQ09OVEVOVFMpLmpvaW4oJycpO1xuICAgICAgICBpZiAodGhpcy5uZXh0IGluc3RhbmNlb2YgX3RleHQyLmRlZmF1bHQpIHtcbiAgICAgICAgICByZXN0b3JlVGV4dCA9IHRoaXMubmV4dC5kb21Ob2RlO1xuICAgICAgICAgIHRoaXMubmV4dC5pbnNlcnRBdCgwLCB0ZXh0KTtcbiAgICAgICAgICB0aGlzLnRleHROb2RlLmRhdGEgPSBDdXJzb3IuQ09OVEVOVFM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50ZXh0Tm9kZS5kYXRhID0gdGV4dDtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUodGhpcy50ZXh0Tm9kZSksIHRoaXMpO1xuICAgICAgICAgIHRoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShDdXJzb3IuQ09OVEVOVFMpO1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBfbWFwID0gW3N0YXJ0LCBlbmRdLm1hcChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHJlc3RvcmVUZXh0LmRhdGEubGVuZ3RoLCBvZmZzZXQgLSAxKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfbWFwMiA9IF9zbGljZWRUb0FycmF5KF9tYXAsIDIpO1xuXG4gICAgICAgIHN0YXJ0ID0gX21hcDJbMF07XG4gICAgICAgIGVuZCA9IF9tYXAyWzFdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnROb2RlOiByZXN0b3JlVGV4dCxcbiAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnQsXG4gICAgICAgICAgZW5kTm9kZTogcmVzdG9yZVRleHQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBlbmRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLnRleHROb2RlO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChyYW5nZSkgY29udGV4dC5yYW5nZSA9IHJhbmdlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnNvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkN1cnNvci5ibG90TmFtZSA9ICdjdXJzb3InO1xuQ3Vyc29yLmNsYXNzTmFtZSA9ICdxbC1jdXJzb3InO1xuQ3Vyc29yLnRhZ05hbWUgPSAnc3Bhbic7XG5DdXJzb3IuQ09OVEVOVFMgPSAnXFx1RkVGRic7IC8vIFplcm8gd2lkdGggbm8gYnJlYWsgc3BhY2VcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBDdXJzb3I7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0cyhDb250YWluZXIsIF9QYXJjaG1lbnQkQ29udGFpbmVyKTtcblxuICBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbnRhaW5lci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnRhaW5lcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIENvbnRhaW5lcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpO1xuXG5Db250YWluZXIuYWxsb3dlZENoaWxkcmVuID0gW19ibG9jazIuZGVmYXVsdCwgX2Jsb2NrLkJsb2NrRW1iZWQsIENvbnRhaW5lcl07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRhaW5lcjtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbG9yU3R5bGUgPSBleHBvcnRzLkNvbG9yQ2xhc3MgPSBleHBvcnRzLkNvbG9yQXR0cmlidXRvciA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbG9yQXR0cmlidXRvciA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEF0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKENvbG9yQXR0cmlidXRvciwgX1BhcmNobWVudCRBdHRyaWJ1dG9yKTtcblxuICBmdW5jdGlvbiBDb2xvckF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yQXR0cmlidXRvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbG9yQXR0cmlidXRvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQXR0cmlidXRvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yQXR0cmlidXRvciwgW3tcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9nZXQoQ29sb3JBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQXR0cmlidXRvci5wcm90b3R5cGUpLCAndmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIGRvbU5vZGUpO1xuICAgICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKCdyZ2IoJykpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlteXFxkXSsvLCAnJykucmVwbGFjZSgvW15cXGRdKyQvLCAnJyk7XG4gICAgICByZXR1cm4gJyMnICsgdmFsdWUuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKCcwMCcgKyBwYXJzZUludChjb21wb25lbnQpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yQXR0cmlidXRvcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlKTtcblxudmFyIENvbG9yQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdjb2xvcicsICdxbC1jb2xvcicsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcbnZhciBDb2xvclN0eWxlID0gbmV3IENvbG9yQXR0cmlidXRvcignY29sb3InLCAnY29sb3InLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG5cbmV4cG9ydHMuQ29sb3JBdHRyaWJ1dG9yID0gQ29sb3JBdHRyaWJ1dG9yO1xuZXhwb3J0cy5Db2xvckNsYXNzID0gQ29sb3JDbGFzcztcbmV4cG9ydHMuQ29sb3JTdHlsZSA9IENvbG9yU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zYW5pdGl6ZSA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExpbmsgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoTGluaywgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gTGluaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExpbmsuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5rKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluaywgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgfHwgIXZhbHVlKSByZXR1cm4gX2dldChMaW5rLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpbmsucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLnNhbml0aXplKHZhbHVlKTtcbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChMaW5rLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGluayksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIHZhbHVlID0gdGhpcy5zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdyZWwnLCAnbm9vcGVuZXIgbm9yZWZlcnJlcicpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nhbml0aXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICByZXR1cm4gX3Nhbml0aXplKHVybCwgdGhpcy5QUk9UT0NPTF9XSElURUxJU1QpID8gdXJsIDogdGhpcy5TQU5JVElaRURfVVJMO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuTGluay5ibG90TmFtZSA9ICdsaW5rJztcbkxpbmsudGFnTmFtZSA9ICdBJztcbkxpbmsuU0FOSVRJWkVEX1VSTCA9ICdhYm91dDpibGFuayc7XG5MaW5rLlBST1RPQ09MX1dISVRFTElTVCA9IFsnaHR0cCcsICdodHRwcycsICdtYWlsdG8nLCAndGVsJ107XG5cbmZ1bmN0aW9uIF9zYW5pdGl6ZSh1cmwsIHByb3RvY29scykge1xuICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhbmNob3IuaHJlZiA9IHVybDtcbiAgdmFyIHByb3RvY29sID0gYW5jaG9yLmhyZWYuc2xpY2UoMCwgYW5jaG9yLmhyZWYuaW5kZXhPZignOicpKTtcbiAgcmV0dXJuIHByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA+IC0xO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5zYW5pdGl6ZSA9IF9zYW5pdGl6ZTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9rZXlib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgX2tleWJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWJvYXJkKTtcblxudmFyIF9kcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3KTtcblxudmFyIF9kcm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kcm9wZG93bik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvcHRpb25zQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIHRvZ2dsZUFyaWFBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgIShlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpID09PSAndHJ1ZScpKTtcbn1cblxudmFyIFBpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGlja2VyKHNlbGVjdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGlja2VyKTtcblxuICAgIHRoaXMuc2VsZWN0ID0gc2VsZWN0O1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMuYnVpbGRQaWNrZXIoKTtcbiAgICB0aGlzLnNlbGVjdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc2VsZWN0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY29udGFpbmVyLCB0aGlzLnNlbGVjdCk7XG5cbiAgICB0aGlzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnRvZ2dsZVBpY2tlcigpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIC8vIEFsbG93cyB0aGUgXCJFbnRlclwiIGtleSB0byBvcGVuIHRoZSBwaWNrZXJcbiAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FTlRFUjpcbiAgICAgICAgICBfdGhpcy50b2dnbGVQaWNrZXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRXNjYXBlXCIga2V5IHRvIGNsb3NlIHRoZSBwaWNrZXJcbiAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FU0NBUEU6XG4gICAgICAgICAgX3RoaXMuZXNjYXBlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaWNrZXIsIFt7XG4gICAga2V5OiAndG9nZ2xlUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlUGlja2VyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZSgncWwtZXhwYW5kZWQnKTtcbiAgICAgIC8vIFRvZ2dsZSBhcmlhLWV4cGFuZGVkIGFuZCBhcmlhLWhpZGRlbiB0byBtYWtlIHRoZSBwaWNrZXIgYWNjZXNzaWJsZVxuICAgICAgdG9nZ2xlQXJpYUF0dHJpYnV0ZSh0aGlzLmxhYmVsLCAnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgdG9nZ2xlQXJpYUF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMsICdhcmlhLWhpZGRlbicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkSXRlbShvcHRpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGl0ZW0udGFiSW5kZXggPSAnMCc7XG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcblxuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdxbC1waWNrZXItaXRlbScpO1xuICAgICAgaWYgKG9wdGlvbi5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24udGV4dENvbnRlbnQpIHtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnLCBvcHRpb24udGV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNlbGVjdEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRW50ZXJcIiBrZXkgdG8gc2VsZWN0IGFuIGl0ZW1cbiAgICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVOVEVSOlxuICAgICAgICAgICAgX3RoaXMyLnNlbGVjdEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRXNjYXBlXCIga2V5IHRvIGNsb3NlIHRoZSBwaWNrZXJcbiAgICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVTQ0FQRTpcbiAgICAgICAgICAgIF90aGlzMi5lc2NhcGUoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZExhYmVsKCkge1xuICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyLWxhYmVsJyk7XG4gICAgICBsYWJlbC5pbm5lckhUTUwgPSBfZHJvcGRvd24yLmRlZmF1bHQ7XG4gICAgICBsYWJlbC50YWJJbmRleCA9ICcwJztcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkT3B0aW9ucygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIG9wdGlvbnMuY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyLW9wdGlvbnMnKTtcblxuICAgICAgLy8gRG9uJ3Qgd2FudCBzY3JlZW4gcmVhZGVycyB0byByZWFkIHRoaXMgdW50aWwgb3B0aW9ucyBhcmUgdmlzaWJsZVxuICAgICAgb3B0aW9ucy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIG9wdGlvbnMudGFiSW5kZXggPSAnLTEnO1xuXG4gICAgICAvLyBOZWVkIGEgdW5pcXVlIGlkIGZvciBhcmlhLWNvbnRyb2xzXG4gICAgICBvcHRpb25zLmlkID0gJ3FsLXBpY2tlci1vcHRpb25zLScgKyBvcHRpb25zQ291bnRlcjtcbiAgICAgIG9wdGlvbnNDb3VudGVyICs9IDE7XG4gICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIG9wdGlvbnMuaWQpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBbXS5zbGljZS5jYWxsKHRoaXMuc2VsZWN0Lm9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgaXRlbSA9IF90aGlzMy5idWlsZEl0ZW0ob3B0aW9uKTtcbiAgICAgICAgb3B0aW9ucy5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzMy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRQaWNrZXIoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLnNlbGVjdC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIF90aGlzNC5jb250YWluZXIuc2V0QXR0cmlidXRlKGl0ZW0ubmFtZSwgaXRlbS52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXBpY2tlcicpO1xuICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuYnVpbGRMYWJlbCgpO1xuICAgICAgdGhpcy5idWlsZE9wdGlvbnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gQ2xvc2UgbWVudSBhbmQgcmV0dXJuIGZvY3VzIHRvIHRyaWdnZXIgbGFiZWxcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIC8vIE5lZWQgc2V0VGltZW91dCBmb3IgYWNjZXNzaWJpbGl0eSB0byBlbnN1cmUgdGhhdCB0aGUgYnJvd3NlciBleGVjdXRlc1xuICAgICAgLy8gZm9jdXMgb24gdGhlIG5leHQgcHJvY2VzcyB0aHJlYWQgYW5kIGFmdGVyIGFueSBET00gY29udGVudCBjaGFuZ2VzXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5sYWJlbC5mb2N1cygpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWV4cGFuZGVkJyk7XG4gICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgdGhpcy5vcHRpb25zLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLnFsLXNlbGVjdGVkJyk7XG4gICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHJldHVybjtcbiAgICAgIGlmIChzZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ3FsLXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3FsLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4ID0gW10uaW5kZXhPZi5jYWxsKGl0ZW0ucGFyZW50Tm9kZS5jaGlsZHJlbiwgaXRlbSk7XG4gICAgICBpZiAoaXRlbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSkge1xuICAgICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScsIGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLmhhc0F0dHJpYnV0ZSgnZGF0YS1sYWJlbCcpKSB7XG4gICAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJywgaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhYmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sYWJlbCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBFdmVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoRXZlbnQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIG9wdGlvbiA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtcGlja2VyLW9wdGlvbnMnKS5jaGlsZHJlblt0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgb3B0aW9uID0gdGhpcy5zZWxlY3Qub3B0aW9uc1t0aGlzLnNlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtKG51bGwpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQWN0aXZlID0gb3B0aW9uICE9IG51bGwgJiYgb3B0aW9uICE9PSB0aGlzLnNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bc2VsZWN0ZWRdJyk7XG4gICAgICB0aGlzLmxhYmVsLmNsYXNzTGlzdC50b2dnbGUoJ3FsLWFjdGl2ZScsIGlzQWN0aXZlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGlja2VyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQaWNrZXI7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX2NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWluZXIpO1xuXG52YXIgX2N1cnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG52YXIgX2N1cnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jdXJzb3IpO1xuXG52YXIgX2VtYmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfZW1iZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1iZWQpO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbnZhciBfc2Nyb2xsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBfc2Nyb2xsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxudmFyIF9jbGlwYm9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblxudmFyIF9jbGlwYm9hcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xpcGJvYXJkKTtcblxudmFyIF9oaXN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbnZhciBfaGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5KTtcblxudmFyIF9rZXlib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgX2tleWJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWJvYXJkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX3F1aWxsMi5kZWZhdWx0LnJlZ2lzdGVyKHtcbiAgJ2Jsb3RzL2Jsb2NrJzogX2Jsb2NrMi5kZWZhdWx0LFxuICAnYmxvdHMvYmxvY2svZW1iZWQnOiBfYmxvY2suQmxvY2tFbWJlZCxcbiAgJ2Jsb3RzL2JyZWFrJzogX2JyZWFrMi5kZWZhdWx0LFxuICAnYmxvdHMvY29udGFpbmVyJzogX2NvbnRhaW5lcjIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2N1cnNvcic6IF9jdXJzb3IyLmRlZmF1bHQsXG4gICdibG90cy9lbWJlZCc6IF9lbWJlZDIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2lubGluZSc6IF9pbmxpbmUyLmRlZmF1bHQsXG4gICdibG90cy9zY3JvbGwnOiBfc2Nyb2xsMi5kZWZhdWx0LFxuICAnYmxvdHMvdGV4dCc6IF90ZXh0Mi5kZWZhdWx0LFxuXG4gICdtb2R1bGVzL2NsaXBib2FyZCc6IF9jbGlwYm9hcmQyLmRlZmF1bHQsXG4gICdtb2R1bGVzL2hpc3RvcnknOiBfaGlzdG9yeTIuZGVmYXVsdCxcbiAgJ21vZHVsZXMva2V5Ym9hcmQnOiBfa2V5Ym9hcmQyLmRlZmF1bHRcbn0pO1xuXG5fcGFyY2htZW50Mi5kZWZhdWx0LnJlZ2lzdGVyKF9ibG9jazIuZGVmYXVsdCwgX2JyZWFrMi5kZWZhdWx0LCBfY3Vyc29yMi5kZWZhdWx0LCBfaW5saW5lMi5kZWZhdWx0LCBfc2Nyb2xsMi5kZWZhdWx0LCBfdGV4dDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9xdWlsbDIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFNoYWRvd0Jsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93QmxvdChkb21Ob2RlKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZSA9IGRvbU5vZGU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXSA9IHsgYmxvdDogdGhpcyB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhZG93QmxvdC5wcm90b3R5cGUsIFwic3RhdGljc1wiLCB7XG4gICAgICAgIC8vIEhhY2sgZm9yIGFjY2Vzc2luZyBpbmhlcml0ZWQgc3RhdGljIG1ldGhvZHNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2hhZG93QmxvdC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVnaXN0cnkuUGFyY2htZW50RXJyb3IoJ0Jsb3QgZGVmaW5pdGlvbiBtaXNzaW5nIHRhZ05hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHZhbHVlKS50b1N0cmluZygpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZVt2YWx1ZSAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFnTmFtZS5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSB0aGlzLnBhcmVudC5zY3JvbGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IHRoaXMuZG9tTm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUmVnaXN0cnkuY3JlYXRlKGRvbU5vZGUpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYmxvdC5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBpZiAoUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQkxPVCkgIT0gbnVsbCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgYmxvdC53cmFwKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBSZWdpc3RyeS5jcmVhdGUodGhpcy5zdGF0aWNzLnNjb3BlKTtcbiAgICAgICAgICAgIGJsb3Qud3JhcChwYXJlbnQpO1xuICAgICAgICAgICAgcGFyZW50LmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIHZhciBibG90ID0gZGVmID09IG51bGwgPyBSZWdpc3RyeS5jcmVhdGUoJ3RleHQnLCB2YWx1ZSkgOiBSZWdpc3RyeS5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZik7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5pbnNlcnRJbnRvID0gZnVuY3Rpb24gKHBhcmVudEJsb3QsIHJlZkJsb3QpIHtcbiAgICAgICAgaWYgKHJlZkJsb3QgPT09IHZvaWQgMCkgeyByZWZCbG90ID0gbnVsbDsgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgcGFyZW50QmxvdC5jaGlsZHJlbi5pbnNlcnRCZWZvcmUodGhpcywgcmVmQmxvdCk7XG4gICAgICAgIGlmIChyZWZCbG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkRvbU5vZGUgPSByZWZCbG90LmRvbU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlICE9IHBhcmVudEJsb3QuZG9tTm9kZSB8fFxuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLm5leHRTaWJsaW5nICE9IHJlZkRvbU5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudEJsb3QuZG9tTm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21Ob2RlLCByZWZEb21Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudEJsb3Q7XG4gICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5pc29sYXRlID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICB0YXJnZXQuc3BsaXQobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICBpZiAocm9vdCA9PT0gdm9pZCAwKSB7IHJvb3QgPSB0aGlzLnBhcmVudDsgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCB8fCB0aGlzID09IHJvb3QpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuLm9mZnNldCh0aGlzKSArIHRoaXMucGFyZW50Lm9mZnNldChyb290KTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gVE9ETyBjbGVhbiB1cCBvbmNlIHdlIHVzZSBXZWFrTWFwXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGUucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0YXJnZXQucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCB0YXJnZXQubmV4dCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFJlZ2lzdHJ5LmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuICAgICAgICByZXBsYWNlbWVudC5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gdGhpcyA6IHRoaXMubmV4dDtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBieSBkZWZhdWx0XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gUmVnaXN0cnkuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGhpcy5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QuYmxvdE5hbWUgPSAnYWJzdHJhY3QnO1xuICAgIHJldHVybiBTaGFkb3dCbG90O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNoYWRvd0Jsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgY2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIHN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQXR0cmlidXRvclN0b3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0b3JTdG9yZShkb21Ob2RlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLmRvbU5vZGUgPSBkb21Ob2RlO1xuICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gdmVyYlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuYWRkKHRoaXMuZG9tTm9kZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSh0aGlzLmRvbU5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlLnJlbW92ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dG9yXzEuZGVmYXVsdC5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NfMS5kZWZhdWx0LmtleXModGhpcy5kb21Ob2RlKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlXzEuZGVmYXVsdC5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC5jb25jYXQoY2xhc3NlcylcbiAgICAgICAgICAgIC5jb25jYXQoc3R5bGVzKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFKTtcbiAgICAgICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgYXR0cmlidXRvcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzW2F0dHIuYXR0ck5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5hdHRyaWJ1dGVzW2tleV0udmFsdWUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgICAgICB0YXJnZXQuZm9ybWF0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb3B5KHRhcmdldCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzW2tleV0ucmVtb3ZlKF90aGlzLmRvbU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBuYW1lKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gX3RoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXR0cmlidXRvclN0b3JlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJpYnV0b3JTdG9yZTtcblxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuZnVuY3Rpb24gbWF0Y2gobm9kZSwgcHJlZml4KSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgIHJldHVybiBjbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZihwcmVmaXggKyBcIi1cIikgPT09IDA7XG4gICAgfSk7XG59XG52YXIgQ2xhc3NBdHRyaWJ1dG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc0F0dHJpYnV0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NBdHRyaWJ1dG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENsYXNzQXR0cmlidXRvci5rZXlzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lXG4gICAgICAgICAgICAgICAgLnNwbGl0KCctJylcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy0nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmtleU5hbWUgKyBcIi1cIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gbWF0Y2gobm9kZSwgdGhpcy5rZXlOYW1lKTtcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS5jbGFzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xhc3NBdHRyaWJ1dG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaChub2RlLCB0aGlzLmtleU5hbWUpWzBdIHx8ICcnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQuc2xpY2UodGhpcy5rZXlOYW1lLmxlbmd0aCArIDEpOyAvLyArMSBmb3IgaHlwaGVuXG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6ICcnO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzQXR0cmlidXRvcjtcbn0oYXR0cmlidXRvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsYXNzQXR0cmlidXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuZnVuY3Rpb24gY2FtZWxpemUobmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy0nKTtcbiAgICB2YXIgcmVzdCA9IHBhcnRzXG4gICAgICAgIC5zbGljZSgxKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0WzBdLnRvVXBwZXJDYXNlKCkgKyBwYXJ0LnNsaWNlKDEpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICByZXR1cm4gcGFydHNbMF0gKyByZXN0O1xufVxudmFyIFN0eWxlQXR0cmlidXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3R5bGVBdHRyaWJ1dG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0eWxlQXR0cmlidXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdHlsZUF0dHJpYnV0b3Iua2V5cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJycpLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyWzBdLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSAnJztcbiAgICAgICAgaWYgKCFub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6ICcnO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlQXR0cmlidXRvcjtcbn0oYXR0cmlidXRvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlQXR0cmlidXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaGVtZSk7XG5cbiAgICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaGVtZSwgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChfdGhpcy5tb2R1bGVzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpcy5hZGRNb2R1bGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZE1vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lKSB7XG4gICAgICB2YXIgbW9kdWxlQ2xhc3MgPSB0aGlzLnF1aWxsLmNvbnN0cnVjdG9yLmltcG9ydCgnbW9kdWxlcy8nICsgbmFtZSk7XG4gICAgICB0aGlzLm1vZHVsZXNbbmFtZV0gPSBuZXcgbW9kdWxlQ2xhc3ModGhpcy5xdWlsbCwgdGhpcy5vcHRpb25zLm1vZHVsZXNbbmFtZV0gfHwge30pO1xuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGhlbWU7XG59KCk7XG5cblRoZW1lLkRFRkFVTFRTID0ge1xuICBtb2R1bGVzOiB7fVxufTtcblRoZW1lLnRoZW1lcyA9IHtcbiAgJ2RlZmF1bHQnOiBUaGVtZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHVUFSRF9URVhUID0gJ1xcdUZFRkYnO1xuXG52YXIgRW1iZWQgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoRW1iZWQsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEVtYmVkKG5vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1iZWQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVtYmVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1iZWQpKS5jYWxsKHRoaXMsIG5vZGUpKTtcblxuICAgIF90aGlzLmNvbnRlbnROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIF90aGlzLmNvbnRlbnROb2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgIFtdLnNsaWNlLmNhbGwoX3RoaXMuZG9tTm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgIF90aGlzLmNvbnRlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgfSk7XG4gICAgX3RoaXMubGVmdEd1YXJkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoR1VBUkRfVEVYVCk7XG4gICAgX3RoaXMucmlnaHRHdWFyZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEdVQVJEX1RFWFQpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMubGVmdEd1YXJkKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnROb2RlKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLnJpZ2h0R3VhcmQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWJlZCwgW3tcbiAgICBrZXk6ICdpbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4KG5vZGUsIG9mZnNldCkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVmdEd1YXJkKSByZXR1cm4gMDtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnJpZ2h0R3VhcmQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIF9nZXQoRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1iZWQucHJvdG90eXBlKSwgJ2luZGV4JywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0Tm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZXh0ID0gbm9kZS5kYXRhLnNwbGl0KEdVQVJEX1RFWFQpLmpvaW4oJycpO1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVmdEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYgaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBwcmV2TGVuZ3RoID0gdGhpcy5wcmV2Lmxlbmd0aCgpO1xuICAgICAgICAgIHRoaXMucHJldi5pbnNlcnRBdChwcmV2TGVuZ3RoLCB0ZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGhpcy5wcmV2LmRvbU5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogcHJldkxlbmd0aCArIHRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0ZXh0Tm9kZSksIHRoaXMpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gdGhpcy5yaWdodEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMubmV4dC5pbnNlcnRBdCgwLCB0ZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGhpcy5uZXh0LmRvbU5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRleHROb2RlKSwgdGhpcy5uZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGV4dE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmRhdGEgPSBHVUFSRF9URVhUO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiAobXV0YXRpb24udGFyZ2V0ID09PSBfdGhpczIubGVmdEd1YXJkIHx8IG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLnJpZ2h0R3VhcmQpKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLnJlc3RvcmUobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICBpZiAocmFuZ2UpIGNvbnRleHQucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtYmVkO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRW1iZWQ7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BbGlnblN0eWxlID0gZXhwb3J0cy5BbGlnbkNsYXNzID0gZXhwb3J0cy5BbGlnbkF0dHJpYnV0ZSA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSyxcbiAgd2hpdGVsaXN0OiBbJ3JpZ2h0JywgJ2NlbnRlcicsICdqdXN0aWZ5J11cbn07XG5cbnZhciBBbGlnbkF0dHJpYnV0ZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlKCdhbGlnbicsICdhbGlnbicsIGNvbmZpZyk7XG52YXIgQWxpZ25DbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2FsaWduJywgJ3FsLWFsaWduJywgY29uZmlnKTtcbnZhciBBbGlnblN0eWxlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSgnYWxpZ24nLCAndGV4dC1hbGlnbicsIGNvbmZpZyk7XG5cbmV4cG9ydHMuQWxpZ25BdHRyaWJ1dGUgPSBBbGlnbkF0dHJpYnV0ZTtcbmV4cG9ydHMuQWxpZ25DbGFzcyA9IEFsaWduQ2xhc3M7XG5leHBvcnRzLkFsaWduU3R5bGUgPSBBbGlnblN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFja2dyb3VuZFN0eWxlID0gZXhwb3J0cy5CYWNrZ3JvdW5kQ2xhc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9jb2xvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgQmFja2dyb3VuZENsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnYmFja2dyb3VuZCcsICdxbC1iZycsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcbnZhciBCYWNrZ3JvdW5kU3R5bGUgPSBuZXcgX2NvbG9yLkNvbG9yQXR0cmlidXRvcignYmFja2dyb3VuZCcsICdiYWNrZ3JvdW5kLWNvbG9yJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xuXG5leHBvcnRzLkJhY2tncm91bmRDbGFzcyA9IEJhY2tncm91bmRDbGFzcztcbmV4cG9ydHMuQmFja2dyb3VuZFN0eWxlID0gQmFja2dyb3VuZFN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlyZWN0aW9uU3R5bGUgPSBleHBvcnRzLkRpcmVjdGlvbkNsYXNzID0gZXhwb3J0cy5EaXJlY3Rpb25BdHRyaWJ1dGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNvbmZpZyA9IHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0ssXG4gIHdoaXRlbGlzdDogWydydGwnXVxufTtcblxudmFyIERpcmVjdGlvbkF0dHJpYnV0ZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlKCdkaXJlY3Rpb24nLCAnZGlyJywgY29uZmlnKTtcbnZhciBEaXJlY3Rpb25DbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2RpcmVjdGlvbicsICdxbC1kaXJlY3Rpb24nLCBjb25maWcpO1xudmFyIERpcmVjdGlvblN0eWxlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSgnZGlyZWN0aW9uJywgJ2RpcmVjdGlvbicsIGNvbmZpZyk7XG5cbmV4cG9ydHMuRGlyZWN0aW9uQXR0cmlidXRlID0gRGlyZWN0aW9uQXR0cmlidXRlO1xuZXhwb3J0cy5EaXJlY3Rpb25DbGFzcyA9IERpcmVjdGlvbkNsYXNzO1xuZXhwb3J0cy5EaXJlY3Rpb25TdHlsZSA9IERpcmVjdGlvblN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRm9udENsYXNzID0gZXhwb3J0cy5Gb250U3R5bGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb25maWcgPSB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORSxcbiAgd2hpdGVsaXN0OiBbJ3NlcmlmJywgJ21vbm9zcGFjZSddXG59O1xuXG52YXIgRm9udENsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnZm9udCcsICdxbC1mb250JywgY29uZmlnKTtcblxudmFyIEZvbnRTdHlsZUF0dHJpYnV0b3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhGb250U3R5bGVBdHRyaWJ1dG9yLCBfUGFyY2htZW50JEF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIEZvbnRTdHlsZUF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRTdHlsZUF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb250U3R5bGVBdHRyaWJ1dG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9udFN0eWxlQXR0cmlidXRvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRTdHlsZUF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShub2RlKSB7XG4gICAgICByZXR1cm4gX2dldChGb250U3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvbnRTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ3ZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBub2RlKS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRTdHlsZUF0dHJpYnV0b3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSk7XG5cbnZhciBGb250U3R5bGUgPSBuZXcgRm9udFN0eWxlQXR0cmlidXRvcignZm9udCcsICdmb250LWZhbWlseScsIGNvbmZpZyk7XG5cbmV4cG9ydHMuRm9udFN0eWxlID0gRm9udFN0eWxlO1xuZXhwb3J0cy5Gb250Q2xhc3MgPSBGb250Q2xhc3M7XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TaXplU3R5bGUgPSBleHBvcnRzLlNpemVDbGFzcyA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU2l6ZUNsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnc2l6ZScsICdxbC1zaXplJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWydzbWFsbCcsICdsYXJnZScsICdodWdlJ11cbn0pO1xudmFyIFNpemVTdHlsZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUoJ3NpemUnLCAnZm9udC1zaXplJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWycxMHB4JywgJzE4cHgnLCAnMzJweCddXG59KTtcblxuZXhwb3J0cy5TaXplQ2xhc3MgPSBTaXplQ2xhc3M7XG5leHBvcnRzLlNpemVTdHlsZSA9IFNpemVTdHlsZTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAnYWxpZ24nOiB7XG4gICAgJyc6IF9fd2VicGFja19yZXF1aXJlX18oNzYpLFxuICAgICdjZW50ZXInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KSxcbiAgICAncmlnaHQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSxcbiAgICAnanVzdGlmeSc6IF9fd2VicGFja19yZXF1aXJlX18oNzkpXG4gIH0sXG4gICdiYWNrZ3JvdW5kJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MCksXG4gICdibG9ja3F1b3RlJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MSksXG4gICdib2xkJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MiksXG4gICdjbGVhbic6IF9fd2VicGFja19yZXF1aXJlX18oODMpLFxuICAnY29kZSc6IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICAnY29kZS1ibG9jayc6IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICAnY29sb3InOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KSxcbiAgJ2RpcmVjdGlvbic6IHtcbiAgICAnJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NSksXG4gICAgJ3J0bCc6IF9fd2VicGFja19yZXF1aXJlX18oODYpXG4gIH0sXG4gICdmbG9hdCc6IHtcbiAgICAnY2VudGVyJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NyksXG4gICAgJ2Z1bGwnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KSxcbiAgICAnbGVmdCc6IF9fd2VicGFja19yZXF1aXJlX18oODkpLFxuICAgICdyaWdodCc6IF9fd2VicGFja19yZXF1aXJlX18oOTApXG4gIH0sXG4gICdmb3JtdWxhJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5MSksXG4gICdoZWFkZXInOiB7XG4gICAgJzEnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKSxcbiAgICAnMic6IF9fd2VicGFja19yZXF1aXJlX18oOTMpXG4gIH0sXG4gICdpdGFsaWMnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KSxcbiAgJ2ltYWdlJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NSksXG4gICdpbmRlbnQnOiB7XG4gICAgJysxJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NiksXG4gICAgJy0xJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NylcbiAgfSxcbiAgJ2xpbmsnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KSxcbiAgJ2xpc3QnOiB7XG4gICAgJ29yZGVyZWQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KSxcbiAgICAnYnVsbGV0JzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDApLFxuICAgICdjaGVjayc6IF9fd2VicGFja19yZXF1aXJlX18oMTAxKVxuICB9LFxuICAnc2NyaXB0Jzoge1xuICAgICdzdWInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMiksXG4gICAgJ3N1cGVyJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpXG4gIH0sXG4gICdzdHJpa2UnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCksXG4gICd1bmRlcmxpbmUnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSksXG4gICd2aWRlbyc6IF9fd2VicGFja19yZXF1aXJlX18oMTA2KVxufTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldExhc3RDaGFuZ2VJbmRleCA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhIaXN0b3J5LCBfTW9kdWxlKTtcblxuICBmdW5jdGlvbiBIaXN0b3J5KHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpc3RvcnkpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEhpc3RvcnkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIaXN0b3J5KSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICBfdGhpcy5pZ25vcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICBfdGhpcy5jbGVhcigpO1xuICAgIF90aGlzLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGVsdGEsIG9sZERlbHRhLCBzb3VyY2UpIHtcbiAgICAgIGlmIChldmVudE5hbWUgIT09IF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuVEVYVF9DSEFOR0UgfHwgX3RoaXMuaWdub3JlQ2hhbmdlKSByZXR1cm47XG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMudXNlck9ubHkgfHwgc291cmNlID09PSBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgICAgIF90aGlzLnJlY29yZChkZWx0YSwgb2xkRGVsdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudHJhbnNmb3JtKGRlbHRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnWicsIHNob3J0S2V5OiB0cnVlIH0sIF90aGlzLnVuZG8uYmluZChfdGhpcykpO1xuICAgIF90aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoeyBrZXk6ICdaJywgc2hvcnRLZXk6IHRydWUsIHNoaWZ0S2V5OiB0cnVlIH0sIF90aGlzLnJlZG8uYmluZChfdGhpcykpO1xuICAgIGlmICgvV2luL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG4gICAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnWScsIHNob3J0S2V5OiB0cnVlIH0sIF90aGlzLnJlZG8uYmluZChfdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGlzdG9yeSwgW3tcbiAgICBrZXk6ICdjaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2Uoc291cmNlLCBkZXN0KSB7XG4gICAgICBpZiAodGhpcy5zdGFja1tzb3VyY2VdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5zdGFja1tzb3VyY2VdLnBvcCgpO1xuICAgICAgdGhpcy5zdGFja1tkZXN0XS5wdXNoKGRlbHRhKTtcbiAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICAgIHRoaXMuaWdub3JlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGFbc291cmNlXSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB0aGlzLmlnbm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0TGFzdENoYW5nZUluZGV4KGRlbHRhW3NvdXJjZV0pO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLnN0YWNrID0geyB1bmRvOiBbXSwgcmVkbzogW10gfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjdXRvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXRvZmYoKSB7XG4gICAgICB0aGlzLmxhc3RSZWNvcmRlZCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVjb3JkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkKGNoYW5nZURlbHRhLCBvbGREZWx0YSkge1xuICAgICAgaWYgKGNoYW5nZURlbHRhLm9wcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHRoaXMuc3RhY2sucmVkbyA9IFtdO1xuICAgICAgdmFyIHVuZG9EZWx0YSA9IHRoaXMucXVpbGwuZ2V0Q29udGVudHMoKS5kaWZmKG9sZERlbHRhKTtcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHRoaXMubGFzdFJlY29yZGVkICsgdGhpcy5vcHRpb25zLmRlbGF5ID4gdGltZXN0YW1wICYmIHRoaXMuc3RhY2sudW5kby5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHRoaXMuc3RhY2sudW5kby5wb3AoKTtcbiAgICAgICAgdW5kb0RlbHRhID0gdW5kb0RlbHRhLmNvbXBvc2UoZGVsdGEudW5kbyk7XG4gICAgICAgIGNoYW5nZURlbHRhID0gZGVsdGEucmVkby5jb21wb3NlKGNoYW5nZURlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gdGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFjay51bmRvLnB1c2goe1xuICAgICAgICByZWRvOiBjaGFuZ2VEZWx0YSxcbiAgICAgICAgdW5kbzogdW5kb0RlbHRhXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnN0YWNrLnVuZG8ubGVuZ3RoID4gdGhpcy5vcHRpb25zLm1heFN0YWNrKSB7XG4gICAgICAgIHRoaXMuc3RhY2sudW5kby5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgdGhpcy5jaGFuZ2UoJ3JlZG8nLCAndW5kbycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyYW5zZm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybShkZWx0YSkge1xuICAgICAgdGhpcy5zdGFjay51bmRvLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UudW5kbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UudW5kbywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZS5yZWRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS5yZWRvLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGFjay5yZWRvLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UudW5kbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UudW5kbywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZS5yZWRvID0gZGVsdGEudHJhbnNmb3JtKGNoYW5nZS5yZWRvLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VuZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRvKCkge1xuICAgICAgdGhpcy5jaGFuZ2UoJ3VuZG8nLCAncmVkbycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaXN0b3J5O1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuSGlzdG9yeS5ERUZBVUxUUyA9IHtcbiAgZGVsYXk6IDEwMDAsXG4gIG1heFN0YWNrOiAxMDAsXG4gIHVzZXJPbmx5OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gZW5kc1dpdGhOZXdsaW5lQ2hhbmdlKGRlbHRhKSB7XG4gIHZhciBsYXN0T3AgPSBkZWx0YS5vcHNbZGVsdGEub3BzLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdE9wID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGxhc3RPcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgIHJldHVybiB0eXBlb2YgbGFzdE9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgbGFzdE9wLmluc2VydC5lbmRzV2l0aCgnXFxuJyk7XG4gIH1cbiAgaWYgKGxhc3RPcC5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFzdE9wLmF0dHJpYnV0ZXMpLnNvbWUoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGF0dHIsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spICE9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0Q2hhbmdlSW5kZXgoZGVsdGEpIHtcbiAgdmFyIGRlbGV0ZUxlbmd0aCA9IGRlbHRhLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBvcCkge1xuICAgIGxlbmd0aCArPSBvcC5kZWxldGUgfHwgMDtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9LCAwKTtcbiAgdmFyIGNoYW5nZUluZGV4ID0gZGVsdGEubGVuZ3RoKCkgLSBkZWxldGVMZW5ndGg7XG4gIGlmIChlbmRzV2l0aE5ld2xpbmVDaGFuZ2UoZGVsdGEpKSB7XG4gICAgY2hhbmdlSW5kZXggLT0gMTtcbiAgfVxuICByZXR1cm4gY2hhbmdlSW5kZXg7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEhpc3Rvcnk7XG5leHBvcnRzLmdldExhc3RDaGFuZ2VJbmRleCA9IGdldExhc3RDaGFuZ2VJbmRleDtcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkJhc2VUb29sdGlwID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfa2V5Ym9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9rZXlib2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlib2FyZCk7XG5cbnZhciBfdGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyIF90aGVtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVtZSk7XG5cbnZhciBfY29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxudmFyIF9jb2xvclBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvclBpY2tlcik7XG5cbnZhciBfaWNvblBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG52YXIgX2ljb25QaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvblBpY2tlcik7XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbnZhciBfdG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXG52YXIgX3Rvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9vbHRpcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEFMSUdOUyA9IFtmYWxzZSwgJ2NlbnRlcicsICdyaWdodCcsICdqdXN0aWZ5J107XG5cbnZhciBDT0xPUlMgPSBbXCIjMDAwMDAwXCIsIFwiI2U2MDAwMFwiLCBcIiNmZjk5MDBcIiwgXCIjZmZmZjAwXCIsIFwiIzAwOGEwMFwiLCBcIiMwMDY2Y2NcIiwgXCIjOTkzM2ZmXCIsIFwiI2ZmZmZmZlwiLCBcIiNmYWNjY2NcIiwgXCIjZmZlYmNjXCIsIFwiI2ZmZmZjY1wiLCBcIiNjY2U4Y2NcIiwgXCIjY2NlMGY1XCIsIFwiI2ViZDZmZlwiLCBcIiNiYmJiYmJcIiwgXCIjZjA2NjY2XCIsIFwiI2ZmYzI2NlwiLCBcIiNmZmZmNjZcIiwgXCIjNjZiOTY2XCIsIFwiIzY2YTNlMFwiLCBcIiNjMjg1ZmZcIiwgXCIjODg4ODg4XCIsIFwiI2ExMDAwMFwiLCBcIiNiMjZiMDBcIiwgXCIjYjJiMjAwXCIsIFwiIzAwNjEwMFwiLCBcIiMwMDQ3YjJcIiwgXCIjNmIyNGIyXCIsIFwiIzQ0NDQ0NFwiLCBcIiM1YzAwMDBcIiwgXCIjNjYzZDAwXCIsIFwiIzY2NjYwMFwiLCBcIiMwMDM3MDBcIiwgXCIjMDAyOTY2XCIsIFwiIzNkMTQ2NlwiXTtcblxudmFyIEZPTlRTID0gW2ZhbHNlLCAnc2VyaWYnLCAnbW9ub3NwYWNlJ107XG5cbnZhciBIRUFERVJTID0gWycxJywgJzInLCAnMycsIGZhbHNlXTtcblxudmFyIFNJWkVTID0gWydzbWFsbCcsIGZhbHNlLCAnbGFyZ2UnLCAnaHVnZSddO1xuXG52YXIgQmFzZVRoZW1lID0gZnVuY3Rpb24gKF9UaGVtZSkge1xuICBfaW5oZXJpdHMoQmFzZVRoZW1lLCBfVGhlbWUpO1xuXG4gIGZ1bmN0aW9uIEJhc2VUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVGhlbWUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJhc2VUaGVtZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUaGVtZSkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhxdWlsbC5yb290KSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy50b29sdGlwICE9IG51bGwgJiYgIV90aGlzLnRvb2x0aXAucm9vdC5jb250YWlucyhlLnRhcmdldCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gX3RoaXMudG9vbHRpcC50ZXh0Ym94ICYmICFfdGhpcy5xdWlsbC5oYXNGb2N1cygpKSB7XG4gICAgICAgIF90aGlzLnRvb2x0aXAuaGlkZSgpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnBpY2tlcnMgIT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5waWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHBpY2tlcikge1xuICAgICAgICAgIGlmICghcGlja2VyLmNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHBpY2tlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBxdWlsbC5lbWl0dGVyLmxpc3RlbkRPTSgnY2xpY2snLCBkb2N1bWVudC5ib2R5LCBsaXN0ZW5lcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VUaGVtZSwgW3tcbiAgICBrZXk6ICdhZGRNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNb2R1bGUobmFtZSkge1xuICAgICAgdmFyIG1vZHVsZSA9IF9nZXQoQmFzZVRoZW1lLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUaGVtZS5wcm90b3R5cGUpLCAnYWRkTW9kdWxlJywgdGhpcykuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIGlmIChuYW1lID09PSAndG9vbGJhcicpIHtcbiAgICAgICAgdGhpcy5leHRlbmRUb29sYmFyKG1vZHVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkQnV0dG9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkQnV0dG9ucyhidXR0b25zLCBpY29ucykge1xuICAgICAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgncWwtJykpIHJldHVybjtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgncWwtJy5sZW5ndGgpO1xuICAgICAgICAgIGlmIChpY29uc1tuYW1lXSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbnNbbmFtZV1bJyddICsgaWNvbnNbbmFtZV1bJ3J0bCddO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGljb25zW25hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb25zW25hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBidXR0b24udmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpY29uc1tuYW1lXVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb25zW25hbWVdW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRQaWNrZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRQaWNrZXJzKHNlbGVjdHMsIGljb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5waWNrZXJzID0gc2VsZWN0cy5tYXAoZnVuY3Rpb24gKHNlbGVjdCkge1xuICAgICAgICBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYWxpZ24nKSkge1xuICAgICAgICAgIGlmIChzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEFMSUdOUyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX2ljb25QaWNrZXIyLmRlZmF1bHQoc2VsZWN0LCBpY29ucy5hbGlnbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYmFja2dyb3VuZCcpIHx8IHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWNvbG9yJykpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtYmFja2dyb3VuZCcpID8gJ2JhY2tncm91bmQnIDogJ2NvbG9yJztcbiAgICAgICAgICBpZiAoc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbicpID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGxTZWxlY3Qoc2VsZWN0LCBDT0xPUlMsIGZvcm1hdCA9PT0gJ2JhY2tncm91bmQnID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBfY29sb3JQaWNrZXIyLmRlZmF1bHQoc2VsZWN0LCBpY29uc1tmb3JtYXRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbicpID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1mb250JykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEZPTlRTKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtaGVhZGVyJykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIEhFQURFUlMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1zaXplJykpIHtcbiAgICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIFNJWkVTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBfcGlja2VyMi5kZWZhdWx0KHNlbGVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgX3RoaXMyLnBpY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAocGlja2VyKSB7XG4gICAgICAgICAgcGlja2VyLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5FRElUT1JfQ0hBTkdFLCB1cGRhdGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVGhlbWU7XG59KF90aGVtZTIuZGVmYXVsdCk7XG5cbkJhc2VUaGVtZS5ERUZBVUxUUyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgX3RoZW1lMi5kZWZhdWx0LkRFRkFVTFRTLCB7XG4gIG1vZHVsZXM6IHtcbiAgICB0b29sYmFyOiB7XG4gICAgICBoYW5kbGVyczoge1xuICAgICAgICBmb3JtdWxhOiBmdW5jdGlvbiBmb3JtdWxhKCkge1xuICAgICAgICAgIHRoaXMucXVpbGwudGhlbWUudG9vbHRpcC5lZGl0KCdmb3JtdWxhJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiBmdW5jdGlvbiBpbWFnZSgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIHZhciBmaWxlSW5wdXQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dC5xbC1pbWFnZVt0eXBlPWZpbGVdJyk7XG4gICAgICAgICAgaWYgKGZpbGVJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgZmlsZUlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdmaWxlJyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCAnaW1hZ2UvcG5nLCBpbWFnZS9naWYsIGltYWdlL2pwZWcsIGltYWdlL2JtcCwgaW1hZ2UveC1pY29uJyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuY2xhc3NMaXN0LmFkZCgncWwtaW1hZ2UnKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChmaWxlSW5wdXQuZmlsZXMgIT0gbnVsbCAmJiBmaWxlSW5wdXQuZmlsZXNbMF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMzLnF1aWxsLmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5xdWlsbC51cGRhdGVDb250ZW50cyhuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCh7IGltYWdlOiBlLnRhcmdldC5yZXN1bHQgfSksIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgICAgICBfdGhpczMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICAgICAgICAgICAgZmlsZUlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVJbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZUlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpZGVvOiBmdW5jdGlvbiB2aWRlbygpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXAuZWRpdCgndmlkZW8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBCYXNlVG9vbHRpcCA9IGZ1bmN0aW9uIChfVG9vbHRpcCkge1xuICBfaW5oZXJpdHMoQmFzZVRvb2x0aXAsIF9Ub29sdGlwKTtcblxuICBmdW5jdGlvbiBCYXNlVG9vbHRpcChxdWlsbCwgYm91bmRzQ29udGFpbmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VUb29sdGlwKTtcblxuICAgIHZhciBfdGhpczQgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmFzZVRvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVG9vbHRpcCkpLmNhbGwodGhpcywgcXVpbGwsIGJvdW5kc0NvbnRhaW5lcikpO1xuXG4gICAgX3RoaXM0LnRleHRib3ggPSBfdGhpczQucm9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpO1xuICAgIF90aGlzNC5saXN0ZW4oKTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VUb29sdGlwLCBbe1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRleHRib3guYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX2tleWJvYXJkMi5kZWZhdWx0Lm1hdGNoKGV2ZW50LCAnZW50ZXInKSkge1xuICAgICAgICAgIF90aGlzNS5zYXZlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChfa2V5Ym9hcmQyLmRlZmF1bHQubWF0Y2goZXZlbnQsICdlc2NhcGUnKSkge1xuICAgICAgICAgIF90aGlzNS5jYW5jZWwoKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdCgpIHtcbiAgICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbGluayc7XG4gICAgICB2YXIgcHJldmlldyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWhpZGRlbicpO1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWVkaXRpbmcnKTtcbiAgICAgIGlmIChwcmV2aWV3ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gcHJldmlldztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSAhPT0gdGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJykpIHtcbiAgICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc2l0aW9uKHRoaXMucXVpbGwuZ2V0Qm91bmRzKHRoaXMucXVpbGwuc2VsZWN0aW9uLnNhdmVkUmFuZ2UpKTtcbiAgICAgIHRoaXMudGV4dGJveC5zZWxlY3QoKTtcbiAgICAgIHRoaXMudGV4dGJveC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy50ZXh0Ym94LmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgbW9kZSkgfHwgJycpO1xuICAgICAgdGhpcy5yb290LnNldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJywgbW9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdG9yZUZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZUZvY3VzKCkge1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMucXVpbGwuZm9jdXMoKTtcbiAgICAgIHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dGJveC52YWx1ZTtcbiAgICAgIHN3aXRjaCAodGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJykpIHtcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwucm9vdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rUmFuZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXRUZXh0KHRoaXMubGlua1JhbmdlLCAnbGluaycsIHZhbHVlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5saW5rUmFuZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVGb2N1cygpO1xuICAgICAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIHZhbHVlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWlsbC5yb290LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXh0cmFjdFZpZGVvVXJsKHZhbHVlKTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlICdmb3JtdWxhJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSBicmVhaztcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0RW1iZWQoaW5kZXgsIHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpLCB2YWx1ZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpID09PSAnZm9ybXVsYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWxsLmluc2VydFRleHQoaW5kZXggKyAxLCAnICcsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXggKyAyLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50ZXh0Ym94LnZhbHVlID0gJyc7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVRvb2x0aXA7XG59KF90b29sdGlwMi5kZWZhdWx0KTtcblxuZnVuY3Rpb24gZXh0cmFjdFZpZGVvVXJsKHVybCkge1xuICB2YXIgbWF0Y2ggPSB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Oig/Ond3d3xtKVxcLik/eW91dHViZVxcLmNvbVxcL3dhdGNoLip2PShbYS16QS1aMC05Xy1dKykvKSB8fCB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Oig/Ond3d3xtKVxcLik/eW91dHVcXC5iZVxcLyhbYS16QS1aMC05Xy1dKykvKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIChtYXRjaFsxXSB8fCAnaHR0cHMnKSArICc6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJyArIG1hdGNoWzJdICsgJz9zaG93aW5mbz0wJztcbiAgfVxuICBpZiAobWF0Y2ggPSB1cmwubWF0Y2goL14oPzooaHR0cHM/KTpcXC9cXC8pPyg/Ond3d1xcLik/dmltZW9cXC5jb21cXC8oXFxkKykvKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICByZXR1cm4gKG1hdGNoWzFdIHx8ICdodHRwcycpICsgJzovL3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIG1hdGNoWzJdICsgJy8nO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGZpbGxTZWxlY3Qoc2VsZWN0LCB2YWx1ZXMpIHtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIGlmICh2YWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH0pO1xufVxuXG5leHBvcnRzLkJhc2VUb29sdGlwID0gQmFzZVRvb2x0aXA7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbm9kZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2Rlc1swXSwgbnVsbCk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBub2Rlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICBpZiAoY3VyID09PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChub2RlLCByZWZOb2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZS5uZXh0ID0gcmVmTm9kZTtcbiAgICAgICAgaWYgKHJlZk5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZS5wcmV2O1xuICAgICAgICAgICAgaWYgKHJlZk5vZGUucHJldiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFpbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlLnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgY3VyID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCArPSBjdXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChub2RlLnByZXYgIT0gbnVsbClcbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0ICE9IG51bGwpXG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZClcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbClcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGUucHJldjtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gMTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKGN1ck5vZGUpIHtcbiAgICAgICAgaWYgKGN1ck5vZGUgPT09IHZvaWQgMCkgeyBjdXJOb2RlID0gdGhpcy5oZWFkOyB9XG4gICAgICAgIC8vIFRPRE8gdXNlIHlpZWxkIHdoZW4gd2UgY2FuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gY3VyTm9kZTtcbiAgICAgICAgICAgIGlmIChjdXJOb2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubmV4dDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluY2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGluY2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjdXIsIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGN1ci5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIChpbmNsdXNpdmUgJiYgaW5kZXggPT09IGxlbmd0aCAmJiAoY3VyLm5leHQgPT0gbnVsbCB8fCBjdXIubmV4dC5sZW5ndGgoKSAhPT0gMCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjdXIsIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4IC09IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW251bGwsIDBdO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyLCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGN1cik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmZvckVhY2hBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZmluZChpbmRleCksIHN0YXJ0Tm9kZSA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgdmFyIGN1ciwgY3VySW5kZXggPSBpbmRleCAtIG9mZnNldCwgbmV4dCA9IHRoaXMuaXRlcmF0b3Ioc3RhcnROb2RlKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpICYmIGN1ckluZGV4IDwgaW5kZXggKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJMZW5ndGggPSBjdXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBjdXJJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1ciwgaW5kZXggLSBjdXJJbmRleCwgTWF0aC5taW4obGVuZ3RoLCBjdXJJbmRleCArIGN1ckxlbmd0aCAtIGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXIsIDAsIE1hdGgubWluKGN1ckxlbmd0aCwgaW5kZXggKyBsZW5ndGggLSBjdXJJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VySW5kZXggKz0gY3VyTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXIpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaChjYWxsYmFjayhjdXIpKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1lbW8pIHtcbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExpbmtlZExpc3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250YWluZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBPQlNFUlZFUl9DT05GSUcgPSB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbn07XG52YXIgTUFYX09QVElNSVpFX0lURVJBVElPTlMgPSAxMDA7XG52YXIgU2Nyb2xsQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2Nyb2xsQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxCbG90KG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm9kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2Nyb2xsID0gX3RoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlKG11dGF0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vYnNlcnZlci5vYnNlcnZlKF90aGlzLmRvbU5vZGUsIE9CU0VSVkVSX0NPTkZJRyk7XG4gICAgICAgIF90aGlzLmF0dGFjaCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWxldGVBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb25zID09PSB2b2lkIDApIHsgbXV0YXRpb25zID0gW107IH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAvLyBXZSBtdXN0IG1vZGlmeSBtdXRhdGlvbnMgZGlyZWN0bHksIGNhbm5vdCBtYWtlIGNvcHkgYW5kIHRoZW4gbW9kaWZ5XG4gICAgICAgIHZhciByZWNvcmRzID0gW10uc2xpY2UuY2FsbCh0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICAvLyBBcnJheS5wdXNoIGN1cnJlbnRseSBzZWVtcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIG5vbi10YWlsIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgICAvLyBzbyB3ZSBjYW5ub3QganVzdCBtdXRhdGlvbnMucHVzaC5hcHBseShtdXRhdGlvbnMsIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICAgIHdoaWxlIChyZWNvcmRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICAgICAgLy8gVE9ETyB1c2UgV2Vha01hcFxuICAgICAgICB2YXIgbWFyayA9IGZ1bmN0aW9uIChibG90LCBtYXJrUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobWFya1BhcmVudCA9PT0gdm9pZCAwKSB7IG1hcmtQYXJlbnQgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsIHx8IGJsb3QgPT09IF90aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFya1BhcmVudClcbiAgICAgICAgICAgICAgICBtYXJrKGJsb3QucGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGltaXplID0gZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgICAgIC8vIFBvc3Qtb3JkZXIgdHJhdmVyc2FsXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgY29udGFpbmVyXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaChvcHRpbWl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG90Lm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gbXV0YXRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgcmVtYWluaW5nLmxlbmd0aCA+IDA7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gTUFYX09QVElNSVpFX0lURVJBVElPTlMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tQYXJjaG1lbnRdIE1heGltdW0gb3B0aW1pemUgaXRlcmF0aW9ucyByZWFjaGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1haW5pbmcuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobXV0YXRpb24udGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGJsb3QuZG9tTm9kZSA9PT0gbXV0YXRpb24udGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyayhSZWdpc3RyeS5maW5kKG11dGF0aW9uLnByZXZpb3VzU2libGluZywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChtdXRhdGlvbi5hZGRlZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IFJlZ2lzdHJ5LmZpbmQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoY2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBjb250YWluZXJfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGdyYW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoZ3JhbmRDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoYmxvdC5wcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrKGJsb3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2gob3B0aW1pemUpO1xuICAgICAgICAgICAgcmVtYWluaW5nID0gW10uc2xpY2UuY2FsbCh0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICAgICAgcmVjb3JkcyA9IHJlbWFpbmluZy5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMgfHwgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAvLyBUT0RPIHVzZSBXZWFrTWFwXG4gICAgICAgIG11dGF0aW9uc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBibG90ID0gUmVnaXN0cnkuZmluZChtdXRhdGlvbi50YXJnZXQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID0gW211dGF0aW9uXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChibG90KSB7XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgYmxvdCA9PT0gX3RoaXMgfHxcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYmxvdC51cGRhdGUoYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgfHwgW10sIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpbWl6ZShtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5ibG90TmFtZSA9ICdzY3JvbGwnO1xuICAgIFNjcm9sbEJsb3QuZGVmYXVsdENoaWxkID0gJ2Jsb2NrJztcbiAgICBTY3JvbGxCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuQkxPQ0tfQkxPVDtcbiAgICBTY3JvbGxCbG90LnRhZ05hbWUgPSAnRElWJztcbiAgICByZXR1cm4gU2Nyb2xsQmxvdDtcbn0oY29udGFpbmVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZvcm1hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLy8gU2hhbGxvdyBvYmplY3QgY29tcGFyaXNvblxuZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqMSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChvYmoxW3Byb3BdICE9PSBvYmoyW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBJbmxpbmVCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmxpbmVCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubGluZUJsb3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5saW5lQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gSW5saW5lQmxvdC50YWdOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5mb3JtYXRzLmNhbGwodGhpcywgZG9tTm9kZSk7XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIGZvcm1hdF8xLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQud3JhcChJbmxpbmVCbG90LmJsb3ROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcy5jb3B5KGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51bndyYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRzKClbbmFtZV0gIT0gbnVsbCB8fCBSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEUpKSB7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJsb3QuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZUJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHRoaXMuZm9ybWF0cygpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bndyYXAoKTsgLy8gdW5mb3JtYXR0ZWQgc3BhblxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIElubGluZUJsb3QgJiYgbmV4dC5wcmV2ID09PSB0aGlzICYmIGlzRXF1YWwoZm9ybWF0cywgbmV4dC5mb3JtYXRzKCkpKSB7XG4gICAgICAgICAgICBuZXh0Lm1vdmVDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZUJsb3QuYmxvdE5hbWUgPSAnaW5saW5lJztcbiAgICBJbmxpbmVCbG90LnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuSU5MSU5FX0JMT1Q7XG4gICAgSW5saW5lQmxvdC50YWdOYW1lID0gJ1NQQU4nO1xuICAgIHJldHVybiBJbmxpbmVCbG90O1xufShmb3JtYXRfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbmxpbmVCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZm9ybWF0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQmxvY2tCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja0Jsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJsb2NrQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBSZWdpc3RyeS5xdWVyeShCbG9ja0Jsb3QuYmxvdE5hbWUpLnRhZ05hbWU7XG4gICAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09IHRhZ05hbWUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmZvcm1hdHMuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICB9O1xuICAgIEJsb2NrQmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5CTE9DSykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGgoQmxvY2tCbG90LmJsb3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5CTE9DSykgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICBpZiAoZGVmID09IG51bGwgfHwgUmVnaXN0cnkucXVlcnkodmFsdWUsIFJlZ2lzdHJ5LlNjb3BlLklOTElORSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRleHQgb3IgaW5saW5lXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICAgIGFmdGVyLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QuYmxvdE5hbWUgPSAnYmxvY2snO1xuICAgIEJsb2NrQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLkJMT0NLX0JMT1Q7XG4gICAgQmxvY2tCbG90LnRhZ05hbWUgPSAnUCc7XG4gICAgcmV0dXJuIEJsb2NrQmxvdDtcbn0oZm9ybWF0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGVhZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgRW1iZWRCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbWJlZEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWRCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVtYmVkQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEVtYmVkQmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIHN1cGVyLmZvcm1hdEF0IHdyYXBzLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQgaW4gZ2VuZXJhbCxcbiAgICAgICAgLy8gYnV0IHRoaXMgYWxsb3dzIHN1YmNsYXNzZXMgdG8gb3ZlcndyaXRlIGZvciBmb3JtYXRzXG4gICAgICAgIC8vIHRoYXQganVzdCBhcHBseSB0byBwYXJ0aWN1bGFyIGVtYmVkc1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgMCwgdGhpcy5sZW5ndGgoKSwgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgRW1iZWRCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtYmVkQmxvdDtcbn0obGVhZl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVtYmVkQmxvdDtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxlYWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBUZXh0QmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dEJsb3Qobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50ZXh0ID0gX3RoaXMuc3RhdGljcy52YWx1ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXh0QmxvdC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICB9O1xuICAgIFRleHRCbG90LnZhbHVlID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkb21Ob2RlLmRhdGE7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHRleHRbJ25vcm1hbGl6ZSddKVxuICAgICAgICAgICAgdGV4dCA9IHRleHRbJ25vcm1hbGl6ZSddKCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdGhpcy50ZXh0LnNsaWNlKGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgaWYgKGRlZiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyB0aGlzLnRleHQuc2xpY2UoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGlmICh0aGlzLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCBpbnN0YW5jZW9mIFRleHRCbG90ICYmIHRoaXMubmV4dC5wcmV2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEF0KHRoaXMubGVuZ3RoKCksIHRoaXMubmV4dC52YWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMubmV4dC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmRvbU5vZGUsIGluZGV4XTtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXIgPSBSZWdpc3RyeS5jcmVhdGUodGhpcy5kb21Ob2RlLnNwbGl0VGV4dChpbmRleCkpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYWZ0ZXIsIHRoaXMubmV4dCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMuZG9tTm9kZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5ibG90TmFtZSA9ICd0ZXh0JztcbiAgICBUZXh0QmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLklOTElORV9CTE9UO1xuICAgIHJldHVybiBUZXh0QmxvdDtcbn0obGVhZl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG52YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZWxlbS5jbGFzc0xpc3QudG9nZ2xlKCd0ZXN0LWNsYXNzJywgZmFsc2UpO1xuaWYgKGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0LWNsYXNzJykpIHtcbiAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcbiAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuc3Vic3RyKHBvc2l0aW9uLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xuICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gIH07XG59XG5cbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgXCJmaW5kXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgLy8gRGlzYWJsZSByZXNpemluZyBpbiBGaXJlZm94XG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZW5hYmxlT2JqZWN0UmVzaXppbmdcIiwgZmFsc2UsIGZhbHNlKTtcbiAgLy8gRGlzYWJsZSBhdXRvbWF0aWMgbGlua2lmeWluZyBpbiBJRTExXG4gIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiYXV0b1VybERldGVjdFwiLCBmYWxzZSwgZmFsc2UpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIGxpYnJhcnkgbW9kaWZpZXMgdGhlIGRpZmYtcGF0Y2gtbWF0Y2ggbGlicmFyeSBieSBOZWlsIEZyYXNlclxuICogYnkgcmVtb3ZpbmcgdGhlIHBhdGNoIGFuZCBtYXRjaCBmdW5jdGlvbmFsaXR5IGFuZCBjZXJ0YWluIGFkdmFuY2VkXG4gKiBvcHRpb25zIGluIHRoZSBkaWZmIGZ1bmN0aW9uLiBUaGUgb3JpZ2luYWwgbGljZW5zZSBpcyBhcyBmb2xsb3dzOlxuICpcbiAqID09PVxuICpcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKlxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAqL1xudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge0ludH0gY3Vyc29yX3BvcyBFeHBlY3RlZCBlZGl0IHBvc2l0aW9uIGluIHRleHQxIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgY3Vyc29yX3Bvcykge1xuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICBpZiAodGV4dDEpIHtcbiAgICAgIHJldHVybiBbW0RJRkZfRVFVQUwsIHRleHQxXV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIENoZWNrIGN1cnNvcl9wb3Mgd2l0aGluIGJvdW5kc1xuICBpZiAoY3Vyc29yX3BvcyA8IDAgfHwgdGV4dDEubGVuZ3RoIDwgY3Vyc29yX3Bvcykge1xuICAgIGN1cnNvcl9wb3MgPSBudWxsO1xuICB9XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cCkuXG4gIHZhciBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXG4gIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IGRpZmZfY29tcHV0ZV8odGV4dDEsIHRleHQyKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICB9XG4gIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcbiAgfVxuICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIGlmIChjdXJzb3JfcG9zICE9IG51bGwpIHtcbiAgICBkaWZmcyA9IGZpeF9jdXJzb3IoZGlmZnMsIGN1cnNvcl9wb3MpO1xuICB9XG4gIGRpZmZzID0gZml4X2Vtb2ppKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2NvbXB1dGVfKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgZGlmZnM7XG5cbiAgaWYgKCF0ZXh0MSkge1xuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICBpZiAoIXRleHQyKSB7XG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cblxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IGRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpO1xuICBpZiAoaG0pIHtcbiAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gICAgdmFyIHRleHQxX2EgPSBobVswXTtcbiAgICB2YXIgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdmFyIHRleHQyX2IgPSBobVszXTtcbiAgICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXG4gICAgdmFyIGRpZmZzX2EgPSBkaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSk7XG4gICAgdmFyIGRpZmZzX2IgPSBkaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYik7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSAnbWlkZGxlIHNuYWtlJyBvZiBhIGRpZmYsIHNwbGl0IHRoZSBwcm9ibGVtIGluIHR3b1xuICogYW5kIHJldHVybiB0aGUgcmVjdXJzaXZlbHkgY29uc3RydWN0ZWQgZGlmZi5cbiAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9IDApO1xuICAvLyBPZmZzZXRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGsgbG9vcC5cbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXG4gIHZhciBrMXN0YXJ0ID0gMDtcbiAgdmFyIGsxZW5kID0gMDtcbiAgdmFyIGsyc3RhcnQgPSAwO1xuICB2YXIgazJlbmQgPSAwO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxuICAgIGZvciAodmFyIGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcbiAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGsxO1xuICAgICAgdmFyIHgxO1xuICAgICAgaWYgKGsxID09IC1kIHx8IChrMSAhPSBkICYmIHYxW2sxX29mZnNldCAtIDFdIDwgdjFbazFfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0ICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciB5MSA9IHgxIC0gazE7XG4gICAgICB3aGlsZSAoeDEgPCB0ZXh0MV9sZW5ndGggJiYgeTEgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQoeDEpID09IHRleHQyLmNoYXJBdCh5MSkpIHtcbiAgICAgICAgeDErKztcbiAgICAgICAgeTErKztcbiAgICAgIH1cbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcbiAgICAgIGlmICh4MSA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSByaWdodCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsxZW5kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHkxID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGJvdHRvbSBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT0gLTEpIHtcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICB2YXIgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgIGZvciAodmFyIGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xuICAgICAgdmFyIHgyO1xuICAgICAgaWYgKGsyID09IC1kIHx8IChrMiAhPSBkICYmIHYyW2syX29mZnNldCAtIDFdIDwgdjJbazJfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0ICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciB5MiA9IHgyIC0gazI7XG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geDIgLSAxKSA9PVxuICAgICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpKSB7XG4gICAgICAgIHgyKys7XG4gICAgICAgIHkyKys7XG4gICAgICB9XG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XG4gICAgICBpZiAoeDIgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgbGVmdCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsyZW5kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHkyID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHRvcCBvZiB0aGUgZ3JhcGguXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMV9vZmZzZXQgPj0gMCAmJiBrMV9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MVtrMV9vZmZzZXRdICE9IC0xKSB7XG4gICAgICAgICAgdmFyIHgxID0gdjFbazFfb2Zmc2V0XTtcbiAgICAgICAgICB2YXIgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXG4gIC8vIG51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xuICogYW5kIHJlY3Vyc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgsIHkpIHtcbiAgdmFyIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcbiAgdmFyIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcbiAgdmFyIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcbiAgdmFyIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTtcblxuICAvLyBDb21wdXRlIGJvdGggZGlmZnMgc2VyaWFsbHkuXG4gIHZhciBkaWZmcyA9IGRpZmZfbWFpbih0ZXh0MWEsIHRleHQyYSk7XG4gIHZhciBkaWZmc2IgPSBkaWZmX21haW4odGV4dDFiLCB0ZXh0MmIpO1xuXG4gIHJldHVybiBkaWZmcy5jb25jYXQoZGlmZnNiKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcbiAqICAgICBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPSB0ZXh0Mi5jaGFyQXQoMCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyc3RhcnQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcnN0YXJ0ID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gc3VmZml4IG9mIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8XG4gICAgICB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcmVuZCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn1cblxuLyoqXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGxvbmdlciB0ZXh0P1xuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDsgIC8vIFBvaW50bGVzcy5cbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0LlxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBpKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgICB2YXIgaiA9IC0xO1xuICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9IC0xKSB7XG4gICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcbiAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggKiAyID49IGxvbmd0ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgLy8gQ2hlY2sgYWdhaW4gYmFzZWQgb24gdGhlIHRoaXJkIHF1YXJ0ZXIuXG4gIHZhciBobTIgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gIHZhciBobTtcbiAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKCFobTIpIHtcbiAgICBobSA9IGhtMTtcbiAgfSBlbHNlIGlmICghaG0xKSB7XG4gICAgaG0gPSBobTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQm90aCBtYXRjaGVkLiAgU2VsZWN0IHRoZSBsb25nZXN0LlxuICAgIGhtID0gaG0xWzRdLmxlbmd0aCA+IGhtMls0XS5sZW5ndGggPyBobTEgOiBobTI7XG4gIH1cblxuICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gIHZhciB0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iO1xuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHRleHQxX2IgPSBobVsxXTtcbiAgICB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdGV4dDJfYiA9IGhtWzNdO1xuICB9IGVsc2Uge1xuICAgIHRleHQyX2EgPSBobVswXTtcbiAgICB0ZXh0Ml9iID0gaG1bMV07XG4gICAgdGV4dDFfYSA9IGhtWzJdO1xuICAgIHRleHQxX2IgPSBobVszXTtcbiAgfVxuICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xufVxuXG4vKipcbiAqIFJlb3JkZXIgYW5kIG1lcmdlIGxpa2UgZWRpdCBzZWN0aW9ucy4gIE1lcmdlIGVxdWFsaXRpZXMuXG4gKiBBbnkgZWRpdCBzZWN0aW9uIGNhbiBtb3ZlIGFzIGxvbmcgYXMgaXQgZG9lc24ndCBjcm9zcyBhbiBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2NsZWFudXBNZXJnZShkaWZmcykge1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQgPiAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcbiAgICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcbiAgICAgICAgICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn1cblxudmFyIGRpZmYgPSBkaWZmX21haW47XG5kaWZmLklOU0VSVCA9IERJRkZfSU5TRVJUO1xuZGlmZi5ERUxFVEUgPSBESUZGX0RFTEVURTtcbmRpZmYuRVFVQUwgPSBESUZGX0VRVUFMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmY7XG5cbi8qXG4gKiBNb2RpZnkgYSBkaWZmIHN1Y2ggdGhhdCB0aGUgY3Vyc29yIHBvc2l0aW9uIHBvaW50cyB0byB0aGUgc3RhcnQgb2YgYSBjaGFuZ2U6XG4gKiBFLmcuXG4gKiAgIGN1cnNvcl9ub3JtYWxpemVfZGlmZihbW0RJRkZfRVFVQUwsICdhYmMnXV0sIDEpXG4gKiAgICAgPT4gWzEsIFtbRElGRl9FUVVBTCwgJ2EnXSwgW0RJRkZfRVFVQUwsICdiYyddXV1cbiAqICAgY3Vyc29yX25vcm1hbGl6ZV9kaWZmKFtbRElGRl9JTlNFUlQsICduZXcnXSwgW0RJRkZfREVMRVRFLCAneHl6J11dLCAyKVxuICogICAgID0+IFsyLCBbW0RJRkZfSU5TRVJULCAnbmV3J10sIFtESUZGX0RFTEVURSwgJ3h5J10sIFtESUZGX0RFTEVURSwgJ3onXV1dXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7SW50fSBjdXJzb3JfcG9zIFN1Z2dlc3RlZCBlZGl0IHBvc2l0aW9uLiBNdXN0IG5vdCBiZSBvdXQgb2YgYm91bmRzIVxuICogQHJldHVybiB7QXJyYXl9IEEgdHVwbGUgW2N1cnNvciBsb2NhdGlvbiBpbiB0aGUgbW9kaWZpZWQgZGlmZiwgbW9kaWZpZWQgZGlmZl1cbiAqL1xuZnVuY3Rpb24gY3Vyc29yX25vcm1hbGl6ZV9kaWZmIChkaWZmcywgY3Vyc29yX3Bvcykge1xuICBpZiAoY3Vyc29yX3BvcyA9PT0gMCkge1xuICAgIHJldHVybiBbRElGRl9FUVVBTCwgZGlmZnNdO1xuICB9XG4gIGZvciAodmFyIGN1cnJlbnRfcG9zID0gMCwgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkID0gZGlmZnNbaV07XG4gICAgaWYgKGRbMF0gPT09IERJRkZfREVMRVRFIHx8IGRbMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIHZhciBuZXh0X3BvcyA9IGN1cnJlbnRfcG9zICsgZFsxXS5sZW5ndGg7XG4gICAgICBpZiAoY3Vyc29yX3BvcyA9PT0gbmV4dF9wb3MpIHtcbiAgICAgICAgcmV0dXJuIFtpICsgMSwgZGlmZnNdO1xuICAgICAgfSBlbHNlIGlmIChjdXJzb3JfcG9zIDwgbmV4dF9wb3MpIHtcbiAgICAgICAgLy8gY29weSB0byBwcmV2ZW50IHNpZGUgZWZmZWN0c1xuICAgICAgICBkaWZmcyA9IGRpZmZzLnNsaWNlKCk7XG4gICAgICAgIC8vIHNwbGl0IGQgaW50byB0d28gZGlmZiBjaGFuZ2VzXG4gICAgICAgIHZhciBzcGxpdF9wb3MgPSBjdXJzb3JfcG9zIC0gY3VycmVudF9wb3M7XG4gICAgICAgIHZhciBkX2xlZnQgPSBbZFswXSwgZFsxXS5zbGljZSgwLCBzcGxpdF9wb3MpXTtcbiAgICAgICAgdmFyIGRfcmlnaHQgPSBbZFswXSwgZFsxXS5zbGljZShzcGxpdF9wb3MpXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGksIDEsIGRfbGVmdCwgZF9yaWdodCk7XG4gICAgICAgIHJldHVybiBbaSArIDEsIGRpZmZzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRfcG9zID0gbmV4dF9wb3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignY3Vyc29yX3BvcyBpcyBvdXQgb2YgYm91bmRzIScpXG59XG5cbi8qXG4gKiBNb2RpZnkgYSBkaWZmIHN1Y2ggdGhhdCB0aGUgZWRpdCBwb3NpdGlvbiBpcyBcInNoaWZ0ZWRcIiB0byB0aGUgcHJvcG9zZWQgZWRpdCBsb2NhdGlvbiAoY3Vyc29yX3Bvc2l0aW9uKS5cbiAqXG4gKiBDYXNlIDEpXG4gKiAgIENoZWNrIGlmIGEgbmFpdmUgc2hpZnQgaXMgcG9zc2libGU6XG4gKiAgICAgWzAsIFhdLCBbIDEsIFldIC0+IFsgMSwgWV0sIFswLCBYXSAgICAoaWYgWCArIFkgPT09IFkgKyBYKVxuICogICAgIFswLCBYXSwgWy0xLCBZXSAtPiBbLTEsIFldLCBbMCwgWF0gICAgKGlmIFggKyBZID09PSBZICsgWCkgLSBob2xkcyBzYW1lIHJlc3VsdFxuICogQ2FzZSAyKVxuICogICBDaGVjayBpZiB0aGUgZm9sbG93aW5nIHNoaWZ0cyBhcmUgcG9zc2libGU6XG4gKiAgICAgWzAsICdwcmUnXSwgWyAxLCAncHJlZml4J10gLT4gWyAxLCAncHJlJ10sIFswLCAncHJlJ10sIFsgMSwgJ2ZpeCddXG4gKiAgICAgWzAsICdwcmUnXSwgWy0xLCAncHJlZml4J10gLT4gWy0xLCAncHJlJ10sIFswLCAncHJlJ10sIFstMSwgJ2ZpeCddXG4gKiAgICAgICAgIF4gICAgICAgICAgICBeXG4gKiAgICAgICAgIGQgICAgICAgICAgZF9uZXh0XG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7SW50fSBjdXJzb3JfcG9zIFN1Z2dlc3RlZCBlZGl0IHBvc2l0aW9uLiBNdXN0IG5vdCBiZSBvdXQgb2YgYm91bmRzIVxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmZ1bmN0aW9uIGZpeF9jdXJzb3IgKGRpZmZzLCBjdXJzb3JfcG9zKSB7XG4gIHZhciBub3JtID0gY3Vyc29yX25vcm1hbGl6ZV9kaWZmKGRpZmZzLCBjdXJzb3JfcG9zKTtcbiAgdmFyIG5kaWZmcyA9IG5vcm1bMV07XG4gIHZhciBjdXJzb3JfcG9pbnRlciA9IG5vcm1bMF07XG4gIHZhciBkID0gbmRpZmZzW2N1cnNvcl9wb2ludGVyXTtcbiAgdmFyIGRfbmV4dCA9IG5kaWZmc1tjdXJzb3JfcG9pbnRlciArIDFdO1xuXG4gIGlmIChkID09IG51bGwpIHtcbiAgICAvLyBUZXh0IHdhcyBkZWxldGVkIGZyb20gZW5kIG9mIG9yaWdpbmFsIHN0cmluZyxcbiAgICAvLyBjdXJzb3IgaXMgbm93IG91dCBvZiBib3VuZHMgaW4gbmV3IHN0cmluZ1xuICAgIHJldHVybiBkaWZmcztcbiAgfSBlbHNlIGlmIChkWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQSBtb2RpZmljYXRpb24gaGFwcGVuZWQgYXQgdGhlIGN1cnNvciBsb2NhdGlvbi5cbiAgICAvLyBUaGlzIGlzIHRoZSBleHBlY3RlZCBvdXRjb21lLCBzbyB3ZSBjYW4gcmV0dXJuIHRoZSBvcmlnaW5hbCBkaWZmLlxuICAgIHJldHVybiBkaWZmcztcbiAgfSBlbHNlIHtcbiAgICBpZiAoZF9uZXh0ICE9IG51bGwgJiYgZFsxXSArIGRfbmV4dFsxXSA9PT0gZF9uZXh0WzFdICsgZFsxXSkge1xuICAgICAgLy8gQ2FzZSAxKVxuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGVyZm9ybSBhIG5haXZlIHNoaWZ0XG4gICAgICBuZGlmZnMuc3BsaWNlKGN1cnNvcl9wb2ludGVyLCAyLCBkX25leHQsIGQpO1xuICAgICAgcmV0dXJuIG1lcmdlX3R1cGxlcyhuZGlmZnMsIGN1cnNvcl9wb2ludGVyLCAyKVxuICAgIH0gZWxzZSBpZiAoZF9uZXh0ICE9IG51bGwgJiYgZF9uZXh0WzFdLmluZGV4T2YoZFsxXSkgPT09IDApIHtcbiAgICAgIC8vIENhc2UgMilcbiAgICAgIC8vIGRbMV0gaXMgYSBwcmVmaXggb2YgZF9uZXh0WzFdXG4gICAgICAvLyBXZSBjYW4gYXNzdW1lIHRoYXQgZF9uZXh0WzBdICE9PSAwLCBzaW5jZSBkWzBdID09PSAwXG4gICAgICAvLyBTaGlmdCBlZGl0IGxvY2F0aW9ucy4uXG4gICAgICBuZGlmZnMuc3BsaWNlKGN1cnNvcl9wb2ludGVyLCAyLCBbZF9uZXh0WzBdLCBkWzFdXSwgWzAsIGRbMV1dKTtcbiAgICAgIHZhciBzdWZmaXggPSBkX25leHRbMV0uc2xpY2UoZFsxXS5sZW5ndGgpO1xuICAgICAgaWYgKHN1ZmZpeC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5kaWZmcy5zcGxpY2UoY3Vyc29yX3BvaW50ZXIgKyAyLCAwLCBbZF9uZXh0WzBdLCBzdWZmaXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZV90dXBsZXMobmRpZmZzLCBjdXJzb3JfcG9pbnRlciwgMylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYW55IG1vZGlmaWNhdGlvblxuICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogQ2hlY2sgZGlmZiBkaWQgbm90IHNwbGl0IHN1cnJvZ2F0ZSBwYWlycy5cbiAqIEV4LiBbMCwgJ1xcdUQ4M0QnXSwgWy0xLCAnXFx1REMzNiddLCBbMSwgJ1xcdURDMkYnXSAtPiBbLTEsICdcXHVEODNEXFx1REMzNiddLCBbMSwgJ1xcdUQ4M0RcXHVEQzJGJ11cbiAqICAgICAnXFx1RDgzRFxcdURDMzYnID09PSAn8J+QticsICdcXHVEODNEXFx1REMyRicgPT09ICfwn5CvJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZnVuY3Rpb24gZml4X2Vtb2ppIChkaWZmcykge1xuICB2YXIgY29tcGFjdCA9IGZhbHNlO1xuICB2YXIgc3RhcnRzX3dpdGhfcGFpcl9lbmQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoMCkgPj0gMHhEQzAwICYmIHN0ci5jaGFyQ29kZUF0KDApIDw9IDB4REZGRjtcbiAgfTtcbiAgdmFyIGVuZHNfd2l0aF9wYWlyX3N0YXJ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGgtMSkgPj0gMHhEODAwICYmIHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGgtMSkgPD0gMHhEQkZGO1xuICB9O1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGRpZmZzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRpZmZzW2ktMl1bMF0gPT09IERJRkZfRVFVQUwgJiYgZW5kc193aXRoX3BhaXJfc3RhcnQoZGlmZnNbaS0yXVsxXSkgJiZcbiAgICAgICAgZGlmZnNbaS0xXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgc3RhcnRzX3dpdGhfcGFpcl9lbmQoZGlmZnNbaS0xXVsxXSkgJiZcbiAgICAgICAgZGlmZnNbaV1bMF0gPT09IERJRkZfSU5TRVJUICYmIHN0YXJ0c193aXRoX3BhaXJfZW5kKGRpZmZzW2ldWzFdKSkge1xuICAgICAgY29tcGFjdCA9IHRydWU7XG5cbiAgICAgIGRpZmZzW2ktMV1bMV0gPSBkaWZmc1tpLTJdWzFdLnNsaWNlKC0xKSArIGRpZmZzW2ktMV1bMV07XG4gICAgICBkaWZmc1tpXVsxXSA9IGRpZmZzW2ktMl1bMV0uc2xpY2UoLTEpICsgZGlmZnNbaV1bMV07XG5cbiAgICAgIGRpZmZzW2ktMl1bMV0gPSBkaWZmc1tpLTJdWzFdLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgcmV0dXJuIGRpZmZzO1xuICB9XG4gIHZhciBmaXhlZF9kaWZmcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRpZmZzW2ldWzFdLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpeGVkX2RpZmZzLnB1c2goZGlmZnNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZml4ZWRfZGlmZnM7XG59XG5cbi8qXG4gKiBUcnkgdG8gbWVyZ2UgdHVwbGVzIHdpdGggdGhlaXIgbmVpZ2JvcnMgaW4gYSBnaXZlbiByYW5nZS5cbiAqIEUuZy4gWzAsICdhJ10sIFswLCAnYiddIC0+IFswLCAnYWInXVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtJbnR9IHN0YXJ0IFBvc2l0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IHRvIG1lcmdlIChkaWZmc1tzdGFydF0gaXMgYWxzbyBtZXJnZWQgd2l0aCBkaWZmc1tzdGFydCAtIDFdKS5cbiAqIEBwYXJhbSB7SW50fSBsZW5ndGggTnVtYmVyIG9mIGNvbnNlY3V0aXZlIGVsZW1lbnRzIHRvIGNoZWNrLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIG1lcmdlZCBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VfdHVwbGVzIChkaWZmcywgc3RhcnQsIGxlbmd0aCkge1xuICAvLyBDaGVjayBmcm9tIChzdGFydC0xKSB0byAoc3RhcnQrbGVuZ3RoKS5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgbGVuZ3RoIC0gMTsgaSA+PSAwICYmIGkgPj0gc3RhcnQgLSAxOyBpLS0pIHtcbiAgICBpZiAoaSArIDEgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciBsZWZ0X2QgPSBkaWZmc1tpXTtcbiAgICAgIHZhciByaWdodF9kID0gZGlmZnNbaSsxXTtcbiAgICAgIGlmIChsZWZ0X2RbMF0gPT09IHJpZ2h0X2RbMV0pIHtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGksIDIsIFtsZWZ0X2RbMF0sIGxlZnRfZFsxXSArIHJpZ2h0X2RbMV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuXG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn1cblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBPbmx5IGNoZWNrIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7QXJyYXl8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50LCBleGlzdHMpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGF2YWlsYWJsZSA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChleGlzdHMpIHJldHVybiAhIWF2YWlsYWJsZTtcbiAgaWYgKCFhdmFpbGFibGUpIHJldHVybiBbXTtcbiAgaWYgKGF2YWlsYWJsZS5mbikgcmV0dXJuIFthdmFpbGFibGUuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXZhaWxhYmxlLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGF2YWlsYWJsZVtpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcylcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgdGhpcy5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFt0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMsIHRydWUpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIHRoaXMuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgICAgbGlzdGVuZXJzLmZuID09PSBmblxuICAgICAgJiYgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKVxuICAgICAgJiYgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuXG4gICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgYXBwbHkgYW55bW9yZS5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXRjaFRleHQgPSBleHBvcnRzLm1hdGNoU3BhY2luZyA9IGV4cG9ydHMubWF0Y2hOZXdsaW5lID0gZXhwb3J0cy5tYXRjaEJsb3QgPSBleHBvcnRzLm1hdGNoQXR0cmlidXRvciA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXh0ZW5kMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZDIpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbnZhciBfYWxpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxudmFyIF9iYWNrZ3JvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBfY29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2NvZGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZSk7XG5cbnZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIF9kaXJlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxudmFyIF9mb250ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBfc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6Y2xpcGJvYXJkJyk7XG5cbnZhciBET01fS0VZID0gJ19fcWwtbWF0Y2hlcic7XG5cbnZhciBDTElQQk9BUkRfQ09ORklHID0gW1tOb2RlLlRFWFRfTk9ERSwgbWF0Y2hUZXh0XSwgW05vZGUuVEVYVF9OT0RFLCBtYXRjaE5ld2xpbmVdLCBbJ2JyJywgbWF0Y2hCcmVha10sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hOZXdsaW5lXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaEJsb3RdLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoU3BhY2luZ10sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hBdHRyaWJ1dG9yXSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaFN0eWxlc10sIFsnbGknLCBtYXRjaEluZGVudF0sIFsnYicsIG1hdGNoQWxpYXMuYmluZChtYXRjaEFsaWFzLCAnYm9sZCcpXSwgWydpJywgbWF0Y2hBbGlhcy5iaW5kKG1hdGNoQWxpYXMsICdpdGFsaWMnKV0sIFsnc3R5bGUnLCBtYXRjaElnbm9yZV1dO1xuXG52YXIgQVRUUklCVVRFX0FUVFJJQlVUT1JTID0gW19hbGlnbi5BbGlnbkF0dHJpYnV0ZSwgX2RpcmVjdGlvbi5EaXJlY3Rpb25BdHRyaWJ1dGVdLnJlZHVjZShmdW5jdGlvbiAobWVtbywgYXR0cikge1xuICBtZW1vW2F0dHIua2V5TmFtZV0gPSBhdHRyO1xuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcblxudmFyIFNUWUxFX0FUVFJJQlVUT1JTID0gW19hbGlnbi5BbGlnblN0eWxlLCBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kU3R5bGUsIF9jb2xvci5Db2xvclN0eWxlLCBfZGlyZWN0aW9uLkRpcmVjdGlvblN0eWxlLCBfZm9udC5Gb250U3R5bGUsIF9zaXplLlNpemVTdHlsZV0ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBhdHRyKSB7XG4gIG1lbW9bYXR0ci5rZXlOYW1lXSA9IGF0dHI7XG4gIHJldHVybiBtZW1vO1xufSwge30pO1xuXG52YXIgQ2xpcGJvYXJkID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKENsaXBib2FyZCwgX01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gQ2xpcGJvYXJkKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBib2FyZCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2xpcGJvYXJkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xpcGJvYXJkKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIF90aGlzLm9uUGFzdGUuYmluZChfdGhpcykpO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IF90aGlzLnF1aWxsLmFkZENvbnRhaW5lcigncWwtY2xpcGJvYXJkJyk7XG4gICAgX3RoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgX3RoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgX3RoaXMubWF0Y2hlcnMgPSBbXTtcbiAgICBDTElQQk9BUkRfQ09ORklHLmNvbmNhdChfdGhpcy5vcHRpb25zLm1hdGNoZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICBzZWxlY3RvciA9IF9yZWYyWzBdLFxuICAgICAgICAgIG1hdGNoZXIgPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKCFvcHRpb25zLm1hdGNoVmlzdWFsICYmIG1hdGNoZXIgPT09IG1hdGNoU3BhY2luZykgcmV0dXJuO1xuICAgICAgX3RoaXMuYWRkTWF0Y2hlcihzZWxlY3RvciwgbWF0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZCwgW3tcbiAgICBrZXk6ICdhZGRNYXRjaGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWF0Y2hlcihzZWxlY3RvciwgbWF0Y2hlcikge1xuICAgICAgdGhpcy5tYXRjaGVycy5wdXNoKFtzZWxlY3RvciwgbWF0Y2hlcl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbnZlcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0KGh0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlKC9cXD5cXHI/XFxuICtcXDwvZywgJz48Jyk7IC8vIFJlbW92ZSBzcGFjZXMgYmV0d2VlbiB0YWdzXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQodGhpcy5xdWlsbC5zZWxlY3Rpb24uc2F2ZWRSYW5nZS5pbmRleCk7XG4gICAgICBpZiAoZm9ybWF0c1tfY29kZTIuZGVmYXVsdC5ibG90TmFtZV0pIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNvbnRhaW5lci5pbm5lclRleHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgX2NvZGUyLmRlZmF1bHQuYmxvdE5hbWUsIGZvcm1hdHNbX2NvZGUyLmRlZmF1bHQuYmxvdE5hbWVdKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJlcGFyZU1hdGNoaW5nID0gdGhpcy5wcmVwYXJlTWF0Y2hpbmcoKSxcbiAgICAgICAgICBfcHJlcGFyZU1hdGNoaW5nMiA9IF9zbGljZWRUb0FycmF5KF9wcmVwYXJlTWF0Y2hpbmcsIDIpLFxuICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IF9wcmVwYXJlTWF0Y2hpbmcyWzBdLFxuICAgICAgICAgIHRleHRNYXRjaGVycyA9IF9wcmVwYXJlTWF0Y2hpbmcyWzFdO1xuXG4gICAgICB2YXIgZGVsdGEgPSB0cmF2ZXJzZSh0aGlzLmNvbnRhaW5lciwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMpO1xuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgIGlmIChkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykgJiYgZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXS5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgZGVsdGEgPSBkZWx0YS5jb21wb3NlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihkZWx0YS5sZW5ndGgoKSAtIDEpLmRlbGV0ZSgxKSk7XG4gICAgICB9XG4gICAgICBkZWJ1Zy5sb2coJ2NvbnZlcnQnLCB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwsIGRlbHRhKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rhbmdlcm91c2x5UGFzdGVIVE1MJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGFuZ2Vyb3VzbHlQYXN0ZUhUTUwoaW5kZXgsIGh0bWwpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRDb250ZW50cyh0aGlzLmNvbnZlcnQoaW5kZXgpLCBodG1sKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oMCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXN0ZSA9IHRoaXMuY29udmVydChodG1sKTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oaW5kZXgpLmNvbmNhdChwYXN0ZSksIHNvdXJjZSk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4ICsgcGFzdGUubGVuZ3RoKCksIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25QYXN0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGUoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIXRoaXMucXVpbGwuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmZvY3VzKCk7XG4gICAgICB0aGlzLnF1aWxsLnNlbGVjdGlvbi51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWx0YSA9IGRlbHRhLmNvbmNhdChfdGhpczIuY29udmVydCgpKS5kZWxldGUocmFuZ2UubGVuZ3RoKTtcbiAgICAgICAgX3RoaXMyLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgLy8gcmFuZ2UubGVuZ3RoIGNvbnRyaWJ1dGVzIHRvIGRlbHRhLmxlbmd0aCgpXG4gICAgICAgIF90aGlzMi5xdWlsbC5zZXRTZWxlY3Rpb24oZGVsdGEubGVuZ3RoKCkgLSByYW5nZS5sZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIF90aGlzMi5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICBfdGhpczIucXVpbGwuZm9jdXMoKTtcbiAgICAgIH0sIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZXBhcmVNYXRjaGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVNYXRjaGluZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZWxlbWVudE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgdGV4dE1hdGNoZXJzID0gW107XG4gICAgICB0aGlzLm1hdGNoZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIF9wYWlyID0gX3NsaWNlZFRvQXJyYXkocGFpciwgMiksXG4gICAgICAgICAgICBzZWxlY3RvciA9IF9wYWlyWzBdLFxuICAgICAgICAgICAgbWF0Y2hlciA9IF9wYWlyWzFdO1xuXG4gICAgICAgIHN3aXRjaCAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgICAgdGV4dE1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKF90aGlzMy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gdXNlIHdlYWttYXBcbiAgICAgICAgICAgICAgbm9kZVtET01fS0VZXSA9IG5vZGVbRE9NX0tFWV0gfHwgW107XG4gICAgICAgICAgICAgIG5vZGVbRE9NX0tFWV0ucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVyc107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaXBib2FyZDtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbkNsaXBib2FyZC5ERUZBVUxUUyA9IHtcbiAgbWF0Y2hlcnM6IFtdLFxuICBtYXRjaFZpc3VhbDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdCwgdmFsdWUpIHtcbiAgaWYgKCh0eXBlb2YgZm9ybWF0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihmb3JtYXQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybWF0KS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBrZXkpIHtcbiAgICAgIHJldHVybiBhcHBseUZvcm1hdChkZWx0YSwga2V5LCBmb3JtYXRba2V5XSk7XG4gICAgfSwgZGVsdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBvcCkge1xuICAgICAgaWYgKG9wLmF0dHJpYnV0ZXMgJiYgb3AuYXR0cmlidXRlc1tmb3JtYXRdKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5wdXNoKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQob3AuaW5zZXJ0LCAoMCwgX2V4dGVuZDMuZGVmYXVsdCkoe30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZm9ybWF0LCB2YWx1ZSksIG9wLmF0dHJpYnV0ZXMpKTtcbiAgICAgIH1cbiAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm4ge307XG4gIHZhciBET01fS0VZID0gJ19fcWwtY29tcHV0ZWQtc3R5bGUnO1xuICByZXR1cm4gbm9kZVtET01fS0VZXSB8fCAobm9kZVtET01fS0VZXSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpKTtcbn1cblxuZnVuY3Rpb24gZGVsdGFFbmRzV2l0aChkZWx0YSwgdGV4dCkge1xuICB2YXIgZW5kVGV4dCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSBkZWx0YS5vcHMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIGVuZFRleHQubGVuZ3RoIDwgdGV4dC5sZW5ndGg7IC0taSkge1xuICAgIHZhciBvcCA9IGRlbHRhLm9wc1tpXTtcbiAgICBpZiAodHlwZW9mIG9wLmluc2VydCAhPT0gJ3N0cmluZycpIGJyZWFrO1xuICAgIGVuZFRleHQgPSBvcC5pbnNlcnQgKyBlbmRUZXh0O1xuICB9XG4gIHJldHVybiBlbmRUZXh0LnNsaWNlKC0xICogdGV4dC5sZW5ndGgpID09PSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0xpbmUobm9kZSkge1xuICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlOyAvLyBFeGNsdWRlIGVtYmVkIGJsb2Nrc1xuICB2YXIgc3R5bGUgPSBjb21wdXRlU3R5bGUobm9kZSk7XG4gIHJldHVybiBbJ2Jsb2NrJywgJ2xpc3QtaXRlbSddLmluZGV4T2Yoc3R5bGUuZGlzcGxheSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMpIHtcbiAgLy8gUG9zdC1vcmRlclxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5URVhUX05PREUpIHtcbiAgICByZXR1cm4gdGV4dE1hdGNoZXJzLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgIHJldHVybiBtYXRjaGVyKG5vZGUsIGRlbHRhKTtcbiAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gW10ucmVkdWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzIHx8IFtdLCBmdW5jdGlvbiAoZGVsdGEsIGNoaWxkTm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuRGVsdGEgPSB0cmF2ZXJzZShjaGlsZE5vZGUsIGVsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzKTtcbiAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGNoaWxkcmVuRGVsdGEgPSBlbGVtZW50TWF0Y2hlcnMucmVkdWNlKGZ1bmN0aW9uIChjaGlsZHJlbkRlbHRhLCBtYXRjaGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXIoY2hpbGROb2RlLCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgICAgfSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICAgIGNoaWxkcmVuRGVsdGEgPSAoY2hpbGROb2RlW0RPTV9LRVldIHx8IFtdKS5yZWR1Y2UoZnVuY3Rpb24gKGNoaWxkcmVuRGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcihjaGlsZE5vZGUsIGNoaWxkcmVuRGVsdGEpO1xuICAgICAgICB9LCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YS5jb25jYXQoY2hpbGRyZW5EZWx0YSk7XG4gICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaEFsaWFzKGZvcm1hdCwgbm9kZSwgZGVsdGEpIHtcbiAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0dHJpYnV0b3Iobm9kZSwgZGVsdGEpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlLmtleXMobm9kZSk7XG4gIHZhciBjbGFzc2VzID0gX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzLmtleXMobm9kZSk7XG4gIHZhciBzdHlsZXMgPSBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUua2V5cyhub2RlKTtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgYXR0cmlidXRlcy5jb25jYXQoY2xhc3NlcykuY29uY2F0KHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBhdHRyID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkFUVFJJQlVURSk7XG4gICAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0c1thdHRyLmF0dHJOYW1lXSA9IGF0dHIudmFsdWUobm9kZSk7XG4gICAgICBpZiAoZm9ybWF0c1thdHRyLmF0dHJOYW1lXSkgcmV0dXJuO1xuICAgIH1cbiAgICBhdHRyID0gQVRUUklCVVRFX0FUVFJJQlVUT1JTW25hbWVdO1xuICAgIGlmIChhdHRyICE9IG51bGwgJiYgKGF0dHIuYXR0ck5hbWUgPT09IG5hbWUgfHwgYXR0ci5rZXlOYW1lID09PSBuYW1lKSkge1xuICAgICAgZm9ybWF0c1thdHRyLmF0dHJOYW1lXSA9IGF0dHIudmFsdWUobm9kZSkgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhdHRyID0gU1RZTEVfQVRUUklCVVRPUlNbbmFtZV07XG4gICAgaWYgKGF0dHIgIT0gbnVsbCAmJiAoYXR0ci5hdHRyTmFtZSA9PT0gbmFtZSB8fCBhdHRyLmtleU5hbWUgPT09IG5hbWUpKSB7XG4gICAgICBhdHRyID0gU1RZTEVfQVRUUklCVVRPUlNbbmFtZV07XG4gICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICBkZWx0YSA9IGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXRzKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQmxvdChub2RlLCBkZWx0YSkge1xuICB2YXIgbWF0Y2ggPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5vZGUpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIGRlbHRhO1xuICBpZiAobWF0Y2gucHJvdG90eXBlIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkge1xuICAgIHZhciBlbWJlZCA9IHt9O1xuICAgIHZhciB2YWx1ZSA9IG1hdGNoLnZhbHVlKG5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbWJlZFttYXRjaC5ibG90TmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KGVtYmVkLCBtYXRjaC5mb3JtYXRzKG5vZGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoLmZvcm1hdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWx0YSA9IGFwcGx5Rm9ybWF0KGRlbHRhLCBtYXRjaC5ibG90TmFtZSwgbWF0Y2guZm9ybWF0cyhub2RlKSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaEJyZWFrKG5vZGUsIGRlbHRhKSB7XG4gIGlmICghZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSWdub3JlKCkge1xuICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSW5kZW50KG5vZGUsIGRlbHRhKSB7XG4gIHZhciBtYXRjaCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobm9kZSk7XG4gIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmJsb3ROYW1lICE9PSAnbGlzdC1pdGVtJyB8fCAhZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG4gIHZhciBpbmRlbnQgPSAtMSxcbiAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgd2hpbGUgKCFwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1jbGlwYm9hcmQnKSkge1xuICAgIGlmICgoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShwYXJlbnQpIHx8IHt9KS5ibG90TmFtZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBpbmRlbnQgKz0gMTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgaWYgKGluZGVudCA8PSAwKSByZXR1cm4gZGVsdGE7XG4gIHJldHVybiBkZWx0YS5jb21wb3NlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihkZWx0YS5sZW5ndGgoKSAtIDEpLnJldGFpbigxLCB7IGluZGVudDogaW5kZW50IH0pKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hOZXdsaW5lKG5vZGUsIGRlbHRhKSB7XG4gIGlmICghZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgaWYgKGlzTGluZShub2RlKSB8fCBkZWx0YS5sZW5ndGgoKSA+IDAgJiYgbm9kZS5uZXh0U2libGluZyAmJiBpc0xpbmUobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTcGFjaW5nKG5vZGUsIGRlbHRhKSB7XG4gIGlmIChpc0xpbmUobm9kZSkgJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT0gbnVsbCAmJiAhZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcblxcbicpKSB7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoY29tcHV0ZVN0eWxlKG5vZGUpLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVTdHlsZShub2RlKS5tYXJnaW5Cb3R0b20pO1xuICAgIGlmIChub2RlLm5leHRFbGVtZW50U2libGluZy5vZmZzZXRUb3AgPiBub2RlLm9mZnNldFRvcCArIG5vZGVIZWlnaHQgKiAxLjUpIHtcbiAgICAgIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTdHlsZXMobm9kZSwgZGVsdGEpIHtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZSB8fCB7fTtcbiAgaWYgKHN0eWxlLmZvbnRTdHlsZSAmJiBjb21wdXRlU3R5bGUobm9kZSkuZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgIGZvcm1hdHMuaXRhbGljID0gdHJ1ZTtcbiAgfVxuICBpZiAoc3R5bGUuZm9udFdlaWdodCAmJiAoY29tcHV0ZVN0eWxlKG5vZGUpLmZvbnRXZWlnaHQuc3RhcnRzV2l0aCgnYm9sZCcpIHx8IHBhcnNlSW50KGNvbXB1dGVTdHlsZShub2RlKS5mb250V2VpZ2h0KSA+PSA3MDApKSB7XG4gICAgZm9ybWF0cy5ib2xkID0gdHJ1ZTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIGRlbHRhID0gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdHMpO1xuICB9XG4gIGlmIChwYXJzZUZsb2F0KHN0eWxlLnRleHRJbmRlbnQgfHwgMCkgPiAwKSB7XG4gICAgLy8gQ291bGQgYmUgMC41aW5cbiAgICBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCgnXFx0JykuY29uY2F0KGRlbHRhKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoVGV4dChub2RlLCBkZWx0YSkge1xuICB2YXIgdGV4dCA9IG5vZGUuZGF0YTtcbiAgLy8gV29yZCByZXByZXNlbnRzIGVtcHR5IGxpbmUgd2l0aCA8bzpwPiZuYnNwOzwvbzpwPlxuICBpZiAobm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdPOlAnKSB7XG4gICAgcmV0dXJuIGRlbHRhLmluc2VydCh0ZXh0LnRyaW0oKSk7XG4gIH1cbiAgaWYgKHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCAmJiBub2RlLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1jbGlwYm9hcmQnKSkge1xuICAgIHJldHVybiBkZWx0YTtcbiAgfVxuICBpZiAoIWNvbXB1dGVTdHlsZShub2RlLnBhcmVudE5vZGUpLndoaXRlU3BhY2Uuc3RhcnRzV2l0aCgncHJlJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1zdHlsZVxuICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uIHJlcGxhY2VyKGNvbGxhcHNlLCBtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5yZXBsYWNlKC9bXlxcdTAwYTBdL2csICcnKTsgLy8gXFx1MDBhMCBpcyBuYnNwO1xuICAgICAgcmV0dXJuIG1hdGNoLmxlbmd0aCA8IDEgJiYgY29sbGFwc2UgPyAnICcgOiBtYXRjaDtcbiAgICB9O1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnICcpLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc1xccysvZywgcmVwbGFjZXIuYmluZChyZXBsYWNlciwgdHJ1ZSkpOyAvLyBjb2xsYXBzZSB3aGl0ZXNwYWNlXG4gICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09IG51bGwgJiYgaXNMaW5lKG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCAmJiBpc0xpbmUobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxzKy8sIHJlcGxhY2VyLmJpbmQocmVwbGFjZXIsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09IG51bGwgJiYgaXNMaW5lKG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5uZXh0U2libGluZyAhPSBudWxsICYmIGlzTGluZShub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKyQvLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDbGlwYm9hcmQ7XG5leHBvcnRzLm1hdGNoQXR0cmlidXRvciA9IG1hdGNoQXR0cmlidXRvcjtcbmV4cG9ydHMubWF0Y2hCbG90ID0gbWF0Y2hCbG90O1xuZXhwb3J0cy5tYXRjaE5ld2xpbmUgPSBtYXRjaE5ld2xpbmU7XG5leHBvcnRzLm1hdGNoU3BhY2luZyA9IG1hdGNoU3BhY2luZztcbmV4cG9ydHMubWF0Y2hUZXh0ID0gbWF0Y2hUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJvbGQgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoQm9sZCwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gQm9sZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9sZCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvbGQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm9sZCwgW3tcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoQm9sZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICBpZiAodGhpcy5kb21Ob2RlLnRhZ05hbWUgIT09IHRoaXMuc3RhdGljcy50YWdOYW1lWzBdKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZVdpdGgodGhpcy5zdGF0aWNzLmJsb3ROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBfZ2V0KEJvbGQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb2xkKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm9sZDtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cbkJvbGQuYmxvdE5hbWUgPSAnYm9sZCc7XG5Cb2xkLnRhZ05hbWUgPSBbJ1NUUk9ORycsICdCJ107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJvbGQ7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRDb250cm9scyA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDp0b29sYmFyJyk7XG5cbnZhciBUb29sYmFyID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFRvb2xiYXIsIF9Nb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIFRvb2xiYXIocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbGJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVG9vbGJhci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRvb2xiYXIpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5vcHRpb25zLmNvbnRhaW5lcikpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGFkZENvbnRyb2xzKGNvbnRhaW5lciwgX3RoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgcXVpbGwuY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgcXVpbGwuY29udGFpbmVyKTtcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5jb250YWluZXIgPSBfdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKCEoX3RoaXMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB2YXIgX3JldDtcblxuICAgICAgcmV0dXJuIF9yZXQgPSBkZWJ1Zy5lcnJvcignQ29udGFpbmVyIHJlcXVpcmVkIGZvciB0b29sYmFyJywgX3RoaXMub3B0aW9ucyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG4gICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXRvb2xiYXInKTtcbiAgICBfdGhpcy5jb250cm9scyA9IFtdO1xuICAgIF90aGlzLmhhbmRsZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX3RoaXMub3B0aW9ucy5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICBfdGhpcy5hZGRIYW5kbGVyKGZvcm1hdCwgX3RoaXMub3B0aW9ucy5oYW5kbGVyc1tmb3JtYXRdKTtcbiAgICB9KTtcbiAgICBbXS5mb3JFYWNoLmNhbGwoX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbiwgc2VsZWN0JyksIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgX3RoaXMuYXR0YWNoKGlucHV0KTtcbiAgICB9KTtcbiAgICBfdGhpcy5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgaWYgKHR5cGUgPT09IF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSkge1xuICAgICAgICBfdGhpcy51cGRhdGUocmFuZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcXVpbGwkc2VsZWN0aW9uID0gX3RoaXMucXVpbGwuc2VsZWN0aW9uLmdldFJhbmdlKCksXG4gICAgICAgICAgX3RoaXMkcXVpbGwkc2VsZWN0aW9uMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJHNlbGVjdGlvbiwgMSksXG4gICAgICAgICAgcmFuZ2UgPSBfdGhpcyRxdWlsbCRzZWxlY3Rpb24yWzBdOyAvLyBxdWlsbC5nZXRTZWxlY3Rpb24gdHJpZ2dlcnMgdXBkYXRlXG5cblxuICAgICAgX3RoaXMudXBkYXRlKHJhbmdlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbGJhciwgW3tcbiAgICBrZXk6ICdhZGRIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcihmb3JtYXQsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbZm9ybWF0XSA9IGhhbmRsZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdCA9IFtdLmZpbmQuY2FsbChpbnB1dC5jbGFzc0xpc3QsIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdxbC0nKSA9PT0gMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmb3JtYXQpIHJldHVybjtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgncWwtJy5sZW5ndGgpO1xuICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhbmRsZXJzW2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5xdWlsbC5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgdGhpcy5xdWlsbC5zY3JvbGwud2hpdGVsaXN0W2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICAgIGRlYnVnLndhcm4oJ2lnbm9yaW5nIGF0dGFjaGluZyB0byBkaXNhYmxlZCBmb3JtYXQnLCBmb3JtYXQsIGlucHV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoZm9ybWF0KSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVidWcud2FybignaWdub3JpbmcgYXR0YWNoaW5nIHRvIG5vbmV4aXN0ZW50IGZvcm1hdCcsIGZvcm1hdCwgaW5wdXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV2ZW50TmFtZSA9IGlucHV0LnRhZ05hbWUgPT09ICdTRUxFQ1QnID8gJ2NoYW5nZScgOiAnY2xpY2snO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnNlbGVjdGVkSW5kZXggPCAwKSByZXR1cm47XG4gICAgICAgICAgdmFyIHNlbGVjdGVkID0gaW5wdXQub3B0aW9uc1tpbnB1dC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNlbGVjdGVkLnZhbHVlIHx8IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1hY3RpdmUnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC52YWx1ZSB8fCAhaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLnF1aWxsLmZvY3VzKCk7XG5cbiAgICAgICAgdmFyIF9xdWlsbCRzZWxlY3Rpb24kZ2V0UiA9IF90aGlzMi5xdWlsbC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSxcbiAgICAgICAgICAgIF9xdWlsbCRzZWxlY3Rpb24kZ2V0UjIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkc2VsZWN0aW9uJGdldFIsIDEpLFxuICAgICAgICAgICAgcmFuZ2UgPSBfcXVpbGwkc2VsZWN0aW9uJGdldFIyWzBdO1xuXG4gICAgICAgIGlmIChfdGhpczIuaGFuZGxlcnNbZm9ybWF0XSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLmhhbmRsZXJzW2Zvcm1hdF0uY2FsbChfdGhpczIsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGZvcm1hdCkucHJvdG90eXBlIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkge1xuICAgICAgICAgIHZhbHVlID0gcHJvbXB0KCdFbnRlciAnICsgZm9ybWF0KTtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgX3RoaXMyLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuZGVsZXRlKHJhbmdlLmxlbmd0aCkuaW5zZXJ0KF9kZWZpbmVQcm9wZXJ0eSh7fSwgZm9ybWF0LCB2YWx1ZSkpLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIucXVpbGwuZm9ybWF0KGZvcm1hdCwgdmFsdWUsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi51cGRhdGUocmFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBUT0RPIHVzZSB3ZWFrbWFwXG4gICAgICB0aGlzLmNvbnRyb2xzLnB1c2goW2Zvcm1hdCwgaW5wdXRdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocmFuZ2UpIHtcbiAgICAgIHZhciBmb3JtYXRzID0gcmFuZ2UgPT0gbnVsbCA/IHt9IDogdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpO1xuICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpciA9IF9zbGljZWRUb0FycmF5KHBhaXIsIDIpLFxuICAgICAgICAgICAgZm9ybWF0ID0gX3BhaXJbMF0sXG4gICAgICAgICAgICBpbnB1dCA9IF9wYWlyWzFdO1xuXG4gICAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgIHZhciBvcHRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRzW2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uID0gaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3NlbGVjdGVkXScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZm9ybWF0c1tmb3JtYXRdKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0c1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFwiL2csICdcXFxcXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbiA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIicgKyB2YWx1ZSArICdcIl0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnOyAvLyBUT0RPIG1ha2UgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgaW5wdXQuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgncWwtYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIC8vIGJvdGggYmVpbmcgbnVsbCBzaG91bGQgbWF0Y2ggKGRlZmF1bHQgdmFsdWVzKVxuICAgICAgICAgICAgLy8gJzEnIHNob3VsZCBtYXRjaCB3aXRoIDEgKGhlYWRlcnMpXG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSBmb3JtYXRzW2Zvcm1hdF0gPT09IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCBmb3JtYXRzW2Zvcm1hdF0gIT0gbnVsbCAmJiBmb3JtYXRzW2Zvcm1hdF0udG9TdHJpbmcoKSA9PT0gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8IGZvcm1hdHNbZm9ybWF0XSA9PSBudWxsICYmICFpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1hY3RpdmUnLCBpc0FjdGl2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC50b2dnbGUoJ3FsLWFjdGl2ZScsIGZvcm1hdHNbZm9ybWF0XSAhPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb29sYmFyO1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuVG9vbGJhci5ERUZBVUxUUyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRCdXR0b24oY29udGFpbmVyLCBmb3JtYXQsIHZhbHVlKSB7XG4gIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3FsLScgKyBmb3JtYXQpO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gYWRkQ29udHJvbHMoY29udGFpbmVyLCBncm91cHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGdyb3Vwc1swXSkpIHtcbiAgICBncm91cHMgPSBbZ3JvdXBzXTtcbiAgfVxuICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcbiAgICB2YXIgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZ3JvdXAuY2xhc3NMaXN0LmFkZCgncWwtZm9ybWF0cycpO1xuICAgIGNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgIGlmICh0eXBlb2YgY29udHJvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWRkQnV0dG9uKGdyb3VwLCBjb250cm9sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBPYmplY3Qua2V5cyhjb250cm9sKVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbFtmb3JtYXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBhZGRTZWxlY3QoZ3JvdXAsIGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEJ1dHRvbihncm91cCwgZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkU2VsZWN0KGNvbnRhaW5lciwgZm9ybWF0LCB2YWx1ZXMpIHtcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3FsLScgKyBmb3JtYXQpO1xuICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgfVxuICAgIGlucHV0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH0pO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xufVxuXG5Ub29sYmFyLkRFRkFVTFRTID0ge1xuICBjb250YWluZXI6IG51bGwsXG4gIGhhbmRsZXJzOiB7XG4gICAgY2xlYW46IGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIC8vIENsZWFuIGZ1bmN0aW9uYWxpdHkgaW4gZXhpc3RpbmcgYXBwcyBvbmx5IGNsZWFuIGlubGluZSBmb3JtYXRzXG4gICAgICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMy5xdWlsbC5mb3JtYXQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnJlbW92ZUZvcm1hdChyYW5nZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGFsaWduID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQoKVsnYWxpZ24nXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ3J0bCcgJiYgYWxpZ24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnYWxpZ24nLCAncmlnaHQnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdhbGlnbicsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdkaXJlY3Rpb24nLCB2YWx1ZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgfSxcbiAgICBpbmRlbnQ6IGZ1bmN0aW9uIGluZGVudCh2YWx1ZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpO1xuICAgICAgdmFyIGluZGVudCA9IHBhcnNlSW50KGZvcm1hdHMuaW5kZW50IHx8IDApO1xuICAgICAgaWYgKHZhbHVlID09PSAnKzEnIHx8IHZhbHVlID09PSAnLTEnKSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IHZhbHVlID09PSAnKzEnID8gMSA6IC0xO1xuICAgICAgICBpZiAoZm9ybWF0cy5kaXJlY3Rpb24gPT09ICdydGwnKSBtb2RpZmllciAqPSAtMTtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsIGluZGVudCArIG1vZGlmaWVyLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWx1ZSA9IHByb21wdCgnRW50ZXIgbGluayBVUkw6Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICB9LFxuICAgIGxpc3Q6IGZ1bmN0aW9uIGxpc3QodmFsdWUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ2NoZWNrJykge1xuICAgICAgICBpZiAoZm9ybWF0c1snbGlzdCddID09PSAnY2hlY2tlZCcgfHwgZm9ybWF0c1snbGlzdCddID09PSAndW5jaGVja2VkJykge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgJ3VuY2hlY2tlZCcsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XG5leHBvcnRzLmFkZENvbnRyb2xzID0gYWRkQ29udHJvbHM7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1ldmVuIHFsLXN0cm9rZVxcXCIgcG9pbnRzPVxcXCI1IDcgMyA5IDUgMTFcXFwiPjwvcG9seWxpbmU+IDxwb2x5bGluZSBjbGFzcz1cXFwicWwtZXZlbiBxbC1zdHJva2VcXFwiIHBvaW50cz1cXFwiMTMgNyAxNSA5IDEzIDExXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTAgeDI9OCB5MT01IHkyPTEzPjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24gKF9QaWNrZXIpIHtcbiAgX2luaGVyaXRzKENvbG9yUGlja2VyLCBfUGlja2VyKTtcblxuICBmdW5jdGlvbiBDb2xvclBpY2tlcihzZWxlY3QsIGxhYmVsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yUGlja2VyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvclBpY2tlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yUGlja2VyKSkuY2FsbCh0aGlzLCBzZWxlY3QpKTtcblxuICAgIF90aGlzLmxhYmVsLmlubmVySFRNTCA9IGxhYmVsO1xuICAgIF90aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1jb2xvci1waWNrZXInKTtcbiAgICBbXS5zbGljZS5jYWxsKF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcucWwtcGlja2VyLWl0ZW0nKSwgMCwgNykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdxbC1wcmltYXJ5Jyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyLCBbe1xuICAgIGtleTogJ2J1aWxkSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkSXRlbShvcHRpb24pIHtcbiAgICAgIHZhciBpdGVtID0gX2dldChDb2xvclBpY2tlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlci5wcm90b3R5cGUpLCAnYnVpbGRJdGVtJywgdGhpcykuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgaXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcnO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSwgdHJpZ2dlcikge1xuICAgICAgX2dldChDb2xvclBpY2tlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlci5wcm90b3R5cGUpLCAnc2VsZWN0SXRlbScsIHRoaXMpLmNhbGwodGhpcywgaXRlbSwgdHJpZ2dlcik7XG4gICAgICB2YXIgY29sb3JMYWJlbCA9IHRoaXMubGFiZWwucXVlcnlTZWxlY3RvcignLnFsLWNvbG9yLWxhYmVsJyk7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtID8gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB8fCAnJyA6ICcnO1xuICAgICAgaWYgKGNvbG9yTGFiZWwpIHtcbiAgICAgICAgaWYgKGNvbG9yTGFiZWwudGFnTmFtZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgY29sb3JMYWJlbC5zdHlsZS5zdHJva2UgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xvckxhYmVsLnN0eWxlLmZpbGwgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvclBpY2tlcjtcbn0oX3BpY2tlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbG9yUGlja2VyO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX3BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJY29uUGlja2VyID0gZnVuY3Rpb24gKF9QaWNrZXIpIHtcbiAgX2luaGVyaXRzKEljb25QaWNrZXIsIF9QaWNrZXIpO1xuXG4gIGZ1bmN0aW9uIEljb25QaWNrZXIoc2VsZWN0LCBpY29ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uUGlja2VyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJY29uUGlja2VyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWNvblBpY2tlcikpLmNhbGwodGhpcywgc2VsZWN0KSk7XG5cbiAgICBfdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtaWNvbi1waWNrZXInKTtcbiAgICBbXS5mb3JFYWNoLmNhbGwoX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5xbC1waWNrZXItaXRlbScpLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5pbm5lckhUTUwgPSBpY29uc1tpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIHx8ICcnXTtcbiAgICB9KTtcbiAgICBfdGhpcy5kZWZhdWx0SXRlbSA9IF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtc2VsZWN0ZWQnKTtcbiAgICBfdGhpcy5zZWxlY3RJdGVtKF90aGlzLmRlZmF1bHRJdGVtKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSWNvblBpY2tlciwgW3tcbiAgICBrZXk6ICdzZWxlY3RJdGVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0SXRlbShpdGVtLCB0cmlnZ2VyKSB7XG4gICAgICBfZ2V0KEljb25QaWNrZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWNvblBpY2tlci5wcm90b3R5cGUpLCAnc2VsZWN0SXRlbScsIHRoaXMpLmNhbGwodGhpcywgaXRlbSwgdHJpZ2dlcik7XG4gICAgICBpdGVtID0gaXRlbSB8fCB0aGlzLmRlZmF1bHRJdGVtO1xuICAgICAgdGhpcy5sYWJlbC5pbm5lckhUTUwgPSBpdGVtLmlubmVySFRNTDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWNvblBpY2tlcjtcbn0oX3BpY2tlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEljb25QaWNrZXI7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcChxdWlsbCwgYm91bmRzQ29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgIHRoaXMucXVpbGwgPSBxdWlsbDtcbiAgICB0aGlzLmJvdW5kc0NvbnRhaW5lciA9IGJvdW5kc0NvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRoaXMucm9vdCA9IHF1aWxsLmFkZENvbnRhaW5lcigncWwtdG9vbHRpcCcpO1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSB0aGlzLmNvbnN0cnVjdG9yLlRFTVBMQVRFO1xuICAgIGlmICh0aGlzLnF1aWxsLnJvb3QgPT09IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yb290LnN0eWxlLm1hcmdpblRvcCA9IC0xICogX3RoaXMucXVpbGwucm9vdC5zY3JvbGxUb3AgKyAncHgnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtaGlkZGVuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbihyZWZlcmVuY2UpIHtcbiAgICAgIHZhciBsZWZ0ID0gcmVmZXJlbmNlLmxlZnQgKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gdGhpcy5yb290Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgIC8vIHJvb3Quc2Nyb2xsVG9wIHNob3VsZCBiZSAwIGlmIHNjcm9sbENvbnRhaW5lciAhPT0gcm9vdFxuICAgICAgdmFyIHRvcCA9IHJlZmVyZW5jZS5ib3R0b20gKyB0aGlzLnF1aWxsLnJvb3Quc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5yb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgIHRoaXMucm9vdC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWZsaXAnKTtcbiAgICAgIHZhciBjb250YWluZXJCb3VuZHMgPSB0aGlzLmJvdW5kc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByb290Qm91bmRzID0gdGhpcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgIGlmIChyb290Qm91bmRzLnJpZ2h0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0KSB7XG4gICAgICAgIHNoaWZ0ID0gY29udGFpbmVyQm91bmRzLnJpZ2h0IC0gcm9vdEJvdW5kcy5yaWdodDtcbiAgICAgICAgdGhpcy5yb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgc2hpZnQgKyAncHgnO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3RCb3VuZHMubGVmdCA8IGNvbnRhaW5lckJvdW5kcy5sZWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY29udGFpbmVyQm91bmRzLmxlZnQgLSByb290Qm91bmRzLmxlZnQ7XG4gICAgICAgIHRoaXMucm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArIHNoaWZ0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIGlmIChyb290Qm91bmRzLmJvdHRvbSA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b20pIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJvb3RCb3VuZHMuYm90dG9tIC0gcm9vdEJvdW5kcy50b3A7XG4gICAgICAgIHZhciB2ZXJ0aWNhbFNoaWZ0ID0gcmVmZXJlbmNlLmJvdHRvbSAtIHJlZmVyZW5jZS50b3AgKyBoZWlnaHQ7XG4gICAgICAgIHRoaXMucm9vdC5zdHlsZS50b3AgPSB0b3AgLSB2ZXJ0aWNhbFNoaWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWZsaXAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1lZGl0aW5nJyk7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtaGlkZGVuJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2x0aXA7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2x0aXA7XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfbGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX2xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluayk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRPT0xCQVJfQ09ORklHID0gW1t7IGhlYWRlcjogWycxJywgJzInLCAnMycsIGZhbHNlXSB9XSwgWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnbGluayddLCBbeyBsaXN0OiAnb3JkZXJlZCcgfSwgeyBsaXN0OiAnYnVsbGV0JyB9XSwgWydjbGVhbiddXTtcblxudmFyIFNub3dUaGVtZSA9IGZ1bmN0aW9uIChfQmFzZVRoZW1lKSB7XG4gIF9pbmhlcml0cyhTbm93VGhlbWUsIF9CYXNlVGhlbWUpO1xuXG4gIGZ1bmN0aW9uIFNub3dUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbm93VGhlbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kdWxlcy50b29sYmFyICE9IG51bGwgJiYgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9IFRPT0xCQVJfQ09ORklHO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTbm93VGhlbWUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbm93VGhlbWUpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5xdWlsbC5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtc25vdycpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbm93VGhlbWUsIFt7XG4gICAga2V5OiAnZXh0ZW5kVG9vbGJhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFRvb2xiYXIodG9vbGJhcikge1xuICAgICAgdG9vbGJhci5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtc25vdycpO1xuICAgICAgdGhpcy5idWlsZEJ1dHRvbnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgICB0aGlzLmJ1aWxkUGlja2VycyhbXS5zbGljZS5jYWxsKHRvb2xiYXIuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpKSwgX2ljb25zMi5kZWZhdWx0KTtcbiAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTbm93VG9vbHRpcCh0aGlzLnF1aWxsLCB0aGlzLm9wdGlvbnMuYm91bmRzKTtcbiAgICAgIGlmICh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtbGluaycpKSB7XG4gICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7IGtleTogJ0snLCBzaG9ydEtleTogdHJ1ZSB9LCBmdW5jdGlvbiAocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0b29sYmFyLmhhbmRsZXJzWydsaW5rJ10uY2FsbCh0b29sYmFyLCAhY29udGV4dC5mb3JtYXQubGluayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbm93VGhlbWU7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuU25vd1RoZW1lLkRFRkFVTFRTID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBfYmFzZTIuZGVmYXVsdC5ERUZBVUxUUywge1xuICBtb2R1bGVzOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PSBudWxsIHx8IHJhbmdlLmxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJldmlldyA9IHRoaXMucXVpbGwuZ2V0VGV4dChyYW5nZSk7XG4gICAgICAgICAgICBpZiAoL15cXFMrQFxcUytcXC5cXFMrJC8udGVzdChwcmV2aWV3KSAmJiBwcmV2aWV3LmluZGV4T2YoJ21haWx0bzonKSAhPT0gMCkge1xuICAgICAgICAgICAgICBwcmV2aWV3ID0gJ21haWx0bzonICsgcHJldmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b29sdGlwID0gdGhpcy5xdWlsbC50aGVtZS50b29sdGlwO1xuICAgICAgICAgICAgdG9vbHRpcC5lZGl0KCdsaW5rJywgcHJldmlldyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBTbm93VG9vbHRpcCA9IGZ1bmN0aW9uIChfQmFzZVRvb2x0aXApIHtcbiAgX2luaGVyaXRzKFNub3dUb29sdGlwLCBfQmFzZVRvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIFNub3dUb29sdGlwKHF1aWxsLCBib3VuZHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU25vd1Rvb2x0aXApO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTbm93VG9vbHRpcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUb29sdGlwKSkuY2FsbCh0aGlzLCBxdWlsbCwgYm91bmRzKSk7XG5cbiAgICBfdGhpczIucHJldmlldyA9IF90aGlzMi5yb290LnF1ZXJ5U2VsZWN0b3IoJ2EucWwtcHJldmlldycpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU25vd1Rvb2x0aXAsIFt7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIF9nZXQoU25vd1Rvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU25vd1Rvb2x0aXAucHJvdG90eXBlKSwgJ2xpc3RlbicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignYS5xbC1hY3Rpb24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1lZGl0aW5nJykpIHtcbiAgICAgICAgICBfdGhpczMuc2F2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMy5lZGl0KCdsaW5rJywgX3RoaXMzLnByZXZpZXcudGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCdhLnFsLXJlbW92ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczMubGlua1JhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczMubGlua1JhbmdlO1xuICAgICAgICAgIF90aGlzMy5yZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgICBfdGhpczMucXVpbGwuZm9ybWF0VGV4dChyYW5nZSwgJ2xpbmsnLCBmYWxzZSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICBkZWxldGUgX3RoaXMzLmxpbmtSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpczMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFLCBmdW5jdGlvbiAocmFuZ2UsIG9sZFJhbmdlLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUikge1xuICAgICAgICAgIHZhciBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQgPSBfdGhpczMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnQoX2xpbmsyLmRlZmF1bHQsIHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgICAgX3F1aWxsJHNjcm9sbCRkZXNjZW5kMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRzY3JvbGwkZGVzY2VuZCwgMiksXG4gICAgICAgICAgICAgIGxpbmsgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzBdLFxuICAgICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyWzFdO1xuXG4gICAgICAgICAgaWYgKGxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMzLmxpbmtSYW5nZSA9IG5ldyBfc2VsZWN0aW9uLlJhbmdlKHJhbmdlLmluZGV4IC0gb2Zmc2V0LCBsaW5rLmxlbmd0aCgpKTtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3ID0gX2xpbmsyLmRlZmF1bHQuZm9ybWF0cyhsaW5rLmRvbU5vZGUpO1xuICAgICAgICAgICAgX3RoaXMzLnByZXZpZXcudGV4dENvbnRlbnQgPSBwcmV2aWV3O1xuICAgICAgICAgICAgX3RoaXMzLnByZXZpZXcuc2V0QXR0cmlidXRlKCdocmVmJywgcHJldmlldyk7XG4gICAgICAgICAgICBfdGhpczMuc2hvdygpO1xuICAgICAgICAgICAgX3RoaXMzLnBvc2l0aW9uKF90aGlzMy5xdWlsbC5nZXRCb3VuZHMoX3RoaXMzLmxpbmtSYW5nZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXMzLmxpbmtSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBfZ2V0KFNub3dUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUb29sdGlwLnByb3RvdHlwZSksICdzaG93JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbm93VG9vbHRpcDtcbn0oX2Jhc2UuQmFzZVRvb2x0aXApO1xuXG5Tbm93VG9vbHRpcC5URU1QTEFURSA9IFsnPGEgY2xhc3M9XCJxbC1wcmV2aWV3XCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJhYm91dDpibGFua1wiPjwvYT4nLCAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1mb3JtdWxhPVwiZT1tY14yXCIgZGF0YS1saW5rPVwiaHR0cHM6Ly9xdWlsbGpzLmNvbVwiIGRhdGEtdmlkZW89XCJFbWJlZCBVUkxcIj4nLCAnPGEgY2xhc3M9XCJxbC1hY3Rpb25cIj48L2E+JywgJzxhIGNsYXNzPVwicWwtcmVtb3ZlXCI+PC9hPiddLmpvaW4oJycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTbm93VGhlbWU7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FsaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBfZGlyZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfaW5kZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbnZhciBfYmxvY2txdW90ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG52YXIgX2Jsb2NrcXVvdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2txdW90ZSk7XG5cbnZhciBfaGVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cbnZhciBfaGVhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlYWRlcik7XG5cbnZhciBfbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xuXG52YXIgX2xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGlzdCk7XG5cbnZhciBfYmFja2dyb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgX2NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnZhciBfZm9udCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX3NpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxudmFyIF9ib2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbnZhciBfYm9sZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib2xkKTtcblxudmFyIF9pdGFsaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIF9pdGFsaWMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRhbGljKTtcblxudmFyIF9saW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfbGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rKTtcblxudmFyIF9zY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxudmFyIF9zY3JpcHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2NyaXB0KTtcblxudmFyIF9zdHJpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxudmFyIF9zdHJpa2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaWtlKTtcblxudmFyIF91bmRlcmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxudmFyIF91bmRlcmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdW5kZXJsaW5lKTtcblxudmFyIF9pbWFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXG52YXIgX2ltYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ltYWdlKTtcblxudmFyIF92aWRlbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG52YXIgX3ZpZGVvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvKTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxudmFyIF9mb3JtdWxhID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbnZhciBfZm9ybXVsYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtdWxhKTtcblxudmFyIF9zeW50YXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxudmFyIF9zeW50YXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ludGF4KTtcblxudmFyIF90b29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG5cbnZhciBfdG9vbGJhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sYmFyKTtcblxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcblxudmFyIF9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9waWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGlja2VyKTtcblxudmFyIF9jb2xvclBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG52YXIgX2NvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yUGlja2VyKTtcblxudmFyIF9pY29uUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cbnZhciBfaWNvblBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29uUGlja2VyKTtcblxudmFyIF90b29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cbnZhciBfdG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sdGlwKTtcblxudmFyIF9idWJibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5cbnZhciBfYnViYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1YmJsZSk7XG5cbnZhciBfc25vdyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXG52YXIgX3Nub3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc25vdyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9jb3JlMi5kZWZhdWx0LnJlZ2lzdGVyKHtcbiAgJ2F0dHJpYnV0b3JzL2F0dHJpYnV0ZS9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvbkF0dHJpYnV0ZSxcblxuICAnYXR0cmlidXRvcnMvY2xhc3MvYWxpZ24nOiBfYWxpZ24uQWxpZ25DbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2JhY2tncm91bmQnOiBfYmFja2dyb3VuZC5CYWNrZ3JvdW5kQ2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9jb2xvcic6IF9jb2xvci5Db2xvckNsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvZGlyZWN0aW9uJzogX2RpcmVjdGlvbi5EaXJlY3Rpb25DbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2ZvbnQnOiBfZm9udC5Gb250Q2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9zaXplJzogX3NpemUuU2l6ZUNsYXNzLFxuXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9hbGlnbic6IF9hbGlnbi5BbGlnblN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvYmFja2dyb3VuZCc6IF9iYWNrZ3JvdW5kLkJhY2tncm91bmRTdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NvbG9yJzogX2NvbG9yLkNvbG9yU3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvblN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvZm9udCc6IF9mb250LkZvbnRTdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL3NpemUnOiBfc2l6ZS5TaXplU3R5bGVcbn0sIHRydWUpO1xuXG5fY29yZTIuZGVmYXVsdC5yZWdpc3Rlcih7XG4gICdmb3JtYXRzL2FsaWduJzogX2FsaWduLkFsaWduQ2xhc3MsXG4gICdmb3JtYXRzL2RpcmVjdGlvbic6IF9kaXJlY3Rpb24uRGlyZWN0aW9uQ2xhc3MsXG4gICdmb3JtYXRzL2luZGVudCc6IF9pbmRlbnQuSW5kZW50Q2xhc3MsXG5cbiAgJ2Zvcm1hdHMvYmFja2dyb3VuZCc6IF9iYWNrZ3JvdW5kLkJhY2tncm91bmRTdHlsZSxcbiAgJ2Zvcm1hdHMvY29sb3InOiBfY29sb3IuQ29sb3JTdHlsZSxcbiAgJ2Zvcm1hdHMvZm9udCc6IF9mb250LkZvbnRDbGFzcyxcbiAgJ2Zvcm1hdHMvc2l6ZSc6IF9zaXplLlNpemVDbGFzcyxcblxuICAnZm9ybWF0cy9ibG9ja3F1b3RlJzogX2Jsb2NrcXVvdGUyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2NvZGUtYmxvY2snOiBfY29kZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvaGVhZGVyJzogX2hlYWRlcjIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvbGlzdCc6IF9saXN0Mi5kZWZhdWx0LFxuXG4gICdmb3JtYXRzL2JvbGQnOiBfYm9sZDIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvY29kZSc6IF9jb2RlLkNvZGUsXG4gICdmb3JtYXRzL2l0YWxpYyc6IF9pdGFsaWMyLmRlZmF1bHQsXG4gICdmb3JtYXRzL2xpbmsnOiBfbGluazIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvc2NyaXB0JzogX3NjcmlwdDIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvc3RyaWtlJzogX3N0cmlrZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvdW5kZXJsaW5lJzogX3VuZGVybGluZTIuZGVmYXVsdCxcblxuICAnZm9ybWF0cy9pbWFnZSc6IF9pbWFnZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvdmlkZW8nOiBfdmlkZW8yLmRlZmF1bHQsXG5cbiAgJ2Zvcm1hdHMvbGlzdC9pdGVtJzogX2xpc3QuTGlzdEl0ZW0sXG5cbiAgJ21vZHVsZXMvZm9ybXVsYSc6IF9mb3JtdWxhMi5kZWZhdWx0LFxuICAnbW9kdWxlcy9zeW50YXgnOiBfc3ludGF4Mi5kZWZhdWx0LFxuICAnbW9kdWxlcy90b29sYmFyJzogX3Rvb2xiYXIyLmRlZmF1bHQsXG5cbiAgJ3RoZW1lcy9idWJibGUnOiBfYnViYmxlMi5kZWZhdWx0LFxuICAndGhlbWVzL3Nub3cnOiBfc25vdzIuZGVmYXVsdCxcblxuICAndWkvaWNvbnMnOiBfaWNvbnMyLmRlZmF1bHQsXG4gICd1aS9waWNrZXInOiBfcGlja2VyMi5kZWZhdWx0LFxuICAndWkvaWNvbi1waWNrZXInOiBfaWNvblBpY2tlcjIuZGVmYXVsdCxcbiAgJ3VpL2NvbG9yLXBpY2tlcic6IF9jb2xvclBpY2tlcjIuZGVmYXVsdCxcbiAgJ3VpL3Rvb2x0aXAnOiBfdG9vbHRpcDIuZGVmYXVsdFxufSwgdHJ1ZSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuSW5kZW50Q2xhc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJZGVudEF0dHJpYnV0b3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhJZGVudEF0dHJpYnV0b3IsIF9QYXJjaG1lbnQkQXR0cmlidXRvcik7XG5cbiAgZnVuY3Rpb24gSWRlbnRBdHRyaWJ1dG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZGVudEF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJZGVudEF0dHJpYnV0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJZGVudEF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICcrMScgfHwgdmFsdWUgPT09ICctMScpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHRoaXMudmFsdWUobm9kZSkgfHwgMDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJysxJyA/IGluZGVudCArIDEgOiBpbmRlbnQgLSAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KElkZW50QXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ2FkZCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbkFkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkFkZChub2RlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9nZXQoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvci5wcm90b3R5cGUpLCAnY2FuQWRkJywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCB2YWx1ZSkgfHwgX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICdjYW5BZGQnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIHBhcnNlSW50KHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShub2RlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICd2YWx1ZScsIHRoaXMpLmNhbGwodGhpcywgbm9kZSkpIHx8IHVuZGVmaW5lZDsgLy8gRG9uJ3QgcmV0dXJuIE5hTlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJZGVudEF0dHJpYnV0b3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcyk7XG5cbnZhciBJbmRlbnRDbGFzcyA9IG5ldyBJZGVudEF0dHJpYnV0b3IoJ2luZGVudCcsICdxbC1pbmRlbnQnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLLFxuICB3aGl0ZWxpc3Q6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XVxufSk7XG5cbmV4cG9ydHMuSW5kZW50Q2xhc3MgPSBJbmRlbnRDbGFzcztcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQmxvY2txdW90ZSA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKEJsb2NrcXVvdGUsIF9CbG9jayk7XG5cbiAgZnVuY3Rpb24gQmxvY2txdW90ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2txdW90ZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJsb2NrcXVvdGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja3F1b3RlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gQmxvY2txdW90ZTtcbn0oX2Jsb2NrMi5kZWZhdWx0KTtcblxuQmxvY2txdW90ZS5ibG90TmFtZSA9ICdibG9ja3F1b3RlJztcbkJsb2NrcXVvdGUudGFnTmFtZSA9ICdibG9ja3F1b3RlJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2txdW90ZTtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVhZGVyID0gZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoSGVhZGVyLCBfQmxvY2spO1xuXG4gIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSGVhZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGVhZGVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGVhZGVyLCBudWxsLCBbe1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ05hbWUuaW5kZXhPZihkb21Ob2RlLnRhZ05hbWUpICsgMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGVhZGVyO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5IZWFkZXIuYmxvdE5hbWUgPSAnaGVhZGVyJztcbkhlYWRlci50YWdOYW1lID0gWydIMScsICdIMicsICdIMycsICdINCcsICdINScsICdINiddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIZWFkZXI7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5MaXN0SXRlbSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9jb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9jb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGFpbmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTGlzdEl0ZW0gPSBmdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIF9pbmhlcml0cyhMaXN0SXRlbSwgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBMaXN0SXRlbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdEl0ZW0pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaXN0SXRlbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlzdEl0ZW0sIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSA9PT0gTGlzdC5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3Muc2NvcGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoTGlzdEl0ZW0ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0ucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPT0gbnVsbCAmJiB0aGlzLm5leHQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoTGlzdEl0ZW0ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0ucHJvdG90eXBlKSwgJ3JlbW92ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuaXNvbGF0ZSh0aGlzLm9mZnNldCh0aGlzLnBhcmVudCksIHRoaXMubGVuZ3RoKCkpO1xuICAgICAgaWYgKG5hbWUgPT09IHRoaXMucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50LnVud3JhcCgpO1xuICAgICAgICByZXR1cm4gX2dldChMaXN0SXRlbS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbS5wcm90b3R5cGUpLCAncmVwbGFjZVdpdGgnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUgPT09IHRoaXMudGFnTmFtZSA/IHVuZGVmaW5lZCA6IF9nZXQoTGlzdEl0ZW0uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbSksICdmb3JtYXRzJywgdGhpcykuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlzdEl0ZW07XG59KF9ibG9jazIuZGVmYXVsdCk7XG5cbkxpc3RJdGVtLmJsb3ROYW1lID0gJ2xpc3QtaXRlbSc7XG5MaXN0SXRlbS50YWdOYW1lID0gJ0xJJztcblxudmFyIExpc3QgPSBmdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoTGlzdCwgX0NvbnRhaW5lcik7XG5cbiAgX2NyZWF0ZUNsYXNzKExpc3QsIG51bGwsIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHZhbHVlID09PSAnb3JkZXJlZCcgPyAnT0wnIDogJ1VMJztcbiAgICAgIHZhciBub2RlID0gX2dldChMaXN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHRhZ05hbWUpO1xuICAgICAgaWYgKHZhbHVlID09PSAnY2hlY2tlZCcgfHwgdmFsdWUgPT09ICd1bmNoZWNrZWQnKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnLCB2YWx1ZSA9PT0gJ2NoZWNrZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdPTCcpIHJldHVybiAnb3JkZXJlZCc7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnVUwnKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykpIHtcbiAgICAgICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcpID09PSAndHJ1ZScgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ2J1bGxldCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gTGlzdChkb21Ob2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpc3QpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaXN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdCkpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgdmFyIGxpc3RFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiBsaXN0RXZlbnRIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlICE9PSBkb21Ob2RlKSByZXR1cm47XG4gICAgICB2YXIgZm9ybWF0ID0gX3RoaXMyLnN0YXRpY3MuZm9ybWF0cyhkb21Ob2RlKTtcbiAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKGUudGFyZ2V0KTtcbiAgICAgIGlmIChmb3JtYXQgPT09ICdjaGVja2VkJykge1xuICAgICAgICBibG90LmZvcm1hdCgnbGlzdCcsICd1bmNoZWNrZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAndW5jaGVja2VkJykge1xuICAgICAgICBibG90LmZvcm1hdCgnbGlzdCcsICdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RFdmVudEhhbmRsZXIpO1xuICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdEV2ZW50SGFuZGxlcik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaXN0LCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnRhaWwuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIC8vIFdlIGRvbid0IGluaGVyaXQgZnJvbSBGb3JtYXRCbG90XG4gICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEJlZm9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIGlmIChibG90IGluc3RhbmNlb2YgTGlzdEl0ZW0pIHtcbiAgICAgICAgX2dldChMaXN0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QucHJvdG90eXBlKSwgJ2luc2VydEJlZm9yZScsIHRoaXMpLmNhbGwodGhpcywgYmxvdCwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlZiA9PSBudWxsID8gdGhpcy5sZW5ndGgoKSA6IHJlZi5vZmZzZXQodGhpcyk7XG4gICAgICAgIHZhciBhZnRlciA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICBhZnRlci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIGFmdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoTGlzdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0LnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgICAgIGlmIChuZXh0ICE9IG51bGwgJiYgbmV4dC5wcmV2ID09PSB0aGlzICYmIG5leHQuc3RhdGljcy5ibG90TmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIG5leHQuZG9tTm9kZS50YWdOYW1lID09PSB0aGlzLmRvbU5vZGUudGFnTmFtZSAmJiBuZXh0LmRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKSA9PT0gdGhpcy5kb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykpIHtcbiAgICAgICAgbmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0LnN0YXRpY3MuYmxvdE5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSkge1xuICAgICAgICB2YXIgaXRlbSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICB0YXJnZXQubW92ZUNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgX2dldChMaXN0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QucHJvdG90eXBlKSwgJ3JlcGxhY2UnLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpc3Q7XG59KF9jb250YWluZXIyLmRlZmF1bHQpO1xuXG5MaXN0LmJsb3ROYW1lID0gJ2xpc3QnO1xuTGlzdC5zY29wZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQkxPVDtcbkxpc3QudGFnTmFtZSA9IFsnT0wnLCAnVUwnXTtcbkxpc3QuZGVmYXVsdENoaWxkID0gJ2xpc3QtaXRlbSc7XG5MaXN0LmFsbG93ZWRDaGlsZHJlbiA9IFtMaXN0SXRlbV07XG5cbmV4cG9ydHMuTGlzdEl0ZW0gPSBMaXN0SXRlbTtcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3Q7XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2JvbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9ib2xkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JvbGQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJdGFsaWMgPSBmdW5jdGlvbiAoX0JvbGQpIHtcbiAgX2luaGVyaXRzKEl0YWxpYywgX0JvbGQpO1xuXG4gIGZ1bmN0aW9uIEl0YWxpYygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSXRhbGljKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRhbGljLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRhbGljKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gSXRhbGljO1xufShfYm9sZDIuZGVmYXVsdCk7XG5cbkl0YWxpYy5ibG90TmFtZSA9ICdpdGFsaWMnO1xuSXRhbGljLnRhZ05hbWUgPSBbJ0VNJywgJ0knXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSXRhbGljO1xuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNjcmlwdCA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhTY3JpcHQsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFNjcmlwdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NyaXB0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2NyaXB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2NyaXB0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NyaXB0LCBudWxsLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnc3VwZXInKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdzdWInKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdWInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KFNjcmlwdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcmlwdCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnU1VCJykgcmV0dXJuICdzdWInO1xuICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ1NVUCcpIHJldHVybiAnc3VwZXInO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NyaXB0O1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuU2NyaXB0LmJsb3ROYW1lID0gJ3NjcmlwdCc7XG5TY3JpcHQudGFnTmFtZSA9IFsnU1VCJywgJ1NVUCddO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JpcHQ7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFN0cmlrZSA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhTdHJpa2UsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaWtlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaWtlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaWtlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gU3RyaWtlO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuU3RyaWtlLmJsb3ROYW1lID0gJ3N0cmlrZSc7XG5TdHJpa2UudGFnTmFtZSA9ICdTJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyaWtlO1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX2lubGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmxpbmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVbmRlcmxpbmUgPSBmdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoVW5kZXJsaW5lLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBVbmRlcmxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVuZGVybGluZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVuZGVybGluZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuZGVybGluZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIFVuZGVybGluZTtcbn0oX2lubGluZTIuZGVmYXVsdCk7XG5cblVuZGVybGluZS5ibG90TmFtZSA9ICd1bmRlcmxpbmUnO1xuVW5kZXJsaW5lLnRhZ05hbWUgPSAnVSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFVuZGVybGluZTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQVRUUklCVVRFUyA9IFsnYWx0JywgJ2hlaWdodCcsICd3aWR0aCddO1xuXG52YXIgSW1hZ2UgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoSW1hZ2UsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEltYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEltYWdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2UpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZSwgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChBVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KEltYWdlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEltYWdlLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KEltYWdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2UpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5zYW5pdGl6ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIEFUVFJJQlVURVMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBmb3JtYXRzW2F0dHJpYnV0ZV0gPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21hdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godXJsKSB7XG4gICAgICByZXR1cm4gKC9cXC4oanBlP2d8Z2lmfHBuZykkLy50ZXN0KHVybCkgfHwgL15kYXRhOmltYWdlXFwvLis7YmFzZTY0Ly50ZXN0KHVybClcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2FuaXRpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW5pdGl6ZSh1cmwpIHtcbiAgICAgIHJldHVybiAoMCwgX2xpbmsuc2FuaXRpemUpKHVybCwgWydodHRwJywgJ2h0dHBzJywgJ2RhdGEnXSkgPyB1cmwgOiAnLy86MCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZTtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkltYWdlLmJsb3ROYW1lID0gJ2ltYWdlJztcbkltYWdlLnRhZ05hbWUgPSAnSU1HJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIF9saW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmspO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBBVFRSSUJVVEVTID0gWydoZWlnaHQnLCAnd2lkdGgnXTtcblxudmFyIFZpZGVvID0gZnVuY3Rpb24gKF9CbG9ja0VtYmVkKSB7XG4gIF9pbmhlcml0cyhWaWRlbywgX0Jsb2NrRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIFZpZGVvKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlbyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFZpZGVvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlkZW8pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaWRlbywgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChBVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KFZpZGVvLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZpZGVvLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KFZpZGVvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlkZW8pLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAnMCcpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsIHRydWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuc2FuaXRpemUodmFsdWUpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBBVFRSSUJVVEVTLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0cywgYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgZm9ybWF0c1thdHRyaWJ1dGVdID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuIF9saW5rMi5kZWZhdWx0LnNhbml0aXplKHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWRlbztcbn0oX2Jsb2NrLkJsb2NrRW1iZWQpO1xuXG5WaWRlby5ibG90TmFtZSA9ICd2aWRlbyc7XG5WaWRlby5jbGFzc05hbWUgPSAncWwtdmlkZW8nO1xuVmlkZW8udGFnTmFtZSA9ICdJRlJBTUUnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlbztcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkZvcm11bGFCbG90ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZW1iZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxudmFyIF9lbWJlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWJlZCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGb3JtdWxhQmxvdCA9IGZ1bmN0aW9uIChfRW1iZWQpIHtcbiAgX2luaGVyaXRzKEZvcm11bGFCbG90LCBfRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEZvcm11bGFCbG90KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtdWxhQmxvdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvcm11bGFCbG90Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybXVsYUJsb3QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtdWxhQmxvdCwgbnVsbCwgW3tcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChGb3JtdWxhQmxvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm11bGFCbG90KSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2luZG93LmthdGV4LnJlbmRlcih2YWx1ZSwgbm9kZSwge1xuICAgICAgICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgZXJyb3JDb2xvcjogJyNmMDAnXG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm11bGFCbG90O1xufShfZW1iZWQyLmRlZmF1bHQpO1xuXG5Gb3JtdWxhQmxvdC5ibG90TmFtZSA9ICdmb3JtdWxhJztcbkZvcm11bGFCbG90LmNsYXNzTmFtZSA9ICdxbC1mb3JtdWxhJztcbkZvcm11bGFCbG90LnRhZ05hbWUgPSAnU1BBTic7XG5cbnZhciBGb3JtdWxhID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKEZvcm11bGEsIF9Nb2R1bGUpO1xuXG4gIF9jcmVhdGVDbGFzcyhGb3JtdWxhLCBudWxsLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBfcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoRm9ybXVsYUJsb3QsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEZvcm11bGEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm11bGEpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtdWxhLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybXVsYSkpLmNhbGwodGhpcykpO1xuXG4gICAgaWYgKHdpbmRvdy5rYXRleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbW9kdWxlIHJlcXVpcmVzIEthVGVYLicpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIEZvcm11bGE7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLkZvcm11bGFCbG90ID0gRm9ybXVsYUJsb3Q7XG5leHBvcnRzLmRlZmF1bHQgPSBGb3JtdWxhO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQ29kZVRva2VuID0gZXhwb3J0cy5Db2RlQmxvY2sgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxudmFyIF9jb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfY29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2RlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3ludGF4Q29kZUJsb2NrID0gZnVuY3Rpb24gKF9Db2RlQmxvY2spIHtcbiAgX2luaGVyaXRzKFN5bnRheENvZGVCbG9jaywgX0NvZGVCbG9jayk7XG5cbiAgZnVuY3Rpb24gU3ludGF4Q29kZUJsb2NrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXhDb2RlQmxvY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTeW50YXhDb2RlQmxvY2suX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW50YXhDb2RlQmxvY2spKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXhDb2RlQmxvY2ssIFt7XG4gICAga2V5OiAncmVwbGFjZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aChibG9jaykge1xuICAgICAgdGhpcy5kb21Ob2RlLnRleHRDb250ZW50ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICAgIF9nZXQoU3ludGF4Q29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bnRheENvZGVCbG9jay5wcm90b3R5cGUpLCAncmVwbGFjZVdpdGgnLCB0aGlzKS5jYWxsKHRoaXMsIGJsb2NrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWdobGlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHQoX2hpZ2hsaWdodCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBpZiAodGhpcy5jYWNoZWRUZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LnRyaW0oKS5sZW5ndGggPiAwIHx8IHRoaXMuY2FjaGVkVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLmlubmVySFRNTCA9IF9oaWdobGlnaHQodGV4dCk7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRUZXh0ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ludGF4Q29kZUJsb2NrO1xufShfY29kZTIuZGVmYXVsdCk7XG5cblN5bnRheENvZGVCbG9jay5jbGFzc05hbWUgPSAncWwtc3ludGF4JztcblxudmFyIENvZGVUb2tlbiA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ3Rva2VuJywgJ2hsanMnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG5cbnZhciBTeW50YXggPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoU3ludGF4LCBfTW9kdWxlKTtcblxuICBfY3JlYXRlQ2xhc3MoU3ludGF4LCBudWxsLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBfcXVpbGwyLmRlZmF1bHQucmVnaXN0ZXIoQ29kZVRva2VuLCB0cnVlKTtcbiAgICAgIF9xdWlsbDIuZGVmYXVsdC5yZWdpc3RlcihTeW50YXhDb2RlQmxvY2ssIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN5bnRheChxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXgpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTeW50YXguX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW50YXgpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBpZiAodHlwZW9mIF90aGlzMi5vcHRpb25zLmhpZ2hsaWdodCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW50YXggbW9kdWxlIHJlcXVpcmVzIGhpZ2hsaWdodC5qcy4gUGxlYXNlIGluY2x1ZGUgdGhlIGxpYnJhcnkgb24gdGhlIHBhZ2UgYmVmb3JlIFF1aWxsLicpO1xuICAgIH1cbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIF90aGlzMi5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5oaWdobGlnaHQoKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIH0pO1xuICAgIF90aGlzMi5oaWdobGlnaHQoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN5bnRheCwgW3tcbiAgICBrZXk6ICdoaWdobGlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucXVpbGwuc2VsZWN0aW9uLmNvbXBvc2luZykgcmV0dXJuO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy5xdWlsbC5zY3JvbGwuZGVzY2VuZGFudHMoU3ludGF4Q29kZUJsb2NrKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGNvZGUuaGlnaGxpZ2h0KF90aGlzMy5vcHRpb25zLmhpZ2hsaWdodCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ludGF4O1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuU3ludGF4LkRFRkFVTFRTID0ge1xuICBoaWdobGlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LmhsanMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gd2luZG93LmhsanMuaGlnaGxpZ2h0QXV0byh0ZXh0KTtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfTtcbiAgfSgpLFxuICBpbnRlcnZhbDogMTAwMFxufTtcblxuZXhwb3J0cy5Db2RlQmxvY2sgPSBTeW50YXhDb2RlQmxvY2s7XG5leHBvcnRzLkNvZGVUb2tlbiA9IENvZGVUb2tlbjtcbmV4cG9ydHMuZGVmYXVsdCA9IFN5bnRheDtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xMyB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTkgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE0IHgyPTQgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTIgeDI9NiB5MT00IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9NSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj05IHkxPTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGcgY2xhc3M9XFxcInFsLWZpbGwgcWwtY29sb3ItbGFiZWxcXFwiPiA8cG9seWdvbiBwb2ludHM9XFxcIjYgNi44NjggNiA2IDUgNiA1IDcgNS45NDIgNyA2IDYuODY4XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD00IHk9ND48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiNi44MTcgNSA2IDUgNiA2IDYuMzggNiA2LjgxNyA1XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9Nj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0zIHk9NT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD00IHk9Nz48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiNCAxMS40MzkgNCAxMSAzIDExIDMgMTIgMy43NTUgMTIgNCAxMS40MzlcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT0xMj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9OT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9MTU+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjQuNjMgMTAgNCAxMCA0IDExIDQuMTkyIDExIDQuNjMgMTBcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTMgeT04PjwvcmVjdD4gPHBhdGggZD1NMTAuODMyLDQuMkwxMSw0LjU4MlY0SDEwLjcwOEExLjk0OCwxLjk0OCwwLDAsMSwxMC44MzIsNC4yWj48L3BhdGg+IDxwYXRoIGQ9TTcsNC41ODJMNy4xNjgsNC4yQTEuOTI5LDEuOTI5LDAsMCwxLDcuMjkyLDRIN1Y0LjU4Mlo+PC9wYXRoPiA8cGF0aCBkPU04LDEzSDcuNjgzbC0wLjM1MS44YTEuOTMzLDEuOTMzLDAsMCwxLS4xMjQuMkg4VjEzWj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMiB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTEgeT0zPjwvcmVjdD4gPHBhdGggZD1NOSwzSDhWMy4yODJBMS45ODUsMS45ODUsMCwwLDEsOSwzWj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0yIHk9Mz48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD02IHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0zIHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD01IHk9Mz48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD05IHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTE0PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCIxMy40NDcgMTAuMTc0IDEzLjQ2OSAxMC4yMjUgMTMuNDcyIDEwLjIzMiAxMy44MDggMTEgMTQgMTEgMTQgMTAgMTMuMzcgMTAgMTMuNDQ3IDEwLjE3NFxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTMgeT03PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9NT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNCB5PTY+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT04PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9OT48L3JlY3Q+IDxwYXRoIGQ9TTMuNzc1LDE0SDN2MUg0VjE0LjMxNEExLjk3LDEuOTcsMCwwLDEsMy43NzUsMTRaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9Mz48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiMTIgNi44NjggMTIgNiAxMS42MiA2IDEyIDYuODY4XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTI+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTIgeT01PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTEzIHk9ND48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiMTIuOTMzIDkgMTMgOSAxMyA4IDEyLjQ5NSA4IDEyLjkzMyA5XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD05IHk9MTQ+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9OCB5PTE1PjwvcmVjdD4gPHBhdGggZD1NNiwxNC45MjZWMTVIN1YxNC4zMTZBMS45OTMsMS45OTMsMCwwLDEsNiwxNC45MjZaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTUgeT0xNT48L3JlY3Q+IDxwYXRoIGQ9TTEwLjY2OCwxMy44TDEwLjMxNywxM0gxMHYxaDAuNzkyQTEuOTQ3LDEuOTQ3LDAsMCwxLDEwLjY2OCwxMy44Wj48L3BhdGg+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMSB5PTE1PjwvcmVjdD4gPHBhdGggZD1NMTQuMzMyLDEyLjJhMS45OSwxLjk5LDAsMCwxLC4xNjYuOEgxNVYxMkgxNC4yNDVaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9MTU+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT0xMT48L3JlY3Q+IDwvZz4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjUuNSAxMyA5IDUgMTIuNSAxM1xcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExLjYzIHgyPTYuMzggeTE9MTEgeTI9MTE+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cmVjdCBjbGFzcz1cXFwicWwtZmlsbCBxbC1zdHJva2VcXFwiIGhlaWdodD0zIHdpZHRoPTMgeD00IHk9NT48L3JlY3Q+IDxyZWN0IGNsYXNzPVxcXCJxbC1maWxsIHFsLXN0cm9rZVxcXCIgaGVpZ2h0PTMgd2lkdGg9MyB4PTExIHk9NT48L3JlY3Q+IDxwYXRoIGNsYXNzPVxcXCJxbC1ldmVuIHFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBkPU03LDhjMCw0LjAzMS0zLDUtMyw1PjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtZmlsbCBxbC1zdHJva2VcXFwiIGQ9TTE0LDhjMCw0LjAzMS0zLDUtMyw1PjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsNEg5LjVBMi41LDIuNSwwLDAsMSwxMiw2LjV2MEEyLjUsMi41LDAsMCwxLDkuNSw5SDVBMCwwLDAsMCwxLDUsOVY0QTAsMCwwLDAsMSw1LDRaPjwvcGF0aD4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsOWg1LjVBMi41LDIuNSwwLDAsMSwxMywxMS41djBBMi41LDIuNSwwLDAsMSwxMC41LDE0SDVhMCwwLDAsMCwxLDAsMFY5QTAsMCwwLDAsMSw1LDlaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcIlxcXCIgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTUgeDI9MTMgeTE9MyB5Mj0zPjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTYgeDI9OS4zNSB5MT0xMiB5Mj0zPjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExIHgyPTE1IHkxPTExIHkyPTE1PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTExIHkxPTExIHkyPTE1PjwvbGluZT4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSByeD0wLjUgcnk9MC41IHdpZHRoPTcgeD0yIHk9MTQ+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1cXFwicWwtY29sb3ItbGFiZWwgcWwtc3Ryb2tlIHFsLXRyYW5zcGFyZW50XFxcIiB4MT0zIHgyPTE1IHkxPTE1IHkyPTE1PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjUuNSAxMSA5IDMgMTIuNSAxMVxcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTExLjYzIHgyPTYuMzggeTE9OSB5Mj05PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlnb24gY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiBwb2ludHM9XFxcIjMgMTEgNSA5IDMgNyAzIDExXFxcIj48L3BvbHlnb24+IDxsaW5lIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtZmlsbFxcXCIgeDE9MTUgeDI9MTEgeTE9NCB5Mj00PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMSwzYTMsMywwLDAsMCwwLDZoMVYzSDExWj48L3BhdGg+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTExIHdpZHRoPTEgeD0xMSB5PTQ+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9MTMgeT00PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlnb24gY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiBwb2ludHM9XFxcIjE1IDEyIDEzIDEwIDE1IDggMTUgMTJcXFwiPjwvcG9seWdvbj4gPGxpbmUgY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiB4MT05IHgyPTUgeTE9NCB5Mj00PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU01LDNBMywzLDAsMCwwLDUsOUg2VjNINVo+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9NSB5PTQ+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xMSB3aWR0aD0xIHg9NyB5PTQ+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE0LDE2SDRhMSwxLDAsMCwxLDAtMkgxNEExLDEsMCwwLDEsMTQsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTQsNEg0QTEsMSwwLDAsMSw0LDJIMTRBMSwxLDAsMCwxLDE0LDRaIC8+IDxyZWN0IGNsYXNzPXFsLWZpbGwgeD0zIHk9NiB3aWR0aD0xMiBoZWlnaHQ9NiByeD0xIHJ5PTEgLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMywxNkg1YTEsMSwwLDAsMSwwLTJoOEExLDEsMCwwLDEsMTMsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMsNEg1QTEsMSwwLDAsMSw1LDJoOEExLDEsMCwwLDEsMTMsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTIgeT02IHdpZHRoPTE0IGhlaWdodD02IHJ4PTEgcnk9MSAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDhIMTNhMSwxLDAsMCwxLDAtMmgyQTEsMSwwLDAsMSwxNSw4WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDEySDEzYTEsMSwwLDAsMSwwLTJoMkExLDEsMCwwLDEsMTUsMTJaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUsMTZINWExLDEsMCwwLDEsMC0ySDE1QTEsMSwwLDAsMSwxNSwxNlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNSw0SDVBMSwxLDAsMCwxLDUsMkgxNUExLDEsMCwwLDEsMTUsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTIgeT02IHdpZHRoPTggaGVpZ2h0PTYgcng9MSByeT0xIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NNSw4SDNBMSwxLDAsMCwxLDMsNkg1QTEsMSwwLDAsMSw1LDhaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NNSwxMkgzYTEsMSwwLDAsMSwwLTJINUExLDEsMCwwLDEsNSwxMlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMywxNkgzYTEsMSwwLDAsMSwwLTJIMTNBMSwxLDAsMCwxLDEzLDE2WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLDRIM0ExLDEsMCwwLDEsMywySDEzQTEsMSwwLDAsMSwxMyw0WiAvPiA8cmVjdCBjbGFzcz1xbC1maWxsIHg9OCB5PTYgd2lkdGg9OCBoZWlnaHQ9NiByeD0xIHJ5PTEgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjQgMTgpIHJvdGF0ZSgtMTgwKVxcXCIvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTExLjc1OSwyLjQ4MmEyLjU2MSwyLjU2MSwwLDAsMC0zLjUzLjYwN0E3LjY1Niw3LjY1NiwwLDAsMCw2LjgsNi4yQzYuMTA5LDkuMTg4LDUuMjc1LDE0LjY3Nyw0LjE1LDE0LjkyN2ExLjU0NSwxLjU0NSwwLDAsMC0xLjMtLjkzM0EwLjkyMiwwLjkyMiwwLDAsMCwyLDE1LjAzNlMxLjk1NCwxNiw0LjExOSwxNnMzLjA5MS0yLjY5MSwzLjctNS41NTNjMC4xNzctLjgyNi4zNi0xLjcyNiwwLjU1NC0yLjZMOC43NzUsNi4yYzAuMzgxLTEuNDIxLjgwNy0yLjUyMSwxLjMwNi0yLjY3NmExLjAxNCwxLjAxNCwwLDAsMCwxLjAyLjU2QTAuOTY2LDAuOTY2LDAsMCwwLDExLjc1OSwyLjQ4Mlo+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xLjYgcng9MC44IHJ5PTAuOCB3aWR0aD01IHg9NS4xNSB5PTYuMj48L3JlY3Q+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMuNjYzLDEyLjAyN2ExLjY2MiwxLjY2MiwwLDAsMSwuMjY2LTAuMjc2cTAuMTkzLDAuMDY5LjQ1NiwwLjEzOGEyLjEsMi4xLDAsMCwwLC41MzUuMDY5LDEuMDc1LDEuMDc1LDAsMCwwLC43NjctMC4zLDEuMDQ0LDEuMDQ0LDAsMCwwLC4zMTQtMC44LDAuODQsMC44NCwwLDAsMC0uMjM4LTAuNjE5LDAuOCwwLjgsMCwwLDAtLjU5NC0wLjIzOSwxLjE1NCwxLjE1NCwwLDAsMC0uNzgxLjMsNC42MDcsNC42MDcsMCwwLDAtLjc4MSwxcS0wLjA5MS4xNS0uMjE4LDAuMzQ2bC0wLjI0Ni4zOGMtMC4wNjgtLjI4OC0wLjEzNy0wLjU4Mi0wLjIxMi0wLjg4NS0wLjQ1OS0xLjg0Ny0yLjQ5NC0uOTg0LTIuOTQxLTAuOC0wLjQ4Mi4yLS4zNTMsMC42NDctMC4wOTQsMC41MjlhMC44NjksMC44NjksMCwwLDEsMS4yODEuNTg1YzAuMjE3LDAuNzUxLjM3NywxLjQzNiwwLjUyNywyLjAzOGE1LjY4OCw1LjY4OCwwLDAsMS0uMzYyLjQ2NywyLjY5LDIuNjksMCwwLDEtLjI2NC4yNzFxLTAuMjIxLS4wOC0wLjQ3MS0wLjE0N2EyLjAyOSwyLjAyOSwwLDAsMC0uNTIyLTAuMDY2LDEuMDc5LDEuMDc5LDAsMCwwLS43NjguM0ExLjA1OCwxLjA1OCwwLDAsMCw5LDE1LjEzMWEwLjgyLDAuODIsMCwwLDAsLjgzMi44NTIsMS4xMzQsMS4xMzQsMCwwLDAsLjc4Ny0wLjMsNS4xMSw1LjExLDAsMCwwLC43NzYtMC45OTNxMC4xNDEtLjIxOS4yMTUtMC4zNGMwLjA0Ni0uMDc2LjEyMi0wLjE5NCwwLjIyMy0wLjM0NmEyLjc4NiwyLjc4NiwwLDAsMCwuOTE4LDEuNzI2LDIuNTgyLDIuNTgyLDAsMCwwLDIuMzc2LS4xODVjMC4zMTctLjE4MS4yMTItMC41NjUsMC0wLjQ5NEEwLjgwNywwLjgwNywwLDAsMSwxNC4xNzYsMTVhNS4xNTksNS4xNTksMCwwLDEtLjkxMy0yLjQ0NmwwLDBRMTMuNDg3LDEyLjI0LDEzLjY2MywxMi4wMjdaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMCw0VjE0YTEsMSwwLDAsMS0yLDBWMTBIM3Y0YTEsMSwwLDAsMS0yLDBWNEExLDEsMCwwLDEsMyw0VjhIOFY0YTEsMSwwLDAsMSwyLDBabTYuMDY3ODcsOS4yMDlIMTQuOTg5NzVWNy41OTg2M2EuNTQwODUuNTQwODUsMCwwLDAtLjYwNS0uNjA1NDdoLS42Mjc0NGExLjAxMTE5LDEuMDExMTksMCwwLDAtLjc0OC4yOTY4OEwxMS42NDUsOC41NjY0MWEuNTQzNS41NDM1LDAsMCwwLS4wMjIuODU4NGwuMjg2MTMuMzA3NjJhLjUzODYxLjUzODYxLDAsMCwwLC44NDcxNy4wMzMybC4wOTkxMi0uMDg3ODlhMS4yMTM3LDEuMjEzNywwLDAsMCwuMjQxNy0uMzUyNTRoLjAyMjQ2cy0uMDExMjMuMzA4NTktLjAxMTIzLjYwNTQ3VjEzLjIwOUgxMi4wNDFhLjU0MDg1LjU0MDg1LDAsMCwwLS42MDUuNjA1NDd2LjQzOTQ1YS41NDA4NS41NDA4NSwwLDAsMCwuNjA1LjYwNTQ3aDQuMDI2ODZhLjU0MDg1LjU0MDg1LDAsMCwwLC42MDUtLjYwNTQ3di0uNDM5NDVBLjU0MDg1LjU0MDg1LDAsMCwwLDE2LjA2Nzg3LDEzLjIwOVogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNi43Mzk3NSwxMy44MTQ0NXYuNDM5NDVhLjU0MDg1LjU0MDg1LDAsMCwxLS42MDUuNjA1NDdIMTEuODU1YS41ODM5Mi41ODM5MiwwLDAsMS0uNjQ4OTMtLjYwNTQ3VjE0LjAxMjdjMC0yLjkwNTI3LDMuMzk5NDEtMy40MjE4NywzLjM5OTQxLTQuNTU0NjlhLjc3Njc1Ljc3Njc1LDAsMCwwLS44NDcxNy0uNzgxMjUsMS4xNzY4NCwxLjE3Njg0LDAsMCwwLS44MzU5NC4zODQ3N2MtLjI3NDkuMjYzNjctLjU2MS4zNzQtLjg1NzkxLjEzMTg0bC0uNDI5Mi0uMzQwODJjLS4zMDgxMS0uMjQyMTktLjM4NTI1LS41MTc1OC0uMTU0My0uODE0NDVhMi45NzE1NSwyLjk3MTU1LDAsMCwxLDIuNDUzNjEtMS4xNzY3NiwyLjQ1MzkzLDIuNDUzOTMsMCwwLDEsMi42ODQwOCwyLjQwOTE4YzAsMi40NTMxMi0zLjE3OTIsMi45MjY3Ni0zLjI3ODMyLDMuOTM4NDhoMi43OTQ0M0EuNTQwODUuNTQwODUsMCwwLDEsMTYuNzM5NzUsMTMuODE0NDVaTTksM0EuOTk5NzQuOTk5NzQsMCwwLDAsOCw0VjhIM1Y0QTEsMSwwLDAsMCwxLDRWMTRhMSwxLDAsMCwwLDIsMFYxMEg4djRhMSwxLDAsMCwwLDIsMFY0QS45OTk3NC45OTk3NCwwLDAsMCw5LDNaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTEzIHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT01IHgyPTExIHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTggeDI9MTAgeTE9MTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxyZWN0IGNsYXNzPXFsLXN0cm9rZSBoZWlnaHQ9MTAgd2lkdGg9MTIgeD0zIHk9ND48L3JlY3Q+IDxjaXJjbGUgY2xhc3M9cWwtZmlsbCBjeD02IGN5PTcgcj0xPjwvY2lyY2xlPiA8cG9seWxpbmUgY2xhc3M9XFxcInFsLWV2ZW4gcWwtZmlsbFxcXCIgcG9pbnRzPVxcXCI1IDEyIDUgMTEgNyA5IDggMTAgMTEgNyAxMyA5IDEzIDEyIDUgMTJcXFwiPjwvcG9seWxpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1maWxsIHFsLXN0cm9rZVxcXCIgcG9pbnRzPVxcXCIzIDcgMyAxMSA1IDkgMyA3XFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI1IDcgNSAxMSAzIDkgNSA3XFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xMSB5MT03IHkyPTExPjwvbGluZT4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBkPU04LjksNC41NzdhMy40NzYsMy40NzYsMCwwLDEsLjM2LDQuNjc5QTMuNDc2LDMuNDc2LDAsMCwxLDQuNTc3LDguOUMzLjE4NSw3LjUsMi4wMzUsNi40LDQuMjE3LDQuMjE3UzcuNSwzLjE4NSw4LjksNC41NzdaPjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtc3Ryb2tlXFxcIiBkPU0xMy40MjMsOS4xYTMuNDc2LDMuNDc2LDAsMCwwLTQuNjc5LS4zNiwzLjQ3NiwzLjQ3NiwwLDAsMCwuMzYsNC42NzljMS4zOTIsMS4zOTIsMi41LDIuNTQyLDQuNjc5LjM2UzE0LjgxNSwxMC41LDEzLjQyMyw5LjFaPjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIHgxPTIuNSB4Mj00LjUgeTE9NS41IHkyPTUuNT48L2xpbmU+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMy41LDZBMC41LDAuNSwwLDAsMSwzLDUuNVYzLjA4NWwtMC4yNzYuMTM4QTAuNSwwLjUsMCwwLDEsMi4wNTMsM2MtMC4xMjQtLjI0Ny0wLjAyMy0wLjMyNC4yMjQtMC40NDdsMS0uNUEwLjUsMC41LDAsMCwxLDQsMi41djNBMC41LDAuNSwwLDAsMSwzLjUsNlo+PC9wYXRoPiA8cGF0aCBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIGQ9TTQuNSwxMC41aC0yYzAtLjIzNCwxLjg1LTEuMDc2LDEuODUtMi4yMzRBMC45NTksMC45NTksMCwwLDAsMi41LDguMTU2PjwvcGF0aD4gPHBhdGggY2xhc3M9XFxcInFsLXN0cm9rZSBxbC10aGluXFxcIiBkPU0yLjUsMTQuODQ2YTAuOTU5LDAuOTU5LDAsMCwwLDEuODUtLjEwOUEwLjcsMC43LDAsMCwwLDMuNzUsMTRhMC42ODgsMC42ODgsMCwwLDAsLjYtMC43MzYsMC45NTksMC45NTksMCwwLDAtMS44NS0uMTA5PjwvcGF0aD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT02IHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MyB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTMgeTE9MTQgeTI9MTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcIlxcXCIgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjMgNCA0IDUgNiAzXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxwb2x5bGluZSBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCIzIDE0IDQgMTUgNiAxM1xcXCI+PC9wb2x5bGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjMgOSA0IDEwIDYgOFxcXCI+PC9wb2x5bGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUuNSwxNUgxMy44NjFhMy44NTgsMy44NTgsMCwwLDAsMS45MTQtMi45NzUsMS44LDEuOCwwLDAsMC0xLjYtMS43NTFBMS45MjEsMS45MjEsMCwwLDAsMTIuMDIxLDExLjdhMC41MDAxMywwLjUwMDEzLDAsMSwwLC45NTcuMjkxaDBhMC45MTQsMC45MTQsMCwwLDEsMS4wNTMtLjcyNSwwLjgxLDAuODEsMCwwLDEsLjc0NC43NjJjMCwxLjA3Ni0xLjE2OTcxLDEuODY5ODItMS45Mzk3MSwyLjQzMDgyQTEuNDU2MzksMS40NTYzOSwwLDAsMCwxMiwxNS41YTAuNSwwLjUsMCwwLDAsLjUuNWgzQTAuNSwwLjUsMCwwLDAsMTUuNSwxNVogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU05LjY1LDUuMjQxYTEsMSwwLDAsMC0xLjQwOS4xMDhMNiw3Ljk2NCwzLjc1OSw1LjM0OUExLDEsMCwwLDAsMi4xOTIsNi41OTE3OFEyLjIxNTQxLDYuNjIxMywyLjI0MSw2LjY0OUw0LjY4NCw5LjUsMi4yNDEsMTIuMzVBMSwxLDAsMCwwLDMuNzEsMTMuNzA3MjJxMC4wMjU1Ny0uMDI3NjguMDQ5LTAuMDU3MjJMNiwxMS4wMzYsOC4yNDEsMTMuNjVhMSwxLDAsMSwwLDEuNTY3LTEuMjQyNzdROS43ODQ1OSwxMi4zNzc3LDkuNzU5LDEyLjM1TDcuMzE2LDkuNSw5Ljc1OSw2LjY1MUExLDEsMCwwLDAsOS42NSw1LjI0MVogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUuNSw3SDEzLjg2MWE0LjAxNSw0LjAxNSwwLDAsMCwxLjkxNC0yLjk3NSwxLjgsMS44LDAsMCwwLTEuNi0xLjc1MUExLjkyMiwxLjkyMiwwLDAsMCwxMi4wMjEsMy43YTAuNSwwLjUsMCwxLDAsLjk1Ny4yOTEsMC45MTcsMC45MTcsMCwwLDEsMS4wNTMtLjcyNSwwLjgxLDAuODEsMCwwLDEsLjc0NC43NjJjMCwxLjA3Ny0xLjE2NCwxLjkyNS0xLjkzNCwyLjQ4NkExLjQyMywxLjQyMywwLDAsMCwxMiw3LjVhMC41LDAuNSwwLDAsMCwuNS41aDNBMC41LDAuNSwwLDAsMCwxNS41LDdaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NOS42NTEsNS4yNDFhMSwxLDAsMCwwLTEuNDEuMTA4TDYsNy45NjQsMy43NTksNS4zNDlhMSwxLDAsMSwwLTEuNTE5LDEuM0w0LjY4Myw5LjUsMi4yNDEsMTIuMzVhMSwxLDAsMSwwLDEuNTE5LDEuM0w2LDExLjAzNiw4LjI0MSwxMy42NWExLDEsMCwwLDAsMS41MTktMS4zTDcuMzE3LDkuNSw5Ljc1OSw2LjY1MUExLDEsMCwwLDAsOS42NTEsNS4yNDFaIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIHgxPTE1LjUgeDI9Mi41IHkxPTguNSB5Mj05LjU+PC9saW5lPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTkuMDA3LDhDNi41NDIsNy43OTEsNiw3LjUxOSw2LDYuNSw2LDUuNzkyLDcuMjgzLDUsOSw1YzEuNTcxLDAsMi43NjUuNjc5LDIuOTY5LDEuMzA5YTEsMSwwLDAsMCwxLjktLjYxN0MxMy4zNTYsNC4xMDYsMTEuMzU0LDMsOSwzLDYuMiwzLDQsNC41MzgsNCw2LjVhMy4yLDMuMiwwLDAsMCwuNSwxLjg0M1o+PC9wYXRoPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTguOTg0LDEwQzExLjQ1NywxMC4yMDgsMTIsMTAuNDc5LDEyLDExLjVjMCwwLjcwOC0xLjI4MywxLjUtMywxLjUtMS41NzEsMC0yLjc2NS0uNjc5LTIuOTY5LTEuMzA5YTEsMSwwLDEsMC0xLjkuNjE3QzQuNjQ0LDEzLjg5NCw2LjY0NiwxNSw5LDE1YzIuOCwwLDUtMS41MzgsNS0zLjVhMy4yLDMuMiwwLDAsMC0uNS0xLjg0M1o+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtc3Ryb2tlIGQ9TTUsM1Y5YTQuMDEyLDQuMDEyLDAsMCwwLDQsNEg5YTQuMDEyLDQuMDEyLDAsMCwwLDQtNFYzPjwvcGF0aD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSByeD0wLjUgcnk9MC41IHdpZHRoPTEyIHg9MyB5PTE1PjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxyZWN0IGNsYXNzPXFsLXN0cm9rZSBoZWlnaHQ9MTIgd2lkdGg9MTIgeD0zIHk9Mz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEyIHdpZHRoPTEgeD01IHk9Mz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEyIHdpZHRoPTEgeD0xMiB5PTM+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0yIHdpZHRoPTggeD01IHk9OD48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTMgeT01PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MyB5PTc+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9MTA+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9MTI+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTU+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTc+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTEwPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MTIgeT0xMj48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cG9seWdvbiBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI3IDExIDkgMTMgMTEgMTEgNyAxMVxcXCI+PC9wb2x5Z29uPiA8cG9seWdvbiBjbGFzcz1xbC1zdHJva2UgcG9pbnRzPVxcXCI3IDcgOSA1IDExIDcgNyA3XFxcIj48L3BvbHlnb24+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkJ1YmJsZVRvb2x0aXAgPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRPT0xCQVJfQ09ORklHID0gW1snYm9sZCcsICdpdGFsaWMnLCAnbGluayddLCBbeyBoZWFkZXI6IDEgfSwgeyBoZWFkZXI6IDIgfSwgJ2Jsb2NrcXVvdGUnXV07XG5cbnZhciBCdWJibGVUaGVtZSA9IGZ1bmN0aW9uIChfQmFzZVRoZW1lKSB7XG4gIF9pbmhlcml0cyhCdWJibGVUaGVtZSwgX0Jhc2VUaGVtZSk7XG5cbiAgZnVuY3Rpb24gQnViYmxlVGhlbWUocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnViYmxlVGhlbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kdWxlcy50b29sYmFyICE9IG51bGwgJiYgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9IFRPT0xCQVJfQ09ORklHO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCdWJibGVUaGVtZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRoZW1lKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucXVpbGwuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWJ1YmJsZScpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWJibGVUaGVtZSwgW3tcbiAgICBrZXk6ICdleHRlbmRUb29sYmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kVG9vbGJhcih0b29sYmFyKSB7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgQnViYmxlVG9vbHRpcCh0aGlzLnF1aWxsLCB0aGlzLm9wdGlvbnMuYm91bmRzKTtcbiAgICAgIHRoaXMudG9vbHRpcC5yb290LmFwcGVuZENoaWxkKHRvb2xiYXIuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuYnVpbGRCdXR0b25zKFtdLnNsaWNlLmNhbGwodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpLCBfaWNvbnMyLmRlZmF1bHQpO1xuICAgICAgdGhpcy5idWlsZFBpY2tlcnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1YmJsZVRoZW1lO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbkJ1YmJsZVRoZW1lLkRFRkFVTFRTID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBfYmFzZTIuZGVmYXVsdC5ERUZBVUxUUywge1xuICBtb2R1bGVzOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayh2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXAuZWRpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBCdWJibGVUb29sdGlwID0gZnVuY3Rpb24gKF9CYXNlVG9vbHRpcCkge1xuICBfaW5oZXJpdHMoQnViYmxlVG9vbHRpcCwgX0Jhc2VUb29sdGlwKTtcblxuICBmdW5jdGlvbiBCdWJibGVUb29sdGlwKHF1aWxsLCBib3VuZHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnViYmxlVG9vbHRpcCk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1YmJsZVRvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWJibGVUb29sdGlwKSkuY2FsbCh0aGlzLCBxdWlsbCwgYm91bmRzKSk7XG5cbiAgICBfdGhpczIucXVpbGwub24oX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlLCByYW5nZSwgb2xkUmFuZ2UsIHNvdXJjZSkge1xuICAgICAgaWYgKHR5cGUgIT09IF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFKSByZXR1cm47XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCAmJiByYW5nZS5sZW5ndGggPiAwICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgICAgIF90aGlzMi5zaG93KCk7XG4gICAgICAgIC8vIExvY2sgb3VyIHdpZHRoIHNvIHdlIHdpbGwgZXhwYW5kIGJleW9uZCBvdXIgb2Zmc2V0UGFyZW50IGJvdW5kYXJpZXNcbiAgICAgICAgX3RoaXMyLnJvb3Quc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBfdGhpczIucm9vdC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICBfdGhpczIucm9vdC5zdHlsZS53aWR0aCA9IF90aGlzMi5yb290Lm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgdmFyIGxpbmVzID0gX3RoaXMyLnF1aWxsLmdldExpbmVzKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgX3RoaXMyLnBvc2l0aW9uKF90aGlzMi5xdWlsbC5nZXRCb3VuZHMocmFuZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpczIucXVpbGwuZ2V0SW5kZXgobGFzdExpbmUpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihsYXN0TGluZS5sZW5ndGgoKSAtIDEsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICAgIHZhciBfYm91bmRzID0gX3RoaXMyLnF1aWxsLmdldEJvdW5kcyhuZXcgX3NlbGVjdGlvbi5SYW5nZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgICAgICAgX3RoaXMyLnBvc2l0aW9uKF9ib3VuZHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IF90aGlzMi50ZXh0Ym94ICYmIF90aGlzMi5xdWlsbC5oYXNGb2N1cygpKSB7XG4gICAgICAgIF90aGlzMi5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWJibGVUb29sdGlwLCBbe1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBfZ2V0KEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnViYmxlVG9vbHRpcC5wcm90b3R5cGUpLCAnbGlzdGVuJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcucWwtY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtZWRpdGluZycpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTGV0IHNlbGVjdGlvbiBiZSByZXN0b3JlZCBieSB0b29sYmFyIGhhbmRsZXJzIGJlZm9yZSByZXBvc2l0aW9uaW5nXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWhpZGRlbicpKSByZXR1cm47XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMucG9zaXRpb24oX3RoaXMzLnF1aWxsLmdldEJvdW5kcyhyYW5nZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKHJlZmVyZW5jZSkge1xuICAgICAgdmFyIHNoaWZ0ID0gX2dldChCdWJibGVUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlKSwgJ3Bvc2l0aW9uJywgdGhpcykuY2FsbCh0aGlzLCByZWZlcmVuY2UpO1xuICAgICAgdmFyIGFycm93ID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy5xbC10b29sdGlwLWFycm93Jyk7XG4gICAgICBhcnJvdy5zdHlsZS5tYXJnaW5MZWZ0ID0gJyc7XG4gICAgICBpZiAoc2hpZnQgPT09IDApIHJldHVybiBzaGlmdDtcbiAgICAgIGFycm93LnN0eWxlLm1hcmdpbkxlZnQgPSAtMSAqIHNoaWZ0IC0gYXJyb3cub2Zmc2V0V2lkdGggLyAyICsgJ3B4JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnViYmxlVG9vbHRpcDtcbn0oX2Jhc2UuQmFzZVRvb2x0aXApO1xuXG5CdWJibGVUb29sdGlwLlRFTVBMQVRFID0gWyc8c3BhbiBjbGFzcz1cInFsLXRvb2x0aXAtYXJyb3dcIj48L3NwYW4+JywgJzxkaXYgY2xhc3M9XCJxbC10b29sdGlwLWVkaXRvclwiPicsICc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWZvcm11bGE9XCJlPW1jXjJcIiBkYXRhLWxpbms9XCJodHRwczovL3F1aWxsanMuY29tXCIgZGF0YS12aWRlbz1cIkVtYmVkIFVSTFwiPicsICc8YSBjbGFzcz1cInFsLWNsb3NlXCI+PC9hPicsICc8L2Rpdj4nXS5qb2luKCcnKTtcblxuZXhwb3J0cy5CdWJibGVUb29sdGlwID0gQnViYmxlVG9vbHRpcDtcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1YmJsZVRoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTtcbn0pO1xuXG52YXIgUXVpbGwgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocXVpbGwpO1xuXG52YXIgcmFuZG9tQ29sb3IgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIC8vIFN1cHBvcnQgQ29tbW9uSlNcbiAge1xuICAgIHZhciByYW5kb21Db2xvciA9IGZhY3RvcnkoKTtcblxuICAgIC8vIFN1cHBvcnQgTm9kZUpTICYgQ29tcG9uZW50LCB3aGljaCBhbGxvdyBtb2R1bGUuZXhwb3J0cyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQ29sb3I7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBDb21tb25KUyAxLjEuMSBzcGVjXG4gICAgZXhwb3J0cy5yYW5kb21Db2xvciA9IHJhbmRvbUNvbG9yO1xuXG4gIC8vIFN1cHBvcnQgQU1EXG4gIH1cblxufShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24oKSB7XG5cbiAgLy8gU2VlZCB0byBnZXQgcmVwZWF0YWJsZSBjb2xvcnNcbiAgdmFyIHNlZWQgPSBudWxsO1xuXG4gIC8vIFNoYXJlZCBjb2xvciBkaWN0aW9uYXJ5XG4gIHZhciBjb2xvckRpY3Rpb25hcnkgPSB7fTtcblxuICAvLyBQb3B1bGF0ZSB0aGUgY29sb3IgZGljdGlvbmFyeVxuICBsb2FkQ29sb3JCb3VuZHMoKTtcblxuICAvLyBjaGVjayBpZiBhIHJhbmdlIGlzIHRha2VuXG4gIHZhciBjb2xvclJhbmdlcyA9IFtdO1xuXG4gIHZhciByYW5kb21Db2xvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgc2VlZCBhbmQgZW5zdXJlIGl0J3MgYW5cbiAgICAvLyBpbnRlZ2VyLiBPdGhlcndpc2UsIHJlc2V0IHRoZSBzZWVkIHZhbHVlLlxuICAgIGlmIChvcHRpb25zLnNlZWQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnNlZWQgIT09IG51bGwgJiYgb3B0aW9ucy5zZWVkID09PSBwYXJzZUludChvcHRpb25zLnNlZWQsIDEwKSkge1xuICAgICAgc2VlZCA9IG9wdGlvbnMuc2VlZDtcblxuICAgIC8vIEEgc3RyaW5nIHdhcyBwYXNzZWQgYXMgYSBzZWVkXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5zZWVkID09PSAnc3RyaW5nJykge1xuICAgICAgc2VlZCA9IHN0cmluZ1RvSW50ZWdlcihvcHRpb25zLnNlZWQpO1xuXG4gICAgLy8gU29tZXRoaW5nIHdhcyBwYXNzZWQgYXMgYSBzZWVkIGJ1dCBpdCB3YXNuJ3QgYW4gaW50ZWdlciBvciBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VlZCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2VlZCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHNlZWQgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIHN0cmluZycpO1xuXG4gICAgLy8gTm8gc2VlZCwgcmVzZXQgdGhlIHZhbHVlIG91dHNpZGUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBILFMsQjtcblxuICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gZ2VuZXJhdGUgbXVsdGlwbGUgY29sb3JzXG4gICAgaWYgKG9wdGlvbnMuY291bnQgIT09IG51bGwgJiYgb3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIHZhciB0b3RhbENvbG9ycyA9IG9wdGlvbnMuY291bnQsXG4gICAgICAgICAgY29sb3JzID0gW107XG4gICAgICAvLyBWYWx1ZSBmYWxzZSBhdCBpbmRleCBpIG1lYW5zIHRoZSByYW5nZSBpIGlzIG5vdCB0YWtlbiB5ZXQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuY291bnQ7IGkrKykge1xuICAgICAgICBjb2xvclJhbmdlcy5wdXNoKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgb3B0aW9ucy5jb3VudCA9IG51bGw7XG5cbiAgICAgIHdoaWxlICh0b3RhbENvbG9ycyA+IGNvbG9ycy5sZW5ndGgpIHtcblxuICAgICAgICB2YXIgY29sb3IgPSByYW5kb21Db2xvcihvcHRpb25zKTtcblxuICAgICAgICBpZiAoc2VlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xvcnMucHVzaChjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuY291bnQgPSB0b3RhbENvbG9ycztcblxuICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBwaWNrIGEgaHVlIChIKVxuICAgIEggPSBwaWNrSHVlKG9wdGlvbnMpO1xuXG4gICAgLy8gVGhlbiB1c2UgSCB0byBkZXRlcm1pbmUgc2F0dXJhdGlvbiAoUylcbiAgICBTID0gcGlja1NhdHVyYXRpb24oSCwgb3B0aW9ucyk7XG5cbiAgICAvLyBUaGVuIHVzZSBTIGFuZCBIIHRvIGRldGVybWluZSBicmlnaHRuZXNzIChCKS5cbiAgICBCID0gcGlja0JyaWdodG5lc3MoSCwgUywgb3B0aW9ucyk7XG5cbiAgICAvLyBUaGVuIHdlIHJldHVybiB0aGUgSFNCIGNvbG9yIGluIHRoZSBkZXNpcmVkIGZvcm1hdFxuICAgIHJldHVybiBzZXRGb3JtYXQoW0gsUyxCXSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGlja0h1ZShvcHRpb25zKSB7XG4gICAgaWYgKGNvbG9yUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBodWVSYW5nZSA9IGdldFJlYWxIdWVSYW5nZShvcHRpb25zLmh1ZSk7XG5cbiAgICAgIHZhciBodWUgPSByYW5kb21XaXRoaW4oaHVlUmFuZ2UpO1xuXG4gICAgICAvL0VhY2ggb2YgY29sb3JSYW5nZXMubGVuZ3RoIHJhbmdlcyBoYXMgYSBsZW5ndGggZXF1YWwgYXBwcm94aW1hdGVsbHkgb25lIHN0ZXBcbiAgICAgIHZhciBzdGVwID0gKGh1ZVJhbmdlWzFdIC0gaHVlUmFuZ2VbMF0pIC8gY29sb3JSYW5nZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgaiA9IHBhcnNlSW50KChodWUgLSBodWVSYW5nZVswXSkgLyBzdGVwKTtcblxuICAgICAgLy9DaGVjayBpZiB0aGUgcmFuZ2UgaiBpcyB0YWtlblxuICAgICAgaWYgKGNvbG9yUmFuZ2VzW2pdID09PSB0cnVlKSB7XG4gICAgICAgIGogPSAoaiArIDIpICUgY29sb3JSYW5nZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbG9yUmFuZ2VzW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgfVxuXG4gICAgICB2YXIgbWluID0gKGh1ZVJhbmdlWzBdICsgaiAqIHN0ZXApICUgMzU5LFxuICAgICAgICAgIG1heCA9IChodWVSYW5nZVswXSArIChqICsgMSkgKiBzdGVwKSAlIDM1OTtcblxuICAgICAgaHVlUmFuZ2UgPSBbbWluLCBtYXhdO1xuXG4gICAgICBodWUgPSByYW5kb21XaXRoaW4oaHVlUmFuZ2UpO1xuXG4gICAgICBpZiAoaHVlIDwgMCkge2h1ZSA9IDM2MCArIGh1ZTt9XG4gICAgICByZXR1cm4gaHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGh1ZVJhbmdlID0gZ2V0SHVlUmFuZ2Uob3B0aW9ucy5odWUpO1xuXG4gICAgICBodWUgPSByYW5kb21XaXRoaW4oaHVlUmFuZ2UpO1xuICAgICAgLy8gSW5zdGVhZCBvZiBzdG9yaW5nIHJlZCBhcyB0d28gc2VwZXJhdGUgcmFuZ2VzLFxuICAgICAgLy8gd2UgZ3JvdXAgdGhlbSwgdXNpbmcgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgaWYgKGh1ZSA8IDApIHtcbiAgICAgICAgaHVlID0gMzYwICsgaHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBpY2tTYXR1cmF0aW9uIChodWUsIG9wdGlvbnMpIHtcblxuICAgIGlmIChvcHRpb25zLmh1ZSA9PT0gJ21vbm9jaHJvbWUnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sdW1pbm9zaXR5ID09PSAncmFuZG9tJykge1xuICAgICAgcmV0dXJuIHJhbmRvbVdpdGhpbihbMCwxMDBdKTtcbiAgICB9XG5cbiAgICB2YXIgc2F0dXJhdGlvblJhbmdlID0gZ2V0U2F0dXJhdGlvblJhbmdlKGh1ZSk7XG5cbiAgICB2YXIgc01pbiA9IHNhdHVyYXRpb25SYW5nZVswXSxcbiAgICAgICAgc01heCA9IHNhdHVyYXRpb25SYW5nZVsxXTtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5sdW1pbm9zaXR5KSB7XG5cbiAgICAgIGNhc2UgJ2JyaWdodCc6XG4gICAgICAgIHNNaW4gPSA1NTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RhcmsnOlxuICAgICAgICBzTWluID0gc01heCAtIDEwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICBzTWF4ID0gNTU7XG4gICAgICAgIGJyZWFrO1xuICAgfVxuXG4gICAgcmV0dXJuIHJhbmRvbVdpdGhpbihbc01pbiwgc01heF0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBwaWNrQnJpZ2h0bmVzcyAoSCwgUywgb3B0aW9ucykge1xuXG4gICAgdmFyIGJNaW4gPSBnZXRNaW5pbXVtQnJpZ2h0bmVzcyhILCBTKSxcbiAgICAgICAgYk1heCA9IDEwMDtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5sdW1pbm9zaXR5KSB7XG5cbiAgICAgIGNhc2UgJ2RhcmsnOlxuICAgICAgICBiTWF4ID0gYk1pbiArIDIwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICBiTWluID0gKGJNYXggKyBiTWluKS8yO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmFuZG9tJzpcbiAgICAgICAgYk1pbiA9IDA7XG4gICAgICAgIGJNYXggPSAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByYW5kb21XaXRoaW4oW2JNaW4sIGJNYXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEZvcm1hdCAoaHN2LCBvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuZm9ybWF0KSB7XG5cbiAgICAgIGNhc2UgJ2hzdkFycmF5JzpcbiAgICAgICAgcmV0dXJuIGhzdjtcblxuICAgICAgY2FzZSAnaHNsQXJyYXknOlxuICAgICAgICByZXR1cm4gSFNWdG9IU0woaHN2KTtcblxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgdmFyIGhzbCA9IEhTVnRvSFNMKGhzdik7XG4gICAgICAgIHJldHVybiAnaHNsKCcraHNsWzBdKycsICcraHNsWzFdKyclLCAnK2hzbFsyXSsnJSknO1xuXG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgdmFyIGhzbENvbG9yID0gSFNWdG9IU0woaHN2KTtcbiAgICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYSB8fCBNYXRoLnJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gJ2hzbGEoJytoc2xDb2xvclswXSsnLCAnK2hzbENvbG9yWzFdKyclLCAnK2hzbENvbG9yWzJdKyclLCAnICsgYWxwaGEgKyAnKSc7XG5cbiAgICAgIGNhc2UgJ3JnYkFycmF5JzpcbiAgICAgICAgcmV0dXJuIEhTVnRvUkdCKGhzdik7XG5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIHZhciByZ2IgPSBIU1Z0b1JHQihoc3YpO1xuICAgICAgICByZXR1cm4gJ3JnYignICsgcmdiLmpvaW4oJywgJykgKyAnKSc7XG5cbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICB2YXIgcmdiQ29sb3IgPSBIU1Z0b1JHQihoc3YpO1xuICAgICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLmFscGhhIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiQ29sb3Iuam9pbignLCAnKSArICcsICcgKyBhbHBoYSArICcpJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEhTVnRvSGV4KGhzdik7XG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW5pbXVtQnJpZ2h0bmVzcyhILCBTKSB7XG5cbiAgICB2YXIgbG93ZXJCb3VuZHMgPSBnZXRDb2xvckluZm8oSCkubG93ZXJCb3VuZHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvd2VyQm91bmRzLmxlbmd0aCAtIDE7IGkrKykge1xuXG4gICAgICB2YXIgczEgPSBsb3dlckJvdW5kc1tpXVswXSxcbiAgICAgICAgICB2MSA9IGxvd2VyQm91bmRzW2ldWzFdO1xuXG4gICAgICB2YXIgczIgPSBsb3dlckJvdW5kc1tpKzFdWzBdLFxuICAgICAgICAgIHYyID0gbG93ZXJCb3VuZHNbaSsxXVsxXTtcblxuICAgICAgaWYgKFMgPj0gczEgJiYgUyA8PSBzMikge1xuXG4gICAgICAgICB2YXIgbSA9ICh2MiAtIHYxKS8oczIgLSBzMSksXG4gICAgICAgICAgICAgYiA9IHYxIC0gbSpzMTtcblxuICAgICAgICAgcmV0dXJuIG0qUyArIGI7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEh1ZVJhbmdlIChjb2xvcklucHV0KSB7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlSW50KGNvbG9ySW5wdXQpID09PSAnbnVtYmVyJykge1xuXG4gICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoY29sb3JJbnB1dCk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAzNjAgJiYgbnVtYmVyID4gMCkge1xuICAgICAgICByZXR1cm4gW251bWJlciwgbnVtYmVyXTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29sb3JJbnB1dCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgaWYgKGNvbG9yRGljdGlvbmFyeVtjb2xvcklucHV0XSkge1xuICAgICAgICB2YXIgY29sb3IgPSBjb2xvckRpY3Rpb25hcnlbY29sb3JJbnB1dF07XG4gICAgICAgIGlmIChjb2xvci5odWVSYW5nZSkge3JldHVybiBjb2xvci5odWVSYW5nZTt9XG4gICAgICB9IGVsc2UgaWYgKGNvbG9ySW5wdXQubWF0Y2goL14jPyhbMC05QS1GXXszfXxbMC05QS1GXXs2fSkkL2kpKSB7XG4gICAgICAgIHZhciBodWUgPSBIZXhUb0hTQihjb2xvcklucHV0KVswXTtcbiAgICAgICAgcmV0dXJuIFsgaHVlLCBodWUgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWzAsMzYwXTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F0dXJhdGlvblJhbmdlIChodWUpIHtcbiAgICByZXR1cm4gZ2V0Q29sb3JJbmZvKGh1ZSkuc2F0dXJhdGlvblJhbmdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29sb3JJbmZvIChodWUpIHtcblxuICAgIC8vIE1hcHMgcmVkIGNvbG9ycyB0byBtYWtlIHBpY2tpbmcgaHVlIGVhc2llclxuICAgIGlmIChodWUgPj0gMzM0ICYmIGh1ZSA8PSAzNjApIHtcbiAgICAgIGh1ZS09IDM2MDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjb2xvck5hbWUgaW4gY29sb3JEaWN0aW9uYXJ5KSB7XG4gICAgICAgdmFyIGNvbG9yID0gY29sb3JEaWN0aW9uYXJ5W2NvbG9yTmFtZV07XG4gICAgICAgaWYgKGNvbG9yLmh1ZVJhbmdlICYmXG4gICAgICAgICAgIGh1ZSA+PSBjb2xvci5odWVSYW5nZVswXSAmJlxuICAgICAgICAgICBodWUgPD0gY29sb3IuaHVlUmFuZ2VbMV0pIHtcbiAgICAgICAgICByZXR1cm4gY29sb3JEaWN0aW9uYXJ5W2NvbG9yTmFtZV07XG4gICAgICAgfVxuICAgIH0gcmV0dXJuICdDb2xvciBub3QgZm91bmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZG9tV2l0aGluIChyYW5nZSkge1xuICAgIGlmIChzZWVkID09PSBudWxsKSB7XG4gICAgICAvL2dlbmVyYXRlIHJhbmRvbSBldmVubHkgZGVzdGluY3QgbnVtYmVyIGZyb20gOiBodHRwczovL21hcnRpbi5hbmtlcmwuY29tLzIwMDkvMTIvMDkvaG93LXRvLWNyZWF0ZS1yYW5kb20tY29sb3JzLXByb2dyYW1tYXRpY2FsbHkvXG4gICAgICB2YXIgZ29sZGVuX3JhdGlvID0gMC42MTgwMzM5ODg3NDk4OTU7XG4gICAgICB2YXIgcj1NYXRoLnJhbmRvbSgpO1xuICAgICAgciArPSBnb2xkZW5fcmF0aW87XG4gICAgICByICU9IDE7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5nZVswXSArIHIqKHJhbmdlWzFdICsgMSAtIHJhbmdlWzBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vU2VlZGVkIHJhbmRvbSBhbGdvcml0aG0gZnJvbSBodHRwOi8vaW5kaWVnYW1yLmNvbS9nZW5lcmF0ZS1yZXBlYXRhYmxlLXJhbmRvbS1udW1iZXJzLWluLWpzL1xuICAgICAgdmFyIG1heCA9IHJhbmdlWzFdIHx8IDE7XG4gICAgICB2YXIgbWluID0gcmFuZ2VbMF0gfHwgMDtcbiAgICAgIHNlZWQgPSAoc2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7XG4gICAgICB2YXIgcm5kID0gc2VlZCAvIDIzMzI4MC4wO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobWluICsgcm5kICogKG1heCAtIG1pbikpO1xufVxuICB9XG5cbiAgZnVuY3Rpb24gSFNWdG9IZXggKGhzdil7XG5cbiAgICB2YXIgcmdiID0gSFNWdG9SR0IoaHN2KTtcblxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICAgICAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIH1cblxuICAgIHZhciBoZXggPSAnIycgKyBjb21wb25lbnRUb0hleChyZ2JbMF0pICsgY29tcG9uZW50VG9IZXgocmdiWzFdKSArIGNvbXBvbmVudFRvSGV4KHJnYlsyXSk7XG5cbiAgICByZXR1cm4gaGV4O1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVDb2xvciAobmFtZSwgaHVlUmFuZ2UsIGxvd2VyQm91bmRzKSB7XG5cbiAgICB2YXIgc01pbiA9IGxvd2VyQm91bmRzWzBdWzBdLFxuICAgICAgICBzTWF4ID0gbG93ZXJCb3VuZHNbbG93ZXJCb3VuZHMubGVuZ3RoIC0gMV1bMF0sXG5cbiAgICAgICAgYk1pbiA9IGxvd2VyQm91bmRzW2xvd2VyQm91bmRzLmxlbmd0aCAtIDFdWzFdLFxuICAgICAgICBiTWF4ID0gbG93ZXJCb3VuZHNbMF1bMV07XG5cbiAgICBjb2xvckRpY3Rpb25hcnlbbmFtZV0gPSB7XG4gICAgICBodWVSYW5nZTogaHVlUmFuZ2UsXG4gICAgICBsb3dlckJvdW5kczogbG93ZXJCb3VuZHMsXG4gICAgICBzYXR1cmF0aW9uUmFuZ2U6IFtzTWluLCBzTWF4XSxcbiAgICAgIGJyaWdodG5lc3NSYW5nZTogW2JNaW4sIGJNYXhdXG4gICAgfTtcblxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZENvbG9yQm91bmRzICgpIHtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ21vbm9jaHJvbWUnLFxuICAgICAgbnVsbCxcbiAgICAgIFtbMCwwXSxbMTAwLDBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdyZWQnLFxuICAgICAgWy0yNiwxOF0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkyXSxbNDAsODldLFs1MCw4NV0sWzYwLDc4XSxbNzAsNzBdLFs4MCw2MF0sWzkwLDU1XSxbMTAwLDUwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAnb3JhbmdlJyxcbiAgICAgIFsxOCw0Nl0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkzXSxbNDAsODhdLFs1MCw4Nl0sWzYwLDg1XSxbNzAsNzBdLFsxMDAsNzBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICd5ZWxsb3cnLFxuICAgICAgWzQ2LDYyXSxcbiAgICAgIFtbMjUsMTAwXSxbNDAsOTRdLFs1MCw4OV0sWzYwLDg2XSxbNzAsODRdLFs4MCw4Ml0sWzkwLDgwXSxbMTAwLDc1XV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAnZ3JlZW4nLFxuICAgICAgWzYyLDE3OF0sXG4gICAgICBbWzMwLDEwMF0sWzQwLDkwXSxbNTAsODVdLFs2MCw4MV0sWzcwLDc0XSxbODAsNjRdLFs5MCw1MF0sWzEwMCw0MF1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ2JsdWUnLFxuICAgICAgWzE3OCwgMjU3XSxcbiAgICAgIFtbMjAsMTAwXSxbMzAsODZdLFs0MCw4MF0sWzUwLDc0XSxbNjAsNjBdLFs3MCw1Ml0sWzgwLDQ0XSxbOTAsMzldLFsxMDAsMzVdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdwdXJwbGUnLFxuICAgICAgWzI1NywgMjgyXSxcbiAgICAgIFtbMjAsMTAwXSxbMzAsODddLFs0MCw3OV0sWzUwLDcwXSxbNjAsNjVdLFs3MCw1OV0sWzgwLDUyXSxbOTAsNDVdLFsxMDAsNDJdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdwaW5rJyxcbiAgICAgIFsyODIsIDMzNF0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkwXSxbNDAsODZdLFs2MCw4NF0sWzgwLDgwXSxbOTAsNzVdLFsxMDAsNzNdXVxuICAgICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIEhTVnRvUkdCIChoc3YpIHtcblxuICAgIC8vIHRoaXMgZG9lc24ndCB3b3JrIGZvciB0aGUgdmFsdWVzIG9mIDAgYW5kIDM2MFxuICAgIC8vIGhlcmUncyB0aGUgaGFja3kgZml4XG4gICAgdmFyIGggPSBoc3ZbMF07XG4gICAgaWYgKGggPT09IDApIHtoID0gMTt9XG4gICAgaWYgKGggPT09IDM2MCkge2ggPSAzNTk7fVxuXG4gICAgLy8gUmViYXNlIHRoZSBoLHMsdiB2YWx1ZXNcbiAgICBoID0gaC8zNjA7XG4gICAgdmFyIHMgPSBoc3ZbMV0vMTAwLFxuICAgICAgICB2ID0gaHN2WzJdLzEwMDtcblxuICAgIHZhciBoX2kgPSBNYXRoLmZsb29yKGgqNiksXG4gICAgICBmID0gaCAqIDYgLSBoX2ksXG4gICAgICBwID0gdiAqICgxIC0gcyksXG4gICAgICBxID0gdiAqICgxIC0gZipzKSxcbiAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpKnMpLFxuICAgICAgciA9IDI1NixcbiAgICAgIGcgPSAyNTYsXG4gICAgICBiID0gMjU2O1xuXG4gICAgc3dpdGNoKGhfaSkge1xuICAgICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyAgYnJlYWs7XG4gICAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7ICBicmVhaztcbiAgICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgIGJyZWFrO1xuICAgICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyAgYnJlYWs7XG4gICAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7ICBicmVhaztcbiAgICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbTWF0aC5mbG9vcihyKjI1NSksIE1hdGguZmxvb3IoZyoyNTUpLCBNYXRoLmZsb29yKGIqMjU1KV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhleFRvSFNCIChoZXgpIHtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCAnJyk7XG4gICAgaGV4ID0gaGV4Lmxlbmd0aCA9PT0gMyA/IGhleC5yZXBsYWNlKC8oLikvZywgJyQxJDEnKSA6IGhleDtcblxuICAgIHZhciByZWQgPSBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNikgLyAyNTUsXG4gICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChoZXguc3Vic3RyKDIsIDIpLCAxNikgLyAyNTUsXG4gICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoNCwgMiksIDE2KSAvIDI1NTtcblxuICAgIHZhciBjTWF4ID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgZGVsdGEgPSBjTWF4IC0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgc2F0dXJhdGlvbiA9IGNNYXggPyAoZGVsdGEgLyBjTWF4KSA6IDA7XG5cbiAgICBzd2l0Y2ggKGNNYXgpIHtcbiAgICAgIGNhc2UgcmVkOiByZXR1cm4gWyA2MCAqICgoKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSkgJSA2KSB8fCAwLCBzYXR1cmF0aW9uLCBjTWF4IF07XG4gICAgICBjYXNlIGdyZWVuOiByZXR1cm4gWyA2MCAqICgoKGJsdWUgLSByZWQpIC8gZGVsdGEpICsgMikgfHwgMCwgc2F0dXJhdGlvbiwgY01heCBdO1xuICAgICAgY2FzZSBibHVlOiByZXR1cm4gWyA2MCAqICgoKHJlZCAtIGdyZWVuKSAvIGRlbHRhKSArIDQpIHx8IDAsIHNhdHVyYXRpb24sIGNNYXggXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBIU1Z0b0hTTCAoaHN2KSB7XG4gICAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdLzEwMCxcbiAgICAgIHYgPSBoc3ZbMl0vMTAwLFxuICAgICAgayA9ICgyLXMpKnY7XG5cbiAgICByZXR1cm4gW1xuICAgICAgaCxcbiAgICAgIE1hdGgucm91bmQocyp2IC8gKGs8MSA/IGsgOiAyLWspICogMTAwMDApIC8gMTAwLFxuICAgICAgay8yICogMTAwXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvSW50ZWdlciAoc3RyaW5nKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodG90YWwgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIGJyZWFrO1xuICAgICAgdG90YWwgKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbFxuICB9XG5cbiAgLy8gZ2V0IFRoZSByYW5nZSBvZiBnaXZlbiBodWUgd2hlbiBvcHRpb25zLmNvdW50IT0wXG4gIGZ1bmN0aW9uIGdldFJlYWxIdWVSYW5nZShjb2xvckh1ZSlcbiAgeyBpZiAoIWlzTmFOKGNvbG9ySHVlKSkge1xuICAgIHZhciBudW1iZXIgPSBwYXJzZUludChjb2xvckh1ZSk7XG5cbiAgICBpZiAobnVtYmVyIDwgMzYwICYmIG51bWJlciA+IDApIHtcbiAgICAgIHJldHVybiBnZXRDb2xvckluZm8oY29sb3JIdWUpLmh1ZVJhbmdlXG4gICAgfVxuICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbG9ySHVlID09PSAnc3RyaW5nJykge1xuXG4gICAgICBpZiAoY29sb3JEaWN0aW9uYXJ5W2NvbG9ySHVlXSkge1xuICAgICAgICB2YXIgY29sb3IgPSBjb2xvckRpY3Rpb25hcnlbY29sb3JIdWVdO1xuXG4gICAgICAgIGlmIChjb2xvci5odWVSYW5nZSkge1xuICAgICAgICAgIHJldHVybiBjb2xvci5odWVSYW5nZVxuICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbG9ySHVlLm1hdGNoKC9eIz8oWzAtOUEtRl17M318WzAtOUEtRl17Nn0pJC9pKSkge1xuICAgICAgICB2YXIgaHVlID0gSGV4VG9IU0IoY29sb3JIdWUpWzBdO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JJbmZvKGh1ZSkuaHVlUmFuZ2VcbiAgICB9XG4gIH1cblxuICAgIHJldHVybiBbMCwzNjBdXG59XG4gIHJldHVybiByYW5kb21Db2xvcjtcbn0pKTtcbn0pO1xuXG5jbGFzcyBUZXh0SW5wdXQge1xuICAgIC8vIFRoZSBpbnB1dCBlbGVtZW50XG4gICAgZWw7XG4gICAgcXVpbGw7XG4gICAgZ3JvdXBzO1xuICAgIHBhcmVudEVsZW1lbnQ7XG4gICAgZHJvcHBlZFRleHQ7XG4gICAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCkge1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwuaWQgPSAncmVnZXh0b29sLScgKyB0aGlzLnBhcmVudEVsZW1lbnQudG9vbE51bWJlciArICctcmVnZXgtaW5wdXQnO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3JlZ2V4LWlucHV0Jyk7XG4gICAgICAgIHRoaXMucXVpbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmRyb3BwZWRUZXh0ID0gZmFsc2U7XG4gICAgfVxuICAgIGluaXRRdWlsbCA9ICgpID0+IHtcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHF1aWxsXG4gICAgICAgIHRoaXMucXVpbGwgPSBuZXcgUXVpbGwoJyNyZWdleHRvb2wtJyArIHRoaXMucGFyZW50RWxlbWVudC50b29sTnVtYmVyICsgJy1yZWdleC1pbnB1dCcsIHtcbiAgICAgICAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgICAgICAgICB0b29sYmFyOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XG4gICAgICAgICAgICBrZXk6ICdDJyxcbiAgICAgICAgICAgIHNob3J0S2V5OiB0cnVlLFxuICAgICAgICB9LCAocmFuZ2UsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyZWVLZXlib2FyZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICdldmVudC10eXBlJzogJ3RleHQtaW5wdXQta2V5Ym9hcmQnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBrZXlzOiBbJ2N0cmwnLCAnYyddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5sb2dFdmVudChmcmVlS2V5Ym9hcmRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XG4gICAgICAgICAgICBrZXk6ICdWJyxcbiAgICAgICAgICAgIHNob3J0S2V5OiB0cnVlLFxuICAgICAgICB9LCAocmFuZ2UsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyZWVLZXlib2FyZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICdldmVudC10eXBlJzogJ3RleHQtaW5wdXQta2V5Ym9hcmQnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBrZXlzOiBbJ2N0cmwnLCAndiddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5sb2dFdmVudChmcmVlS2V5Ym9hcmRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwub25kcm9wID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyb3BwZWRUZXh0ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGdldFRleHQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnF1aWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1aWxsLmdldFRleHQoMCwgdGhpcy5xdWlsbC5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBoaWdobGlnaHRHcm91cCA9IChjb2xvcnMpID0+IHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVHcm91cCgpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdyb3Vwcyk7XG4gICAgICAgIHRoaXMucXVpbGw/LnJlbW92ZUZvcm1hdCgwLCB0aGlzLnF1aWxsLmdldExlbmd0aCgpIC0gMSwgJ3NpbGVudCcpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBuZXcgY29sb3JzIGZvciBncm91cCBpZiBjdXJyZW50IGNvbG9ycyBhcmUgbm90IGVub3VnaFxuICAgICAgICBjb25zdCBncm91cENvdW50ID0gdGhpcy5ncm91cHMubGVuZ3RoO1xuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA8IGdyb3VwQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDb2xvcihjb2xvcnMsIGdyb3VwQ291bnQgLSBjb2xvcnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoaWdobGlnaHQgdGhlIGdyb3Vwc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsPy5mb3JtYXRUZXh0KHRoaXMuZ3JvdXBzW2ldLnN0YXJ0LCB0aGlzLmdyb3Vwc1tpXS5lbmQgLSB0aGlzLmdyb3Vwc1tpXS5zdGFydCwge1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kJzogY29sb3JzW2ldXG4gICAgICAgICAgICB9LCAnc2lsZW50Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNhbGN1bGF0ZUdyb3VwID0gKCkgPT4ge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICB0aGlzLmdyb3Vwcy5wdXNoKHsgc3RhcnQ6IDAsIGVuZDogcGF0dGVybi5sZW5ndGggfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5baV0gPT0gJygnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmdyb3Vwcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzLnB1c2goeyBzdGFydDogaSwgZW5kOiAtMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdHRlcm5baV0gPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW3N0YXJ0SW5kZXhdLmVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVE9ETzogKHN0cnVjdHVyZSkgbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIHRoZSBtYWluIGVsZW1lbnQgYWZ0ZXIgYWRkaW5nIGhpZ2hsaWdodCB0byBpbnB1dFxuICAgIGdlbmVyYXRlQ29sb3IgPSAoY29sb3JzLCBjbnQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgY29sb3JzLnB1c2gocmFuZG9tQ29sb3IucmFuZG9tQ29sb3IoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZVRlc3RTdGF0dXMgPSAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdQYXNzJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnUGFzcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdGYWlsJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnRmFpbCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdFcnJvcicpKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ0Vycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHJlc3VsdCk7XG4gICAgfTtcbiAgICByZW1vdmVGb3JtYXQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucXVpbGw/LnJlbW92ZUZvcm1hdCgwLCB0aGlzLnF1aWxsLmdldExlbmd0aCgpIC0gMSwgJ3NpbGVudCcpO1xuICAgIH07XG4gICAgaGlnaGxpZ2h0RXJyb3IgPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5xdWlsbD8uZm9ybWF0VGV4dChwb3NpdGlvbiwgMSwge1xuICAgICAgICAgICAgJ2JhY2tncm91bmQnOiAnI2ZmOTliMydcbiAgICAgICAgfSwgJ3NpbGVudCcpO1xuICAgIH07XG4gICAgcmVzdG9yZUFuc3dlcih0eXBlLCBhbnN3ZXIpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIGxvZ2dpbmcgdG8gcmVzdG9yaW5nIGFuc3dlclxuICAgICAgICBpZiAodHlwZSAhPSAndGV4dCcgfHwgdHlwZW9mIGFuc3dlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1aWxsPy5zZXRUZXh0KGFuc3dlcik7XG4gICAgfVxuICAgIHNldEluZGVudCA9IChpbmRlbnQpID0+IHtcbiAgICB9O1xufVxuXG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmFzY3JpcHQnLCBqYXZhc2NyaXB0XzEpO1xuY29yZS5yZWdpc3Rlckxhbmd1YWdlKCdzcWwnLCBzcWxfMSk7XG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmEnLCBqYXZhXzEpO1xuY29yZS5yZWdpc3Rlckxhbmd1YWdlKCd4bWwnLCB4bWxfMSk7XG5jb3JlLnJlZ2lzdGVyTGFuZ3VhZ2UoJ3B5dGhvbicsIHB5dGhvbl8xKTtcbmNsYXNzIEhQYXJzb25zRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICByb290O1xuICAgIF9wYXJzb25zRGF0YTtcbiAgICBwYXJzb25zRXhwbGFuYXRpb247XG4gICAgaHBhcnNvbnNJbnB1dDtcbiAgICBpbnB1dFR5cGU7XG4gICAgc3RhdGljIHRvb2xDb3VudCA9IDA7XG4gICAgdG9vbE51bWJlcjtcbiAgICB0ZW1wb3JhcnlJbnB1dEV2ZW50O1xuICAgIGlucHV0RGl2O1xuICAgIGxhbmd1YWdlO1xuICAgIGNvbnRleHRCZWZvcmU7XG4gICAgY29udGV4dEFmdGVyO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBIUGFyc29uc0VsZW1lbnQudG9vbENvdW50ICs9IDE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFJlZ2V4RWxlbWVudC50b29sQ291bnQpO1xuICAgICAgICB0aGlzLnRvb2xOdW1iZXIgPSBIUGFyc29uc0VsZW1lbnQudG9vbENvdW50O1xuICAgICAgICAvLyB0aGlzLnJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5hZGRTdHlsZSgpO1xuICAgICAgICB0aGlzLmlucHV0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5wdXREaXYuY2xhc3NMaXN0LmFkZCgnaHBhcnNvbnMtaW5wdXQnKTtcbiAgICAgICAgdGhpcy5yb290LmFwcGVuZCh0aGlzLmlucHV0RGl2KTtcbiAgICAgICAgY29uc3QgcmV1c2FibGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmV1c2UtYmxvY2tzJykgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHJhbmRvbWl6ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyYW5kb21pemUnKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5ocGFyc29uc0lucHV0ID0gbmV3IFBhcnNvbnNJbnB1dCh0aGlzLCByZXVzYWJsZSwgcmFuZG9taXplKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cocmV1c2FibGUpXG4gICAgICAgIC8vIGEgZGl2IHdyYXBwaW5nIHRoZSBpbnB1dCBhbmQgdGhlIHRlc3QgY2FzZSBzdGF0dXNcbiAgICAgICAgLy8gaW5pdCByZWdleCBpbnB1dCBiYXNlZCBvbiB0aGUgaW5wdXQgdHlwZVxuICAgICAgICB0aGlzLl9wYXJzb25zRGF0YSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnBhcnNvbnNFeHBsYW5hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXRUeXBlID0gJ3BhcnNvbnMnO1xuICAgICAgICAvLyB0aGlzLnJlZ2V4RXJyb3JNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIHRoaXMucmVnZXhFcnJvclBvc2l0aW9uID0gLTE7XG4gICAgICAgIHRoaXMuaW5pdFJlZ2V4SW5wdXQoKTtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJbnB1dEV2ZW50ID0ge307XG4gICAgICAgIGxldCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgJ2h0bWwnOiAneG1sJyxcbiAgICAgICAgICAgICdweXRob24nOiAncHl0aG9uJyxcbiAgICAgICAgICAgICdqYXZhc2NyaXB0JzogJ2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ2phdmEnOiAnamF2YScsXG4gICAgICAgICAgICAnc3FsJzogJ3NxbCdcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2VNYXAuZ2V0KHRoaXMuZ2V0QXR0cmlidXRlKCdsYW5ndWFnZScpIHx8ICdub25lJyk7XG4gICAgICAgIHRoaXMuY29udGV4dEJlZm9yZSA9IHRoaXMuY29udGV4dEFmdGVyID0gbnVsbDtcbiAgICB9XG4gICAgc2V0IHBhcnNvbnNEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcGFyc29uc0RhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5pbnB1dFR5cGUgPT0gJ3BhcnNvbnMnKSB7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuc2V0U291cmNlQmxvY2tzKGRhdGEsIHRoaXMucGFyc29uc0V4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGFyc29uc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzb25zRGF0YTtcbiAgICB9XG4gICAgLy8gVE9ET1tyZWZhY3Rvcl06IHB1dCBzdHlsZXNoZWV0IGluIGEgc2VwYXJhdGUgY3NzL3Njc3MgZmlsZVxuICAgIGFkZFN0eWxlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIC8vIHBhcnNvbnMgYmxvY2tcbiAgICAgICAgc2hlZXQuaW5uZXJIVE1MICs9ICcuaHBhcnNvbnMtaW5wdXQge3BhZGRpbmc6IDE1cHg7fVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLmhwYXJzb25zLXRpcCB7IGZvbnQtc3R5bGU6IGl0YWxpYzsgfVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLnBhcnNvbnMtYmxvY2sge2Rpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgYm9yZGVyLWNvbG9yOmdyYXk7IG1hcmdpbjogMCAxcHg7IHBvc2l0aW9uOiByZWxhdGl2ZTsgYm9yZGVyLXJhZGl1czogMTBweDsgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZlZjsgYm9yZGVyOiAxcHggc29saWQgI2QzZDNkMzsgcGFkZGluZzogNXB4IDEwcHg7IG1hcmdpbi10b3A6IDVweDt9XFxuJztcbiAgICAgICAgc2hlZXQuaW5uZXJIVE1MICs9ICcuZHJvcC1hcmVhIC5wYXJzb25zLWJsb2NrLmluY29ycmVjdFBvc2l0aW9uIHtiYWNrZ3JvdW5kLWNvbG9yOiAjZmZiYWJhOyBib3JkZXI6IDFweCBzb2xpZCByZWQ7fVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLnBhcnNvbnMtYmxvY2s6aG92ZXIsIC5wYXJzb25zLWJsb2NrOmZvY3VzIHsgYm9yZGVyLWNvbG9yOiBibGFjazt9XFxuJztcbiAgICAgICAgc2hlZXQuaW5uZXJIVE1MICs9ICcuZHJvcC1hcmVhIHsgYmFja2dyb3VuZC1jb2xvcjogI2ZmYTsgcGFkZGluZzogMCA1cHg7IGhlaWdodDogNDJweDsgbWFyZ2luOiAycHggMDt9XFxuJztcbiAgICAgICAgc2hlZXQuaW5uZXJIVE1MICs9ICcuZHJvcC1hcmVhLmluY29ycmVjdCB7IGJhY2tncm91bmQtY29sb3I6ICNmMmRlZGU7IGJvcmRlci1jb2xvcjogI2YyYjZiNn1cXG4nO1xuICAgICAgICBzaGVldC5pbm5lckhUTUwgKz0gJy5kcm9wLWFyZWEuY29ycmVjdCB7IGJhY2tncm91bmQtY29sb3I6ICNkZmYwZDg7IGJvcmRlci1jb2xvcjogI2FkZTU5NX1cXG4nO1xuICAgICAgICAvLyBUT0RPOihVSSkgbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgdG9wIG9mIHRoZSBsaW5lXG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLnBhcnNvbnMtYmxvY2sgLnRvb2x0aXAgeyB2aXNpYmlsaXR5OiBoaWRkZW47IHdpZHRoOiAyMDBweDsgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBjb2xvcjogI2ZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyBwYWRkaW5nOiA1cHggMDsgYm9yZGVyLXJhZGl1czogNnB4OyAgcG9zaXRpb246IGFic29sdXRlOyB6LWluZGV4OiAxOyBtYXJnaW46IDAgMTBweDsgYm90dG9tOiAxMjAlOyBtYXJnaW4tbGVmdDogLTEwMHB4O31cXG4nO1xuICAgICAgICBzaGVldC5pbm5lckhUTUwgKz0gJy5wYXJzb25zLWJsb2NrIC50b29sdGlwOjphZnRlciB7Y29udGVudDogXCIgXCI7cG9zaXRpb246IGFic29sdXRlOyB0b3A6IDEwMCU7bGVmdDogNTAlOyBtYXJnaW4tbGVmdDogLTVweDsgYm9yZGVyLXdpZHRoOiA1cHg7IGJvcmRlci1zdHlsZTogc29saWQ7IGJvcmRlci1jb2xvcjogYmxhY2sgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7fVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLmRyYWctYXJlYSAucGFyc29ucy1ibG9jazpob3ZlciAudG9vbHRpcCB7IHZpc2liaWxpdHk6IHZpc2libGU7fVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLmRyYWctYXJlYSB7IGJhY2tncm91bmQtY29sb3I6ICNlZmVmZmY7IHBhZGRpbmc6IDAgNXB4OyBoZWlnaHQ6IDQycHg7IG1hcmdpbjogMnB4IDA7IH1cXG4nO1xuICAgICAgICBzaGVldC5pbm5lckhUTUwgKz0gJy5jb250ZXh0LmhpZGUge2Rpc3BsYXk6IG5vbmU7fVxcbic7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCArPSAnLmNvbnRleHQge3BhZGRpbmc6IDAgNHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVhOyBmb250LWZhbWlseTogbW9ub3NwYWNlO31cXG4nO1xuICAgICAgICAvLyB1bml0dGVzdFxuICAgICAgICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoc2hlZXQpO1xuICAgICAgICBjb25zdCBnbG9iYWxfc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBnbG9iYWxfc2hlZXQuaW5uZXJIVE1MICs9ICcucmVnZXgtaW5wdXQgLnFsLWVkaXRvciB7aGVpZ2h0OiBmaXQtY29udGVudDt9XFxuJztcbiAgICAgICAgZ2xvYmFsX3NoZWV0LmlubmVySFRNTCArPSAnLnFsLWVkaXRvciB7IGJveC1zaGFkb3c6IDAgMCAycHggNXB4ICNiMWRhZmE7IG1hcmdpbjogNXB4OyB9XFxuJztcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChnbG9iYWxfc2hlZXQpO1xuICAgIH07XG4gICAgbG9nRXZlbnQgPSAoZXZlbnRDb250ZW50KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB0aGUgbG9nZ2luZyBzY2hlbWUgZm9yIGhvcml6b250YWwgcGFyc29ucyBpbiBnZW5lcmFsLlxuICAgICAgICAvLyBSaWdodCBub3cgaXQgb25seSBkaXNwYXRjaGVzIGV2ZW50IG9mIG1vdmluZyBwYXJzb25zIGJsb2Nrcy5cbiAgICAgICAgY29uc3QgYmFzaWNFdmVudCA9IHtcbiAgICAgICAgICAgICdpbnB1dC10eXBlJzogdGhpcy5pbnB1dFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV2ID0gbmV3IEN1c3RvbUV2ZW50KCdob3Jpem9udGFsLXBhcnNvbnMnLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyAuLi5iYXNpY0V2ZW50LCAuLi5ldmVudENvbnRlbnQgfSB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICB9O1xuICAgIC8vIHByaXZhdGUgX2dldFRpbWVzdGFtcCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgIC8vICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIC8vICAgICByZXR1cm4gdGltZXN0YW1wLmdldEZ1bGxZZWFyKCkgKyAnLycgKyAodGltZXN0YW1wLmdldE1vbnRoKCkgKyAxKSArICcvJyArIHRpbWVzdGFtcC5nZXREYXRlKCkgKyAnLycgKyB0aW1lc3RhbXAuZ2V0SG91cnMoKSArICcvJyArIHRpbWVzdGFtcC5nZXRNaW51dGVzKCkgKyAnLycgKyB0aW1lc3RhbXAuZ2V0U2Vjb25kcygpICsgJy8nICsgdGltZXN0YW1wLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIC8vIH1cbiAgICAvLyAvLyBsb2cgcmVnZXggaW5wdXQgZXZlbnQgYWxvbmcgd2l0aCBjb21waWxhdGlvbiByZXN1bHRcbiAgICAvLyBwcml2YXRlIF9sb2dSZWdleElucHV0RXZlbnQgPSAoKTogdm9pZCA9PiB7XG4gICAgLy8gICAgIC8vIFRPRE86IGp1c3QgdXNpbmcgYW55IGhlcmUuIGJ1dCByZWdleElucHV0RXZlbnQgaXMgYWN0dWFsbHkgUmVnZXhFdmVudC5QYXJzb25zSW5wdXRFdmVudCBvciBGcmVlSW5wdXRFdmVudC4uLiBzbyBtdWNoIHRyb3VibGUgd2l0aCB0eXBpbmchIVxuICAgIC8vICAgICBsZXQgcmVnZXhJbnB1dEV2ZW50OiBhbnkgPSB7XG4gICAgLy8gICAgICAgICAuLi50aGlzLnRlbXBvcmFyeUlucHV0RXZlbnQsXG4gICAgLy8gICAgICAgICB2YWxpZDogdGhpcy5wYXR0ZXJuVmFsaWRGbGFnXG4gICAgLy8gICAgIH07XG4gICAgLy8gICAgIGlmICghdGhpcy5wYXR0ZXJuVmFsaWRGbGFnKSB7XG4gICAgLy8gICAgICAgICAvLyByZWdleElucHV0RXZlbnRbJ2Vycm9yLW1lc3NhZ2UnXSA9IHRoaXMucmVnZXhFcnJvck1lc3NhZ2UuaW5uZXJUZXh0O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRoaXMubG9nRXZlbnQocmVnZXhJbnB1dEV2ZW50KTtcbiAgICAvLyB9XG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lucHV0LXR5cGUnXTsgfVxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdpbnB1dC10eXBlJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFJlZ2V4SW5wdXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UmVnZXhJbnB1dCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dERpdi5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgbGV0IGlucHV0VHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbnB1dC10eXBlJyk7XG4gICAgICAgIHRoaXMuaW5wdXRUeXBlID0gaW5wdXRUeXBlID09ICdwYXJzb25zJyA/ICdwYXJzb25zJyA6ICd0ZXh0JztcbiAgICAgICAgdGhpcy5fcGFyc29uc0RhdGEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wYXJzb25zRXhwbGFuYXRpb24gPSBudWxsO1xuICAgICAgICAvLyB0b2RvOihVSSkgZml4IHRoZSBjc3MgZm9yIHRoZSBpbnB1dFxuICAgICAgICBpZiAodGhpcy5pbnB1dFR5cGUgPT0gJ3BhcnNvbnMnKSB7XG4gICAgICAgICAgICAvLyBpbml0IGVsZW1lbnRzOiBwYXJzb25zIHJlZ2V4IGlucHV0XG4gICAgICAgICAgICBjb25zdCByZXVzYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZXVzZS1ibG9ja3MnKSAhPSBudWxsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmFuZG9taXplID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JhbmRvbWl6ZScpICE9IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQgPSBuZXcgUGFyc29uc0lucHV0KHRoaXMsIHJldXNhYmxlLCByYW5kb21pemUpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dERpdi5hcHBlbmRDaGlsZCh0aGlzLmhwYXJzb25zSW5wdXQuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gKHRoaXMuaW5wdXRUeXBlID09ICd0ZXh0JylcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4X3Nsb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbG90Jyk7XG4gICAgICAgICAgICByZWdleF9zbG90Lm5hbWUgPSAncmVnZXgtaW5wdXQnO1xuICAgICAgICAgICAgdGhpcy5pbnB1dERpdi5hcHBlbmRDaGlsZChyZWdleF9zbG90KTtcbiAgICAgICAgICAgIC8vIFRPRE86IChyZWZhY3RvcikgcmVuYW1lIFJlZ2V4SW5wdXRcbiAgICAgICAgICAgIHRoaXMuaHBhcnNvbnNJbnB1dCA9IG5ldyBUZXh0SW5wdXQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuaHBhcnNvbnNJbnB1dC5lbCk7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuZWwuc2xvdCA9ICdyZWdleC1pbnB1dCc7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuaW5pdFF1aWxsKCk7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQucXVpbGw/Lm9uKCd0ZXh0LWNoYW5nZScsIChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaHBhcnNvbnNJbnB1dC5yZW1vdmVGb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAvLyBsb2dnaW5nIGZyZWUgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlucHV0RXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICdldmVudC10eXBlJzogJ3RleHQtaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBkcm9wcGVkOiB0aGlzLmhwYXJzb25zSW5wdXQuZHJvcHBlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyOiB0aGlzLmhwYXJzb25zSW5wdXQuZ2V0VGV4dCgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuZHJvcHBlZFRleHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9sb2dSZWdleElucHV0RXZlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0SW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0VHlwZSAhPSAncGFyc29ucycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4SW5wdXQgPSB0aGlzLmhwYXJzb25zSW5wdXQ7XG4gICAgICAgICAgICByZWdleElucHV0LnF1aWxsPy5zZXRUZXh0KCcnLCAnc2lsZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbnB1dFR5cGUgPT0gJ3BhcnNvbnMnKSB7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQucmVzZXRJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc2V0RXZlbnQgPSB7XG4gICAgICAgICAgICAnZXZlbnQtdHlwZSc6ICdyZXNldCcsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nRXZlbnQocmVzZXRFdmVudCk7XG4gICAgfVxuICAgIC8vIHJlc3RvcmUgc3R1ZGVudCBhbnN3ZXIgZnJvbSBvdXRzaWRlIHN0b3JhZ2VcbiAgICByZXN0b3JlQW5zd2VyKHR5cGUsIGFuc3dlcikge1xuICAgICAgICBpZiAodHlwZSA9PSB1bmRlZmluZWQgfHwgYW5zd2VyID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaHBhcnNvbnNJbnB1dC5yZXN0b3JlQW5zd2VyKHR5cGUsIGFuc3dlcik7XG4gICAgfVxuICAgIGdldEN1cnJlbnRJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHBhcnNvbnNJbnB1dC5nZXRUZXh0KCk7XG4gICAgfVxuICAgIGdldFBhcnNvbnNUZXh0QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhwYXJzb25zSW5wdXQuX2dldFRleHRBcnJheSgpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0ID0gKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dEJlZm9yZSA9IHRoaXMucXVlcnlTZWxlY3RvcignI2hwYXJzb25zLScgKyB0aGlzLnRvb2xOdW1iZXIgKyAnLWNvbnRleHQtYmVmb3JlJyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRBZnRlciA9IHRoaXMucXVlcnlTZWxlY3RvcignI2hwYXJzb25zLScgKyB0aGlzLnRvb2xOdW1iZXIgKyAnLWNvbnRleHQtYWZ0ZXInKTtcbiAgICAgICAgbGV0IGNvZGVJbmRleCA9IC0xO1xuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpbmRlbnQgPSBjb250ZXh0W2ldLmluZGV4T2YoJyoqKionKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlLmlubmVySFRNTCA9IGNvcmUuaGlnaGxpZ2h0KGNvbnRleHQuc2xpY2UoMCwgY29kZUluZGV4KS5qb2luKCdcXG4nKSwgeyBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0QWZ0ZXIuaW5uZXJIVE1MID0gY29yZS5oaWdobGlnaHQoY29udGV4dC5zbGljZShjb2RlSW5kZXggKyAxKS5qb2luKCdcXG4nKSwgeyBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlLmlubmVyVGV4dCA9IGNvbnRleHQuc2xpY2UoMCwgY29kZUluZGV4KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnRleHRBZnRlci5pbm5lclRleHQgPSBjb250ZXh0LnNsaWNlKGNvZGVJbmRleCArIDEpLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHRCZWZvcmUuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuICAgICAgICBjb250ZXh0QWZ0ZXIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuc2V0SW5kZW50KGluZGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdob3Jpem9udGFsLXBhcnNvbnMnLCBIUGFyc29uc0VsZW1lbnQpO1xuXG5leHBvcnQgeyBIUGFyc29uc0VsZW1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvcml6b250YWwtcGFyc29ucy5qcy5tYXBcbiIsIi8vIGltcG9ydCAnaGFuZHNvbnRhYmxlL2Rpc3QvaGFuZHNvbnRhYmxlLmZ1bGwuY3NzJztcbmltcG9ydCBSdW5lc3RvbmVCYXNlIGZyb20gXCIuLi8uLi9jb21tb24vanMvcnVuZXN0b25lYmFzZS5qc1wiO1xuaW1wb3J0IFwiLi4vY3NzL2hwYXJzb25zLmNzc1wiO1xuaW1wb3J0IFwiLi4vY3NzL2hsanMteGNvZGUuY3NzXCI7XG5pbXBvcnQgQmxvY2tGZWVkYmFjayBmcm9tIFwiLi9CbG9ja0ZlZWRiYWNrLmpzXCI7XG5pbXBvcnQgU1FMRmVlZGJhY2sgZnJvbSBcIi4vU1FMRmVlZGJhY2suanNcIjtcblxuXG5leHBvcnQgdmFyIGhwTGlzdDtcbi8vIERpY3Rpb25hcnkgdGhhdCBjb250YWlucyBhbGwgaW5zdGFuY2VzIG9mIGhvcml6b250YWwgUGFyc29ucyBwcm9ibGVtIG9iamVjdHNcbmlmIChocExpc3QgPT09IHVuZGVmaW5lZCkgaHBMaXN0ID0ge307IFxuXG5cbmltcG9ydCBcIi4vaG9yaXpvbnRhbC1wYXJzb25zLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNRTEhQYXJvbnMgZXh0ZW5kcyBSdW5lc3RvbmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICAvLyBjb3BpZWQgZnJvbSBhY3RpdmVjb2RlXG4gICAgICAgIHZhciBzdWZmU3RhcnQ7XG4gICAgICAgIC8vIGdldHRpbmcgc2V0dGluZ3NcbiAgICAgICAgdmFyIG9yaWcgPSAkKG9wdHMub3JpZykuZmluZChcInRleHRhcmVhXCIpWzBdO1xuICAgICAgICB0aGlzLnJldXNlID0gJChvcmlnKS5kYXRhKCdyZXVzZScpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJhbmRvbWl6ZSA9ICQob3JpZykuZGF0YSgncmFuZG9taXplJykgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMuaXNCbG9ja0dyYWRpbmcgPSAkKG9yaWcpLmRhdGEoJ2Jsb2NrYW5zd2VyJykgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSAkKG9yaWcpLmRhdGEoJ2xhbmd1YWdlJyk7XG4gICAgICAgIGlmICh0aGlzLmlzQmxvY2tHcmFkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrQW5zd2VyID0gJChvcmlnKS5kYXRhKCdibG9ja2Fuc3dlcicpLnNwbGl0KCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXZpZCA9IG9wdHMub3JpZy5pZDtcbiAgICAgICAgdGhpcy5jb250YWluZXJEaXYgPSBvcHRzLm9yaWc7XG4gICAgICAgIHRoaXMudXNlUnVuZXN0b25lU2VydmljZXMgPSBvcHRzLnVzZVJ1bmVzdG9uZVNlcnZpY2VzO1xuICAgICAgICB0aGlzLm9yaWdFbGVtID0gb3JpZztcbiAgICAgICAgdGhpcy5vcmlnVGV4dCA9IHRoaXMub3JpZ0VsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgIHRoaXMuY29kZSA9ICQob3JpZykudGV4dCgpIHx8IFwiXFxuXFxuXFxuXFxuXFxuXCI7XG4gICAgICAgIHRoaXMuZGJ1cmwgPSAkKG9yaWcpLmRhdGEoXCJkYnVybFwiKTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnNhdmVCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLm91dGVyRGl2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250cm9sRGl2ID0gbnVsbDtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5jb2RlKVxuXG4gICAgICAgIHRoaXMub3JpZ2luYWxCbG9ja3MgPSB0aGlzLmdldFNldHRpbmdzKCctLWJsb2Nrcy0tJyk7XG4gICAgICAgIHRoaXMudW5pdHRlc3QgPSB0aGlzLmdldFNldHRpbmdzKCctLXVuaXR0ZXN0LS0nKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5nZXRTZXR0aW5ncygnLS1jb250ZXh0LS0nKTtcblxuICAgICAgICAvLyBDaGFuZ2UgdG8gZmFjdG9yeSB3aGVuIG1vcmUgZXhlY3V0aW9uIGJhc2VkIGZlZWRiYWNrIGlzIGluY2x1ZGVkXG4gICAgICAgIGlmICh0aGlzLmlzQmxvY2tHcmFkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrQ29udHJvbGxlciA9IG5ldyBCbG9ja0ZlZWRiYWNrKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja0NvbnRyb2xsZXIgPSBuZXcgU1FMRmVlZGJhY2sodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGluZyBVSSBjb21wb25lbnRzXG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlT3V0cHV0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja0NvbnRyb2xsZXIuY3VzdG9taXplVUkoKTtcblxuICAgICAgICBpZiAoJChvcmlnKS5kYXRhKFwiY2FwdGlvblwiKSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0aW9uID0gJChvcmlnKS5kYXRhKFwiY2FwdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdGlvbiA9IFwiSG9yaXpvbnRhbFBhcnNvbnNcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENhcHRpb24oXCJydW5lc3RvbmVcIik7XG4gICAgICAgIHRoaXMuaW5kaWNhdGVfY29tcG9uZW50X3JlYWR5KCk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIGZ1bmN0aW9uYWxpdGllcyBmb3IgZGlmZmVyZW50IGZlZWRiYWNrXG4gICAgICAgIHRoaXMuZmVlZGJhY2tDb250cm9sbGVyLmluaXQoKTtcbiAgICB9XG5cbiAgICBnZXRTZXR0aW5ncyhkZWxpbWl0aWVyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0ID0gdGhpcy5jb2RlLmluZGV4T2YoZGVsaW1pdGllcik7XG4gICAgICAgIGlmIChzdCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgc3ViU3RyaW5nID0gdGhpcy5jb2RlLnN1YnN0cmluZyhzdCk7XG4gICAgICAgICAgICBsZXQgZWQgPSBzdWJTdHJpbmcuaW5kZXhPZignXFxuLS0nKTtcbiAgICAgICAgICAgIHN1YlN0cmluZyA9IGVkID4gLTEgPyBzdWJTdHJpbmcuc3Vic3RyaW5nKDAsIGVkICsgMSkgOiBzdWJTdHJpbmc7XG4gICAgICAgICAgICBjb250ZW50ID0gc3ViU3RyaW5nLnNwbGl0KCdcXG4nKS5zbGljZSgxLC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cblxuICAgIC8vIGNvcGllZCBmcm9tIGFjdGl2ZWNvZGUsIGFscmVhZHkgbW9kaWZpZWQgdG8gYWRkIHBhcnNvbnNcbiAgICBjcmVhdGVFZGl0b3IoKSB7XG4gICAgICAgIHRoaXMub3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKHRoaXMub3JpZ0VsZW0pLnJlcGxhY2VXaXRoKHRoaXMub3V0ZXJEaXYpO1xuICAgICAgICBsZXQgcGFyc29uc0hUTUwgPSBgPGhvcml6b250YWwtcGFyc29ucyBpZD0nJHt0aGlzLmRpdmlkfS1ocGFyc29ucydgXG4gICAgICAgIHBhcnNvbnNIVE1MICs9IGAgaW5wdXQtdHlwZT0ncGFyc29ucycgYDtcbiAgICAgICAgaWYgKHRoaXMucmV1c2UpIHtcbiAgICAgICAgICAgIHBhcnNvbnNIVE1MICs9IGAgcmV1c2UtYmxvY2tzPVwidHJ1ZVwiYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIHBhcnNvbnNIVE1MICs9IGAgcmFuZG9taXplPVwidHJ1ZVwiYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgICAgcGFyc29uc0hUTUwgKz0gYCBsYW5ndWFnZT1cImAgKyB0aGlzLmxhbmd1YWdlICsgYFwiYDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzb25zSFRNTCArPSBgPmBcbiAgICAgICAgdGhpcy5vdXRlckRpdi5pbm5lckhUTUwgPSBwYXJzb25zSFRNTDtcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hZGRFdmVudExpc3RlbmVyKCdob3Jpem9udGFsLXBhcnNvbnMnLCAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nSG9yaXpvbnRhbFBhcnNvbnNFdmVudChldi5kZXRhaWwpXG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrQ29udHJvbGxlci5jbGVhckZlZWRiYWNrKCk7XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuaHBhcnNvbnNJbnB1dCA9ICQodGhpcy5vdXRlckRpdikuZmluZChcImhvcml6b250YWwtcGFyc29uc1wiKVswXTtcbiAgICAgICAgdGhpcy5ocGFyc29uc0lucHV0LnBhcnNvbnNEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm9yaWdpbmFsQmxvY2tzKSk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXQgY29udGV4dCBocGFyc29ucycpXG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQuc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlT3V0cHV0KCkge1xuICAgICAgICB0aGlzLmZlZWRiYWNrQ29udHJvbGxlci5jcmVhdGVPdXRwdXQoKTtcbiAgICB9XG5cbiAgICAvLyBjb3BpZWQgZnJvbSBhY3RpdmVjb2RlXG4gICAgY3JlYXRlQ29udHJvbHMoKSB7XG4gICAgICAgIHZhciBjdHJsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgJChjdHJsRGl2KS5hZGRDbGFzcyhcImhwX2FjdGlvbnNcIik7XG4gICAgICAgICQoY3RybERpdikuYWRkQ2xhc3MoXCJjb2wtbWQtMTJcIik7XG5cbiAgICAgICAgLy8gUnVuIEJ1dHRvblxuICAgICAgICB0aGlzLnJ1bkJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLmFkZENsYXNzKFwiYnRuIGJ0bi1zdWNjZXNzIHJ1bi1idXR0b25cIik7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQodGhpcy5ydW5CdXR0b24pO1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikudGV4dChcIlJ1blwiKTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tDb250cm9sbGVyLnJ1bkJ1dHRvbkhhbmRsZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IGJ1dHRvblxuICAgICAgICB2YXIgcmVzZXRCdG47XG4gICAgICAgIHJlc2V0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgJChyZXNldEJ0bikudGV4dChcIlJlc2V0XCIpO1xuICAgICAgICAkKHJlc2V0QnRuKS5hZGRDbGFzcyhcImJ0biBidG4td2FybmluZyBydW4tYnV0dG9uXCIpO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKHJlc2V0QnRuKTtcbiAgICAgICAgdGhpcy5yZXNldEJ1dHRvbiA9IHJlc2V0QnRuO1xuICAgICAgICB0aGlzLnJlc2V0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhwYXJzb25zSW5wdXQucmVzZXRJbnB1dCgpO1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja0NvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICAkKHJlc2V0QnRuKS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcblxuICAgICAgICAkKHRoaXMub3V0ZXJEaXYpLnByZXBlbmQoY3RybERpdik7XG4gICAgICAgIHRoaXMuY29udHJvbERpdiA9IGN0cmxEaXY7XG4gICAgfVxuXG4gICAgbG9nSG9yaXpvbnRhbFBhcnNvbnNFdmVudChocGFyc29uc0V2ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IG1pZ2h0IG5lZWQgdG8gZmluZCBhbm90aGVyIHdheSB0byBjaGFuZ2UgXCJhY3RcIi4gXG4gICAgICAgIC8vIFRoZSBldmVudCBzdHJpbmcgaXMgcHJvYmFibHkgdG9vIGxvbmcuXG4gICAgICAgIGxldCBldiA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBcImhwYXJzb25zXCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICBhY3Q6IEpTT04uc3RyaW5naWZ5KGhwYXJzb25zRXZlbnQpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudChldik7XG4gICAgfVxufVxuXG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG49PSBGaW5kIHRoZSBjdXN0b20gSFRNTCB0YWdzIGFuZCA9PVxuPT0gICBleGVjdXRlIG91ciBjb2RlIG9uIHRoZW0gICAgPT1cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4kKGRvY3VtZW50KS5iaW5kKFwicnVuZXN0b25lOmxvZ2luLWNvbXBsZXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAkKFwiW2RhdGEtY29tcG9uZW50PWhwYXJzb25zXVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCQodGhpcykuY2xvc2VzdChcIltkYXRhLWNvbXBvbmVudD10aW1lZEFzc2Vzc21lbnRdXCIpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgZXhpc3RzIHdpdGhpbiBhIHRpbWVkIGNvbXBvbmVudCwgZG9uJ3QgcmVuZGVyIGl0IGhlcmVcbiAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAgICAgaHBMaXN0W3RoaXMuaWRdID0gbmV3IFNRTEhQYXJvbnMoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB1c2VSdW5lc3RvbmVTZXJ2aWNlczogZUJvb2tDb25maWcudXNlUnVuZXN0b25lU2VydmljZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhgRXJyb3IgcmVuZGVyaW5nIFNob3J0QW5zd2VyIFByb2JsZW0gJHt0aGlzLmlkfVxuICAgICAgICAgICAgLy8gICAgIERldGFpbHM6ICR7ZXJyfWApO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEhQYXJzb25zRmVlZGJhY2sge1xuICAgIGNvbnN0cnVjdG9yKGhwYXJzb25zKSB7XG4gICAgICAgIHRoaXMuaHBhcnNvbnMgPSBocGFyc29ucztcbiAgICB9XG4gICAgY3JlYXRlT3V0cHV0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygnY3JlYXRlT3V0cHV0IG1ldGhvZCBub3QgaW1wbGVtZW50ZWQgaW4gZmVlZGJhY2shJyk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkJ1dHRvbkhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdydW5CdXR0b25DbGlja2VkIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQgaW4gZmVlZGJhY2shJyk7XG4gICAgfVxuICAgIGN1c3RvbWl6ZVVJKCkge1xuICAgICAgICAvLyB1c2VkIHRvIGNoYW5nZSBzb21lIG1pbm9yIFVJLCBlLmcuIHRoZSB0ZXh0IG9uIFJ1biBidXR0b25cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgLy8gaW5pdGxpemF0aW9ucyBmdW5jdGlvbmFsaXRpZXMgc3VjaCBhcyBwcmVwYXJpbmcgU1FMLFxuICAgICAgICAvLyBvciBjaGVja2luZyByZWxhdGVkIG9wdGlvbnNcbiAgICB9XG5cbiAgICBjbGVhckZlZWRiYWNrKCkge1xuICAgICAgICAvLyBjYWxsZWQgd2hlbiBpbnB1dCBpcyBjaGFuZ2VkXG4gICAgICAgIGNvbnNvbGUubG9nKCdjbGVhckZlZWRiYWNrIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQgaW4gZmVlZGJhY2shJyk7XG4gICAgfVxuICAgIFxuICAgIHJlc2V0KCkge1xuICAgICAgICAvLyBjYWxsZWQgd2hlbiByZXNldCBpcyBjbGlja2VkXG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXNldCBtZXRob2Qgbm90IGltcGxlbWVudGVkIGluIGZlZWRiYWNrIScpO1xuICAgIH1cbn1cbiIsIiQuaTE4bigpLmxvYWQoe1xuICAgIGVuOiB7XG4gICAgICAgIG1zZ19wYXJzb25fY2hlY2tfbWU6IFwiQ2hlY2tcIixcbiAgICAgICAgbXNnX3BhcnNvbl9yZXNldDogXCJSZXNldFwiLFxuICAgICAgICBtc2dfcGFyc29uX2hlbHA6IFwiSGVscCBtZVwiLFxuICAgICAgICBtc2dfcGFyc29uX3Rvb19zaG9ydDogXCJZb3VyIHByb2dyYW0gaXMgdG9vIHNob3J0LiBBZGQgbW9yZSBibG9ja3MuXCIsXG4gICAgICAgIG1zZ19wYXJzb25fZHJhZ19mcm9tX2hlcmU6IFwiRHJhZyBmcm9tIGhlcmVcIixcbiAgICAgICAgbXNnX3BhcnNvbl9kcmFnX3RvX2hlcmU6IFwiRHJvcCBibG9ja3MgaGVyZVwiLFxuICAgICAgICBtc2dfcGFyc29uX2NvcnJlY3RfZmlyc3RfdHJ5OlxuICAgICAgICAgICAgXCJQZXJmZWN0ISAgSXQgdG9vayB5b3Ugb25seSBvbmUgdHJ5IHRvIHNvbHZlIHRoaXMuICBHcmVhdCBqb2IhXCIsXG4gICAgICAgIG1zZ19wYXJzb25fY29ycmVjdDpcbiAgICAgICAgICAgIFwiUGVyZmVjdCEgIEl0IHRvb2sgeW91ICQxIHRyaWVzIHRvIHNvbHZlIHRoaXMuICBDbGljayBSZXNldCB0byB0cnkgdG8gc29sdmUgaXQgaW4gb25lIGF0dGVtcHQuXCIsXG4gICAgICAgIG1zZ19wYXJzb25fd3JvbmdfaW5kZW50OlxuICAgICAgICAgICAgXCJUaGlzIGJsb2NrIGlzIG5vdCBpbmRlbnRlZCBjb3JyZWN0bHkuIEVpdGhlciBpbmRlbnQgaXQgbW9yZSBieSBkcmFnZ2luZyBpdCByaWdodCBvciByZWR1Y2UgdGhlIGluZGVudGlvbiBieSBkcmFnZ2luZyBpdCBsZWZ0LlwiLFxuICAgICAgICBtc2dfcGFyc29uX3dyb25nX2luZGVudHM6XG4gICAgICAgICAgICBcIlRoZXNlIGJsb2NrcyBhcmUgbm90IGluZGVudGVkIGNvcnJlY3RseS4gVG8gaW5kZW50IGEgYmxvY2sgbW9yZSwgZHJhZyBpdCB0byB0aGUgcmlnaHQuIFRvIHJlZHVjZSB0aGUgaW5kZW50aW9uLCBkcmFnIGl0IHRvIHRoZSBsZWZ0LlwiLFxuICAgICAgICBtc2dfcGFyc29uX3dyb25nX29yZGVyOlxuICAgICAgICAgICAgXCJIaWdobGlnaHRlZCBibG9ja3MgaW4geW91ciBwcm9ncmFtIGFyZSB3cm9uZyBvciBhcmUgaW4gdGhlIHdyb25nIG9yZGVyLiBUaGlzIGNhbiBiZSBmaXhlZCBieSBtb3ZpbmcsIHJlbW92aW5nLCBvciByZXBsYWNpbmcgaGlnaGxpZ2h0ZWQgYmxvY2tzLlwiLFxuICAgICAgICBtc2dfcGFyc29uX2Fycm93X25hdmlnYXRlOlxuICAgICAgICAgICAgXCJBcnJvdyBrZXlzIHRvIG5hdmlnYXRlLiBTcGFjZSB0byBzZWxlY3QgLyBkZXNlbGVjdCBibG9jayB0byBtb3ZlLlwiLFxuICAgICAgICBtc2dfcGFyc29uX2hlbHBfaW5mbzpcbiAgICAgICAgICAgIFwiQ2xpY2sgb24gdGhlIEhlbHAgTWUgYnV0dG9uIGlmIHlvdSB3YW50IHRvIG1ha2UgdGhlIHByb2JsZW0gZWFzaWVyXCIsXG4gICAgICAgIG1zZ19wYXJzb25fbm90X3NvbHV0aW9uOlxuICAgICAgICAgICAgXCJEaXNhYmxlZCBhbiB1bm5lZWRlZCBjb2RlIGJsb2NrIChvbmUgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgc29sdXRpb24pLlwiLFxuICAgICAgICBtc2dfcGFyc29uX3Byb3ZpZGVkX2luZGVudDogXCJQcm92aWRlZCB0aGUgaW5kZW50YXRpb24uXCIsXG4gICAgICAgIG1zZ19wYXJzb25fY29tYmluZWRfYmxvY2tzOiBcIkNvbWJpbmVkIHR3byBjb2RlIGJsb2NrcyBpbnRvIG9uZS5cIixcbiAgICAgICAgbXNnX3BhcnNvbl9yZW1vdmVfaW5jb3JyZWN0OlxuICAgICAgICAgICAgXCJXaWxsIHJlbW92ZSBhbiBpbmNvcnJlY3QgY29kZSBibG9jayBmcm9tIGFuc3dlciBhcmVhXCIsXG4gICAgICAgIG1zZ19wYXJzb25fd2lsbF9jb21iaW5lOiBcIldpbGwgY29tYmluZSB0d28gYmxvY2tzXCIsXG4gICAgICAgIG1zZ19wYXJzb25fYXRsZWFzdF90aHJlZV9hdHRlbXB0czpcbiAgICAgICAgICAgIFwiWW91IG11c3QgbWFrZSBhdCBsZWFzdCB0aHJlZSBkaXN0aW5jdCBmdWxsIGF0dGVtcHRzIGF0IGEgc29sdXRpb24gYmVmb3JlIHlvdSBjYW4gZ2V0IGhlbHBcIixcbiAgICAgICAgbXNnX3BhcnNvbl90aHJlZV9ibG9ja3NfbGVmdDpcbiAgICAgICAgICAgIFwiVGhlcmUgYXJlIG9ubHkgMyBjb3JyZWN0IGJsb2NrcyBsZWZ0LiAgWW91IHNob3VsZCBiZSBhYmxlIHRvIHB1dCB0aGVtIGluIG9yZGVyXCIsXG4gICAgICAgIG1zZ19wYXJzb25fd2lsbF9wcm92aWRlX2luZGVudDogXCJXaWxsIHByb3ZpZGUgaW5kZW50YXRpb25cIixcbiAgICB9LFxufSk7XG4iLCIkLmkxOG4oKS5sb2FkKHtcbiAgICBcInB0LWJyXCI6IHtcbiAgICAgICAgbXNnX3BhcnNvbl9jaGVja19tZTogXCJWZXJpZmljYXJcIixcbiAgICAgICAgbXNnX3BhcnNvbl9yZXNldDogXCJSZXNldGFyXCIsXG4gICAgICAgIG1zZ19wYXJzb25faGVscDpcIkFqdWRhXCIsXG4gICAgICAgIG1zZ19wYXJzb25fdG9vX3Nob3J0OiBcIlNldSBwcm9ncmFtYSDDqSBtdWl0byBjdXJ0by4gQWRpY2lvbmUgbWFpcyBibG9jb3MuXCIsXG4gICAgICAgIG1zZ19wYXJzb25fZHJhZ19mcm9tX2hlcmU6IFwiQXJyYXN0ZSBkYXF1aVwiLFxuICAgICAgICBtc2dfcGFyc29uX2RyYWdfdG9faGVyZTogXCJMYXJndWUgb3MgYmxvY29zIGFxdWlcIixcbiAgICAgICAgbXNnX3BhcnNvbl9jb3JyZWN0X2ZpcnN0X3RyeTpcbiAgICAgICAgICAgIFwiUGVyZmVpdG8hIFZvY8OqIGxldm91IGFwZW5hcyB1bWEgdGVudGF0aXZhIHBhcmEgcmVzb2x2ZXIuIEJvbSB0cmFiYWxobyFcIixcbiAgICAgICAgbXNnX3BhcnNvbl9jb3JyZWN0OlxuICAgICAgICAgICAgXCJQZXJmZWl0byEgVm9jw6ogbGV2b3UgJDEgdGVudGF0aXZhcyBwYXJhIHJlc29sdmVyLiBDbGlxdWUgZW0gUmVzZXRhciBwYXJhIHRlbnRhciByZXNvbHZlciBlbSB1bWEgdGVudGF0aXZhLlwiICxcbiAgICAgICAgbXNnX3BhcnNvbl93cm9uZ19pbmRlbnQ6XG4gICAgICAgICAgICBcIkVzdGUgYmxvY28gbsOjbyBlc3TDoSBpbmRlbnRhZG8gY29ycmV0YW1lbnRlLiBJbmRlbnRlIG1haXMgYXJyYXN0YW5kby1vIHBhcmEgYSBkaXJlaXRhIG91IHJlZHV6YSBhIGluZGVudGHDp8OjbyBhcnJhc3RhbmRvIHBhcmEgYSBlc3F1ZXJkYS5cIixcbiAgICAgICAgbXNnX3BhcnNvbl93cm9uZ19pbmRlbnRzOlxuICAgICAgICAgICAgXCJFc3RlcyBibG9jb3MgbsOjbyBlc3TDo28gaW5kZW50YWRvcyBjb3JyZXRhbWVudGUuIFBhcmEgaW5kZW50YXIgbWFpcywgYXJyYXN0ZSBvIGJsb2NvIHBhcmEgYSBkaXJlaXRhLiBQYXJhIHJlZHV6aXIgYSBpbmRlbnRhw6fDo28sIGFycmFzdGUgcGFyYSBhIGVzcXVlcmRhLlwiLFxuICAgICAgICBtc2dfcGFyc29uX3dyb25nX29yZGVyOlxuICAgICAgICAgICAgXCJCbG9jb3MgZGVzdGFjYWRvcyBubyBzZXUgcHJvZ3JhbWEgZXN0w6NvIGVycmFkb3Mgb3UgZXN0w6NvIG5hIG9yZGVtIGVycmFkYS4gSXNzbyBwb2RlIHNlciByZXNvbHZpZG8gbW92ZW5kbywgZXhjbHVpbmRvIG91IHN1YnN0aXR1aW5kbyBvcyBibG9jb3MgZGVzdGFjYWRvcy5cIixcbiAgICAgICAgbXNnX3BhcnNvbl9hcnJvd19uYXZpZ2F0ZTpcbiAgICAgICAgICAgIFwiVXNlIGFzIHRlY2xhcyBkZSBzZXRhcyBwYXJhIG5hdmVnYXIuIEVzcGHDp28gcGFyYSBzZWxlY2lvbmFyLyBkZXNtYXJjYXIgYmxvY29zIHBhcmEgbW92ZXIuXCIsXG4gICAgICAgIG1zZ19wYXJzb25faGVscF9pbmZvOlxuICAgICAgICAgICAgXCJDbGlxdWUgbm8gYm90w6NvIEFqdWRhIHNlIHZvY8OqIHF1aXNlciBmYWNpbGl0YXIgbyBwcm9ibGVtYVwiLFxuICAgICAgICBtc2dfcGFyc29uX25vdF9zb2x1dGlvbjpcbiAgICAgICAgICAgIFwiRm9pIGRlc2FiaWxpdGFkbyB1bSBibG9jbyBkZSBjw7NkaWdvIGRlc25lY2Vzc8OhcmlvIChxdWUgbsOjbyBmYXogcGFydGUgZGEgc29sdcOnw6NvKS5cIixcbiAgICAgICAgbXNnX3BhcnNvbl9wcm92aWRlZF9pbmRlbnQ6XCJGb2kgZm9ybmVjaWRhIGEgaW5kZW50YcOnw6NvLlwiLFxuICAgICAgICBtc2dfcGFyc29uX2NvbWJpbmVkX2Jsb2NrczpcIkRvaXMgYmxvY29zIGRlIGPDs2RpZ29zIGZvcmFtIGNvbWJpbmFkb3MgZW0gdW0uXCIsXG4gICAgICAgIG1zZ19wYXJzb25fcmVtb3ZlX2luY29ycmVjdDpcbiAgICAgICAgICAgIFwiU2Vyw6EgcmVtb3ZpZG8gdW0gYmxvY28gZGUgY8OzZGlnbyBpbmNvcnJldG8gZGEgw6FyZWEgZGUgcmVzcG9zdGFcIixcbiAgICAgICAgbXNnX3BhcnNvbl93aWxsX2NvbWJpbmU6XCJTZXLDo28gY29tYmluYWRvcyBkb2lzIGJsb2Nvc1wiLFxuICAgICAgICBtc2dfcGFyc29uX2F0bGVhc3RfdGhyZWVfYXR0ZW1wdHM6XG4gICAgICAgICAgICBcIlZvY8OqIGRldmUgdGVudGFyIHBlbG8gbWVub3MgdHLDqnMgdmV6ZXMgYW50ZXMgZGUgcGVkaXIgYWp1ZGFcIixcbiAgICAgICAgbXNnX3BhcnNvbl90aHJlZV9ibG9ja3NfbGVmdDpcbiAgICAgICAgICAgIFwiUmVzdGFtIGFwZW5hcyAzIGJsb2NvcyBjb3JyZXRvcy4gVm9jw6ogZGV2ZSBjb2xvY8OhLWxvcyBlbSBvcmRlbVwiLFxuICAgICAgICBtc2dfcGFyc29uX3dpbGxfcHJvdmlkZV9pbmRlbnQ6IFwiU2Vyw6EgZm9ybmVjaWRhIGEgaW5kZW50YcOnw6NvXCJcbiAgICB9LFxufSk7XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=